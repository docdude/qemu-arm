Binary file aarch64-linux-user/qemu-aarch64 matches
Binary file aarch64-softmmu/qemu-system-aarch64 matches
Binary file alpha-linux-user/qemu-alpha matches
Binary file alpha-softmmu/qemu-system-alpha matches
Binary file armeb-linux-user/qemu-armeb matches
Binary file arm-linux-user/qemu-arm matches
Binary file arm-softmmu/dump.o matches
Binary file arm-softmmu/qemu-system-arm matches
Binary file cris-linux-user/qemu-cris matches
Binary file cris-softmmu/qemu-system-cris matches
dump.c:     * dc->buf_size should not be less than size, otherwise dc will never be
dump.c:    assert(size <= dc->buf_size);
dump.c:     * if flag_sync is set, synchronize data in dc->buf into vmcore.
dump.c:     * write the data in dc->buf to dc->fd and reset dc->buf
dump.c:    if ((!flag_sync && dc->data_size + size > dc->buf_size) ||
dump.c:        (flag_sync && dc->data_size > 0)) {
dump.c:        if (write_buffer(dc->fd, dc->offset, dc->buf, dc->data_size) < 0) {
dump.c:        dc->offset += dc->data_size;
dump.c:        dc->data_size = 0;
dump.c:        memcpy(dc->buf + dc->data_size, buf, size);
dump.c:        dc->data_size += size;
faraday.patch:+    dc->vmsd  = &vmstate_wm8731;
faraday.patch~:+    dc->vmsd  = &vmstate_wm8731;
hw/gpio/zaurus.c:    dc->desc = "Scoop2 Sharp custom ASIC";
hw/gpio/zaurus.c:    dc->vmsd = &vmstate_scoop_regs;
hw/gpio/zaurus.c:    dc->props = scoop_sysbus_properties;
hw/gpio/omap_gpio.c:    dc->reset = omap_gpif_reset;
hw/gpio/omap_gpio.c:    dc->props = omap_gpio_properties;
hw/gpio/omap_gpio.c:    dc->cannot_instantiate_with_device_add_yet = true;
hw/gpio/omap_gpio.c:    dc->reset = omap2_gpif_reset;
hw/gpio/omap_gpio.c:    dc->props = omap2_gpio_properties;
hw/gpio/omap_gpio.c:    dc->cannot_instantiate_with_device_add_yet = true;
hw/gpio/max7310.c:    dc->reset = max7310_reset;
hw/gpio/max7310.c:    dc->vmsd = &vmstate_max7310;
hw/gpio/pl061.c:    dc->vmsd = &vmstate_pl061;
hw/gpio/puv3_gpio.c:    sdc->init = puv3_gpio_init;
hw/i2c/exynos4210_i2c.c:    dc->vmsd = &exynos4210_i2c_vmstate;
hw/i2c/exynos4210_i2c.c:    dc->reset = exynos4210_i2c_reset;
hw/i2c/exynos4210_i2c.c:    sbdc->init = exynos4210_i2c_realize;
hw/i2c/omap_i2c.c:    dc->props = omap_i2c_properties;
hw/i2c/omap_i2c.c:    dc->reset = omap_i2c_reset;
hw/i2c/omap_i2c.c:    dc->cannot_instantiate_with_device_add_yet = true;
hw/i2c/omap_i2c.c:    dc->vmsd = &vmstate_omap_i2c;
hw/i2c/smbus_eeprom.c:    dc->props = smbus_eeprom_properties;
hw/i2c/smbus_eeprom.c:    dc->cannot_instantiate_with_device_add_yet = true;
hw/i2c/bitbang_i2c.c:    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);
hw/i2c/bitbang_i2c.c:    dc->desc = "Virtual GPIO to I2C bridge";
hw/i2c/ddc.c:    dc->reset = i2c_ddc_reset;
hw/i2c/smbus_ich9.c:    dc->vmsd = &vmstate_ich9_smbus;
hw/i2c/smbus_ich9.c:    dc->desc = "ICH9 SMBUS Bridge";
hw/i2c/smbus_ich9.c:    dc->cannot_instantiate_with_device_add_yet = true;
hw/pci-bridge/i82801b11.c:    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);
hw/pci-bridge/ioh3420.c:    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);
hw/pci-bridge/ioh3420.c:    dc->desc = "Intel IOH device id 3420 PCIE Root Port";
hw/pci-bridge/ioh3420.c:    dc->reset = ioh3420_reset;
hw/pci-bridge/ioh3420.c:    dc->vmsd = &vmstate_ioh3420;
hw/pci-bridge/dec.c:    dc->desc = "DEC 21154 PCI-PCI bridge";
hw/pci-bridge/dec.c:    dc->reset = pci_bridge_reset;
hw/pci-bridge/dec.c:    dc->vmsd = &vmstate_pci_device;
hw/pci-bridge/dec.c:    dc->cannot_instantiate_with_device_add_yet = true;
hw/pci-bridge/dec.c:    sdc->init = pci_dec_21154_device_init;
hw/pci-bridge/pci_bridge_dev.c:    dc->desc = "Standard PCI Bridge";
hw/pci-bridge/pci_bridge_dev.c:    dc->reset = qdev_pci_bridge_dev_reset;
hw/pci-bridge/pci_bridge_dev.c:    dc->props = pci_bridge_dev_properties;
hw/pci-bridge/pci_bridge_dev.c:    dc->vmsd = &pci_bridge_dev_vmstate;
hw/pci-bridge/pci_bridge_dev.c:    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);
hw/pci-bridge/xio3130_upstream.c:    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);
hw/pci-bridge/xio3130_upstream.c:    dc->desc = "TI X3130 Upstream Port of PCI Express Switch";
hw/pci-bridge/xio3130_upstream.c:    dc->reset = xio3130_upstream_reset;
hw/pci-bridge/xio3130_upstream.c:    dc->vmsd = &vmstate_xio3130_upstream;
hw/pci-bridge/xio3130_downstream.c:    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);
hw/pci-bridge/xio3130_downstream.c:    dc->desc = "TI X3130 Downstream Port of PCI Express Switch";
hw/pci-bridge/xio3130_downstream.c:    dc->reset = xio3130_downstream_reset;
hw/pci-bridge/xio3130_downstream.c:    dc->vmsd = &vmstate_xio3130_downstream;
hw/watchdog/wdt_ib700.c:    dc->realize = wdt_ib700_realize;
hw/watchdog/wdt_ib700.c:    dc->reset = wdt_ib700_reset;
hw/watchdog/wdt_ib700.c:    dc->vmsd = &vmstate_ib700;
hw/watchdog/wdt_ib700.c:    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
hw/watchdog/wdt_i6300esb.c:    dc->reset = i6300esb_reset;
hw/watchdog/wdt_i6300esb.c:    dc->vmsd = &vmstate_i6300esb;
hw/watchdog/wdt_i6300esb.c:    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
hw/ftahbc020.c:    dc->desc  = TYPE_FTAHBC020;
hw/ftahbc020.c:    dc->vmsd  = &vmstate_ftahbc020;
hw/ftahbc020.c:    dc->reset = ftahbc020_reset;
hw/ftahbc020.c:    dc->realize = ftahbc020_realize;
hw/ftahbc020.c:    dc->no_user = 1;
hw/dma/i82374.c:    dc->realize = i82374_isa_realize;
hw/dma/i82374.c:    dc->vmsd = &vmstate_isa_i82374;
hw/dma/i82374.c:    dc->props = i82374_properties;
hw/dma/pl330.c:    dc->realize = pl330_realize;
hw/dma/pl330.c:    dc->reset = pl330_reset;
hw/dma/pl330.c:    dc->props = pl330_properties;
hw/dma/pl330.c:    dc->vmsd = &vmstate_pl330;
hw/dma/puv3_dma.c:    sdc->init = puv3_dma_init;
hw/dma/xilinx_axidma.c:    dc->realize = xilinx_axidma_realize,
hw/dma/xilinx_axidma.c:    dc->reset = xilinx_axidma_reset;
hw/dma/xilinx_axidma.c:    dc->props = axidma_properties;
hw/dma/sun4m_iommu.c:    dc->reset = iommu_reset;
hw/dma/sun4m_iommu.c:    dc->vmsd = &vmstate_iommu;
hw/dma/sun4m_iommu.c:    dc->props = iommu_properties;
hw/dma/pl080.c:    dc->vmsd = &vmstate_pl080;
hw/dma/pxa2xx_dma.c:    dc->desc = "PXA2xx DMA controller";
hw/dma/pxa2xx_dma.c:    dc->vmsd = &vmstate_pxa2xx_dma;
hw/dma/pxa2xx_dma.c:    dc->props = pxa2xx_dma_properties;
hw/dma/sparc32_dma.c:    dc->reset = dma_reset;
hw/dma/sparc32_dma.c:    dc->vmsd = &vmstate_dma;
hw/dma/sparc32_dma.c:    dc->props = sparc32_dma_properties;
hw/dma/sparc32_dma.c:    dc->cannot_instantiate_with_device_add_yet = true;
hw/sd/omap3_mmc.c:    dc->reset = omap3_mmc_reset;
hw/sd/milkymist-memcard.c:    dc->reset = milkymist_memcard_reset;
hw/sd/milkymist-memcard.c:    dc->vmsd = &vmstate_milkymist_memcard;
hw/sd/sdhci.c:    dc->vmsd = &sdhci_vmstate;
hw/sd/sdhci.c:    dc->props = sdhci_properties;
hw/sd/sdhci.c:    dc->reset = sdhci_generic_reset;
hw/sd/sdhci.c:    dc->realize = sdhci_realize;
hw/sd/pl181.c:    sdc->init = pl181_init;
hw/ftddrii030.c:    dc->desc  = TYPE_FTDDRII030;
hw/ftddrii030.c:    dc->vmsd  = &vmstate_ftddrii030;
hw/ftddrii030.c:    dc->reset = ftddrii030_reset;
hw/ftddrii030.c:    dc->realize = ftddrii030_realize;
hw/ftddrii030.c:    dc->no_user = 1;
hw/ftlcdc200.c:    dc->reset   = ftlcdc200_reset;
hw/ftlcdc200.c:    dc->vmsd    = &vmstate_ftlcdc200;
hw/ftlcdc200.c:    dc->realize = ftlcdc200_realize;
hw/ftlcdc200.c:    dc->no_user = 1;
hw/ftapbbrg020.c:    dc->vmsd    = &vmstate_ftapbbrg020;
hw/ftapbbrg020.c:    dc->reset   = ftapbbrg020_reset;
hw/ftapbbrg020.c:    dc->realize = ftapbbrg020_realize;
hw/ftapbbrg020.c:    dc->no_user = 1;
hw/net/ne2000-isa.c:    dc->realize = isa_ne2000_realizefn;
hw/net/ne2000-isa.c:    dc->props = ne2000_isa_properties;
hw/net/ne2000-isa.c:    set_bit(DEVICE_CATEGORY_NETWORK, dc->categories);
hw/net/xilinx_ethlite.c:    dc->props = xilinx_ethlite_properties;
hw/net/pcnet-pci.c:    dc->reset = pci_reset;
hw/net/pcnet-pci.c:    dc->vmsd = &vmstate_pci_pcnet;
hw/net/pcnet-pci.c:    dc->props = pcnet_properties;
hw/net/pcnet-pci.c:    set_bit(DEVICE_CATEGORY_NETWORK, dc->categories);
hw/net/virtio-net.c:    dc->props = virtio_net_properties;
hw/net/virtio-net.c:    set_bit(DEVICE_CATEGORY_NETWORK, dc->categories);
hw/net/virtio-net.c:    vdc->realize = virtio_net_device_realize;
hw/net/virtio-net.c:    vdc->unrealize = virtio_net_device_unrealize;
hw/net/virtio-net.c:    vdc->get_config = virtio_net_get_config;
hw/net/virtio-net.c:    vdc->set_config = virtio_net_set_config;
hw/net/virtio-net.c:    vdc->get_features = virtio_net_get_features;
hw/net/virtio-net.c:    vdc->set_features = virtio_net_set_features;
hw/net/virtio-net.c:    vdc->bad_features = virtio_net_bad_features;
hw/net/virtio-net.c:    vdc->reset = virtio_net_reset;
hw/net/virtio-net.c:    vdc->set_status = virtio_net_set_status;
hw/net/virtio-net.c:    vdc->guest_notifier_mask = virtio_net_guest_notifier_mask;
hw/net/virtio-net.c:    vdc->guest_notifier_pending = virtio_net_guest_notifier_pending;
hw/net/allwinner_emac.c:    dc->realize = aw_emac_realize;
hw/net/allwinner_emac.c:    dc->props = aw_emac_properties;
hw/net/allwinner_emac.c:    dc->reset = aw_emac_reset;
hw/net/allwinner_emac.c:    dc->vmsd = &vmstate_aw_emac;
hw/net/xgmac.c:    dc->vmsd = &vmstate_xgmac;
hw/net/xgmac.c:    dc->props = xgmac_properties;
hw/net/xilinx_axienet.c:    dc->realize = xilinx_enet_realize;
hw/net/xilinx_axienet.c:    dc->props = xilinx_enet_properties;
hw/net/xilinx_axienet.c:    dc->reset = xilinx_axienet_reset;
hw/net/vmxnet3.c:    dc->desc = "VMWare Paravirtualized Ethernet v3";
hw/net/vmxnet3.c:    dc->reset = vmxnet3_qdev_reset;
hw/net/vmxnet3.c:    dc->vmsd = &vmstate_vmxnet3;
hw/net/vmxnet3.c:    dc->props = vmxnet3_properties;
hw/net/vmxnet3.c:    set_bit(DEVICE_CATEGORY_NETWORK, dc->categories);
hw/net/ne2000.c:    dc->vmsd = &vmstate_pci_ne2000;
hw/net/ne2000.c:    dc->props = ne2000_properties;
hw/net/ne2000.c:    set_bit(DEVICE_CATEGORY_NETWORK, dc->categories);
hw/net/smc91c111.c:    dc->reset = smc91c111_reset;
hw/net/smc91c111.c:    dc->vmsd = &vmstate_smc91c111;
hw/net/smc91c111.c:    dc->props = smc91c111_properties;
hw/net/eepro100.c:    set_bit(DEVICE_CATEGORY_NETWORK, dc->categories);
hw/net/eepro100.c:    dc->props = e100_properties;
hw/net/eepro100.c:    dc->desc = info->desc;
hw/net/pcnet.c:        int nnrc = nrdc<=1 ? CSR_RCVRL(s) : nrdc-1;
hw/net/rtl8139.c:    dc->reset = rtl8139_reset;
hw/net/rtl8139.c:    dc->vmsd = &vmstate_rtl8139;
hw/net/rtl8139.c:    dc->props = rtl8139_properties;
hw/net/rtl8139.c:    set_bit(DEVICE_CATEGORY_NETWORK, dc->categories);
hw/net/milkymist-minimac2.c:    dc->reset = milkymist_minimac2_reset;
hw/net/milkymist-minimac2.c:    dc->vmsd = &vmstate_milkymist_minimac2;
hw/net/milkymist-minimac2.c:    dc->props = milkymist_minimac2_properties;
hw/net/opencores_eth.c:    set_bit(DEVICE_CATEGORY_NETWORK, dc->categories);
hw/net/opencores_eth.c:    dc->desc = "Opencores 10/100 Mbit Ethernet";
hw/net/opencores_eth.c:    dc->reset = qdev_open_eth_reset;
hw/net/opencores_eth.c:    dc->props = open_eth_properties;
hw/net/fsl_etsec/etsec.c:    dc->realize = etsec_realize;
hw/net/fsl_etsec/etsec.c:    dc->reset = etsec_reset;
hw/net/fsl_etsec/etsec.c:    dc->props = etsec_properties;
hw/net/spapr_llan.c:    set_bit(DEVICE_CATEGORY_NETWORK, dc->categories);
hw/net/spapr_llan.c:    dc->props = spapr_vlan_properties;
hw/net/spapr_llan.c:    dc->vmsd = &vmstate_spapr_llan;
hw/net/etraxfs_eth.c:    dc->props = etraxfs_eth_properties;
hw/net/etraxfs_eth.c:    dc->cannot_instantiate_with_device_add_yet = true;
hw/net/e1000.c:    set_bit(DEVICE_CATEGORY_NETWORK, dc->categories);
hw/net/e1000.c:    dc->desc = "Intel Gigabit Ethernet";
hw/net/e1000.c:    dc->reset = qdev_e1000_reset;
hw/net/e1000.c:    dc->vmsd = &vmstate_e1000;
hw/net/e1000.c:    dc->props = e1000_properties;
hw/net/lance.c:    set_bit(DEVICE_CATEGORY_NETWORK, dc->categories);
hw/net/lance.c:    dc->fw_name = "ethernet";
hw/net/lance.c:    dc->reset = lance_reset;
hw/net/lance.c:    dc->vmsd = &vmstate_lance;
hw/net/lance.c:    dc->props = lance_properties;
hw/net/lance.c:    dc->cannot_instantiate_with_device_add_yet = true;
hw/net/lan9118.c:    dc->reset = lan9118_reset;
hw/net/lan9118.c:    dc->props = lan9118_properties;
hw/net/lan9118.c:    dc->vmsd = &vmstate_lan9118;
hw/net/stellaris_enet.c:    dc->unrealize = stellaris_enet_unrealize;
hw/net/stellaris_enet.c:    dc->props = stellaris_enet_properties;
hw/net/cadence_gem.c:    sdc->init = gem_init;
hw/net/cadence_gem.c:    dc->props = gem_properties;
hw/net/cadence_gem.c:    dc->vmsd = &vmstate_cadence_gem;
hw/net/cadence_gem.c:    dc->reset = gem_reset;
hw/net/mipsnet.c:    set_bit(DEVICE_CATEGORY_NETWORK, dc->categories);
hw/net/mipsnet.c:    dc->desc = "MIPS Simulator network device";
hw/net/mipsnet.c:    dc->reset = mipsnet_sysbus_reset;
hw/net/mipsnet.c:    dc->vmsd = &vmstate_mipsnet;
hw/net/mipsnet.c:    dc->props = mipsnet_properties;
hw/ftdmac020.c:    dc->vmsd    = &vmstate_ftdmac020;
hw/ftdmac020.c:    dc->reset   = ftdmac020_reset;
hw/ftdmac020.c:    dc->realize = ftdmac020_realize;
hw/ftdmac020.c:    dc->no_user = 1;
hw/pcmcia/pxa2xx.c:    dc->realize = pxa2xx_pcmcia_realize;
hw/sh4/sh_pci.c:    dc->cannot_instantiate_with_device_add_yet = true;
hw/sh4/sh_pci.c:    sdc->init = sh_pci_device_init;
hw/acpi/pcihp.c:    return (pc->is_bridge && !dev->qdev.hotplugged) || !dc->hotpluggable;
hw/acpi/piix4.c:    dc->desc = "PM";
hw/acpi/piix4.c:    dc->vmsd = &vmstate_acpi;
hw/acpi/piix4.c:    dc->props = piix4_pm_properties;
hw/acpi/piix4.c:    dc->cannot_instantiate_with_device_add_yet = true;
hw/acpi/piix4.c:    dc->hotpluggable = false;
hw/isa/isa-bus.c:    dc->fw_name = "isa";
hw/isa/vt82c686.c:    set_bit(DEVICE_CATEGORY_SOUND, dc->categories);
hw/isa/vt82c686.c:    dc->desc = "AC97";
hw/isa/vt82c686.c:    set_bit(DEVICE_CATEGORY_NETWORK, dc->categories);
hw/isa/vt82c686.c:    dc->desc = "MC97";
hw/isa/vt82c686.c:    dc->desc = "PM";
hw/isa/vt82c686.c:    dc->vmsd = &vmstate_acpi;
hw/isa/vt82c686.c:    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);
hw/isa/vt82c686.c:    dc->props = via_pm_properties;
hw/isa/vt82c686.c:    dc->desc = "ISA bridge";
hw/isa/vt82c686.c:    dc->vmsd = &vmstate_via;
hw/isa/vt82c686.c:    dc->cannot_instantiate_with_device_add_yet = true;
hw/isa/lpc_ich9.c:    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);
hw/isa/lpc_ich9.c:    dc->reset = ich9_lpc_reset;
hw/isa/lpc_ich9.c:    dc->vmsd = &vmstate_ich9_lpc;
hw/isa/lpc_ich9.c:    dc->desc = "ICH9 LPC bridge";
hw/isa/lpc_ich9.c:    dc->cannot_instantiate_with_device_add_yet = true;
hw/isa/pc87312.c:    dc->realize = pc87312_realize;
hw/isa/pc87312.c:    dc->reset = pc87312_reset;
hw/isa/pc87312.c:    dc->vmsd = &vmstate_pc87312;
hw/isa/pc87312.c:    dc->props = pc87312_properties;
hw/isa/piix4.c:    dc->desc = "ISA bridge";
hw/isa/piix4.c:    dc->vmsd = &vmstate_piix4;
hw/isa/piix4.c:    dc->cannot_instantiate_with_device_add_yet = true;
hw/isa/piix4.c:    dc->hotpluggable = false;
hw/isa/i82378.c:    dc->vmsd = &vmstate_i82378;
hw/isa/i82378.c:    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);
hw/ftintc020.c:    dc->vmsd    = &vmstate_ftintc020;
hw/ftintc020.c:    dc->reset   = ftintc020_reset;
hw/ftintc020.c:    dc->realize = ftintc020_realize;
hw/ftintc020.c:    dc->no_user = 1;
hw/ftgmac100.c:    dc->vmsd  = &vmstate_ftgmac100;
hw/ftgmac100.c:    dc->props = ftgmac100_properties;
hw/ftgmac100.c:    dc->reset = ftgmac100_reset;
hw/ftgmac100.c:    dc->realize = ftgmac100_realize;
hw/ftgmac100.c:    dc->no_user = 1;
hw/ftmac110.c:    dc->vmsd  = &vmstate_ftmac110;
hw/ftmac110.c:    dc->props = ftmac110_properties;
hw/ftmac110.c:    dc->reset = ftmac110_reset;
hw/ftmac110.c:    dc->realize = ftmac110_realize;
hw/ftmac110.c:    dc->no_user = 1;
hw/i386/kvm/i8254.c:    kpc->parent_realize = dc->realize;
hw/i386/kvm/i8254.c:    dc->realize = kvm_pit_realizefn;
hw/i386/kvm/i8254.c:    dc->reset = kvm_pit_reset;
hw/i386/kvm/i8254.c:    dc->props = kvm_pit_properties;
hw/i386/kvm/clock.c:    dc->realize = kvmclock_realize;
hw/i386/kvm/clock.c:    dc->vmsd = &kvmclock_vmsd;
hw/i386/kvm/pci-assign.c:    dc->props       = assigned_dev_properties;
hw/i386/kvm/pci-assign.c:    dc->vmsd        = &vmstate_assigned_device;
hw/i386/kvm/pci-assign.c:    dc->reset       = reset_assigned_device;
hw/i386/kvm/pci-assign.c:    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
hw/i386/kvm/pci-assign.c:    dc->desc        = "KVM-based PCI passthrough";
hw/i386/kvm/i8259.c:    dc->reset     = kvm_pic_reset;
hw/i386/kvm/i8259.c:    kpc->parent_realize = dc->realize;
hw/i386/kvm/i8259.c:    dc->realize   = kvm_pic_realize;
hw/i386/kvm/ioapic.c:    dc->reset    = kvm_ioapic_reset;
hw/i386/kvm/ioapic.c:    dc->props    = kvm_ioapic_properties;
hw/i386/pc.c:    dc->realize = port92_realizefn;
hw/i386/pc.c:    dc->reset = port92_reset;
hw/i386/pc.c:    dc->vmsd = &vmstate_port92_isa;
hw/i386/pc.c:    dc->cannot_instantiate_with_device_add_yet = true;
hw/i386/acpi-build.c:        if (!dc->hotpluggable || pc->is_bridge) {
hw/i386/kvmvapic.c:    dc->reset   = vapic_reset;
hw/i386/kvmvapic.c:    dc->vmsd    = &vmstate_vapic;
hw/i386/kvmvapic.c:    dc->realize = vapic_realize;
hw/scsi/spapr_vscsi.c:    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
hw/scsi/spapr_vscsi.c:    dc->props = spapr_vscsi_properties;
hw/scsi/spapr_vscsi.c:    dc->vmsd = &vmstate_spapr_vscsi;
hw/scsi/vhost-scsi.c:    dc->props = vhost_scsi_properties;
hw/scsi/vhost-scsi.c:    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
hw/scsi/vhost-scsi.c:    vdc->realize = vhost_scsi_realize;
hw/scsi/vhost-scsi.c:    vdc->unrealize = vhost_scsi_unrealize;
hw/scsi/vhost-scsi.c:    vdc->get_features = vhost_scsi_get_features;
hw/scsi/vhost-scsi.c:    vdc->set_config = vhost_scsi_set_config;
hw/scsi/vhost-scsi.c:    vdc->set_status = vhost_scsi_set_status;
hw/scsi/scsi-disk.c:    dc->fw_name = "disk";
hw/scsi/scsi-disk.c:    dc->desc = "virtual SCSI disk";
hw/scsi/scsi-disk.c:    dc->reset = scsi_disk_reset;
hw/scsi/scsi-disk.c:    dc->props = scsi_hd_properties;
hw/scsi/scsi-disk.c:    dc->vmsd  = &vmstate_scsi_disk_state;
hw/scsi/scsi-disk.c:    dc->fw_name = "disk";
hw/scsi/scsi-disk.c:    dc->desc = "virtual SCSI CD-ROM";
hw/scsi/scsi-disk.c:    dc->reset = scsi_disk_reset;
hw/scsi/scsi-disk.c:    dc->props = scsi_cd_properties;
hw/scsi/scsi-disk.c:    dc->vmsd  = &vmstate_scsi_disk_state;
hw/scsi/scsi-disk.c:    dc->fw_name = "disk";
hw/scsi/scsi-disk.c:    dc->desc = "SCSI block device passthrough";
hw/scsi/scsi-disk.c:    dc->reset = scsi_disk_reset;
hw/scsi/scsi-disk.c:    dc->props = scsi_block_properties;
hw/scsi/scsi-disk.c:    dc->vmsd  = &vmstate_scsi_disk_state;
hw/scsi/scsi-disk.c:    dc->fw_name = "disk";
hw/scsi/scsi-disk.c:    dc->desc = "virtual SCSI disk or CD-ROM (legacy)";
hw/scsi/scsi-disk.c:    dc->reset = scsi_disk_reset;
hw/scsi/scsi-disk.c:    dc->props = scsi_disk_properties;
hw/scsi/scsi-disk.c:    dc->vmsd  = &vmstate_scsi_disk_state;
hw/scsi/megasas.c:    dc->props = megasas_properties;
hw/scsi/megasas.c:    dc->reset = megasas_scsi_reset;
hw/scsi/megasas.c:    dc->vmsd = &vmstate_megasas;
hw/scsi/megasas.c:    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
hw/scsi/megasas.c:    dc->desc = "LSI MegaRAID SAS 1078";
hw/scsi/esp-pci.c:    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
hw/scsi/esp-pci.c:    dc->desc = "AMD Am53c974 PCscsi-PCI SCSI adapter";
hw/scsi/esp-pci.c:    dc->reset = esp_pci_hard_reset;
hw/scsi/esp-pci.c:    dc->vmsd = &vmstate_esp_pci_scsi;
hw/scsi/esp-pci.c:    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
hw/scsi/esp-pci.c:    dc->desc = "Tekram DC-390 SCSI adapter";
hw/scsi/esp.c:    dc->realize = sysbus_esp_realize;
hw/scsi/esp.c:    dc->reset = sysbus_esp_hard_reset;
hw/scsi/esp.c:    dc->vmsd = &vmstate_sysbus_esp_scsi;
hw/scsi/esp.c:    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
hw/scsi/vmw_pvscsi.c:    dc->reset = pvscsi_reset;
hw/scsi/vmw_pvscsi.c:    dc->vmsd = &vmstate_pvscsi;
hw/scsi/vmw_pvscsi.c:    dc->props = pvscsi_properties;
hw/scsi/vmw_pvscsi.c:    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
hw/scsi/virtio-scsi.c:    vdc->get_config = virtio_scsi_get_config;
hw/scsi/virtio-scsi.c:    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
hw/scsi/virtio-scsi.c:    dc->props = virtio_scsi_properties;
hw/scsi/virtio-scsi.c:    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
hw/scsi/virtio-scsi.c:    vdc->realize = virtio_scsi_device_realize;
hw/scsi/virtio-scsi.c:    vdc->unrealize = virtio_scsi_device_unrealize;
hw/scsi/virtio-scsi.c:    vdc->set_config = virtio_scsi_set_config;
hw/scsi/virtio-scsi.c:    vdc->get_features = virtio_scsi_get_features;
hw/scsi/virtio-scsi.c:    vdc->reset = virtio_scsi_reset;
hw/scsi/scsi-generic.c:    dc->fw_name = "disk";
hw/scsi/scsi-generic.c:    dc->desc = "pass through generic scsi device (/dev/sg*)";
hw/scsi/scsi-generic.c:    dc->reset = scsi_generic_reset;
hw/scsi/scsi-generic.c:    dc->props = scsi_generic_properties;
hw/scsi/scsi-generic.c:    dc->vmsd  = &vmstate_scsi_device;
hw/scsi/lsi53c895a.c:    dc->reset = lsi_scsi_reset;
hw/scsi/lsi53c895a.c:    dc->vmsd = &vmstate_lsi_scsi;
hw/scsi/lsi53c895a.c:    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
hw/pci-host/apb.c:    dc->cannot_instantiate_with_device_add_yet = true;
hw/pci-host/apb.c:    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);
hw/pci-host/apb.c:    dc->reset = pci_pbm_reset;
hw/pci-host/apb.c:    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);
hw/pci-host/apb.c:    dc->reset = pci_bridge_reset;
hw/pci-host/apb.c:    dc->vmsd = &vmstate_pci_device;
hw/pci-host/bonito.c:    dc->desc = "Host bridge";
hw/pci-host/bonito.c:    dc->vmsd = &vmstate_bonito;
hw/pci-host/bonito.c:    dc->cannot_instantiate_with_device_add_yet = true;
hw/pci-host/grackle.c:    dc->cannot_instantiate_with_device_add_yet = true;
hw/pci-host/versatile.c:    dc->cannot_instantiate_with_device_add_yet = true;
hw/pci-host/versatile.c:    dc->realize = pci_vpb_realize;
hw/pci-host/versatile.c:    dc->reset = pci_vpb_reset;
hw/pci-host/versatile.c:    dc->vmsd = &pci_vpb_vmstate;
hw/pci-host/versatile.c:    dc->props = pci_vpb_properties;
hw/pci-host/q35.c:    dc->realize = q35_host_realize;
hw/pci-host/q35.c:    dc->props = mch_props;
hw/pci-host/q35.c:    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);
hw/pci-host/q35.c:    dc->fw_name = "pci";
hw/pci-host/q35.c:    dc->reset = mch_reset;
hw/pci-host/q35.c:    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);
hw/pci-host/q35.c:    dc->desc = "Host bridge";
hw/pci-host/q35.c:    dc->vmsd = &vmstate_mch;
hw/pci-host/q35.c:    dc->cannot_instantiate_with_device_add_yet = true;
hw/pci-host/uninorth.c:    dc->cannot_instantiate_with_device_add_yet = true;
hw/pci-host/uninorth.c:    dc->cannot_instantiate_with_device_add_yet = true;
hw/pci-host/uninorth.c:    dc->cannot_instantiate_with_device_add_yet = true;
hw/pci-host/uninorth.c:    dc->cannot_instantiate_with_device_add_yet = true;
hw/pci-host/piix.c:    dc->desc        = "ISA bridge";
hw/pci-host/piix.c:    dc->vmsd        = &vmstate_piix3;
hw/pci-host/piix.c:    dc->hotpluggable   = false;
hw/pci-host/piix.c:    dc->cannot_instantiate_with_device_add_yet = true;
hw/pci-host/piix.c:    dc->desc        = "ISA bridge";
hw/pci-host/piix.c:    dc->vmsd        = &vmstate_piix3;
hw/pci-host/piix.c:    dc->hotpluggable   = false;
hw/pci-host/piix.c:    dc->cannot_instantiate_with_device_add_yet = true;
hw/pci-host/piix.c:    dc->desc = "Host bridge";
hw/pci-host/piix.c:    dc->vmsd = &vmstate_i440fx;
hw/pci-host/piix.c:    dc->cannot_instantiate_with_device_add_yet = true;
hw/pci-host/piix.c:    dc->hotpluggable   = false;
hw/pci-host/piix.c:    dc->realize = i440fx_pcihost_realize;
hw/pci-host/piix.c:    dc->fw_name = "pci";
hw/pci-host/piix.c:    dc->props = i440fx_props;
hw/pci-host/versatile.c~:    dc->cannot_instantiate_with_device_add_yet = true;
hw/pci-host/versatile.c~:    dc->realize = pci_vpb_realize;
hw/pci-host/versatile.c~:    dc->reset = pci_vpb_reset;
hw/pci-host/versatile.c~:    dc->vmsd = &pci_vpb_vmstate;
hw/pci-host/versatile.c~:    dc->props = pci_vpb_properties;
hw/pci-host/ppce500.c:    dc->desc = "Host bridge";
hw/pci-host/ppce500.c:    dc->cannot_instantiate_with_device_add_yet = true;
hw/pci-host/ppce500.c:    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);
hw/pci-host/ppce500.c:    dc->props = pcihost_properties;
hw/pci-host/ppce500.c:    dc->vmsd = &vmstate_ppce500_pci;
hw/pci-host/prep.c:    dc->desc = "PReP Host Bridge - Motorola Raven";
hw/pci-host/prep.c:    dc->vmsd = &vmstate_raven;
hw/pci-host/prep.c:    dc->cannot_instantiate_with_device_add_yet = true;
hw/pci-host/prep.c:    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);
hw/pci-host/prep.c:    dc->realize = raven_pcihost_realizefn;
hw/pci-host/prep.c:    dc->props = raven_pcihost_properties;
hw/pci-host/prep.c:    dc->fw_name = "pci";
hw/sparc64/sun4u.c:    dc->props = prom_properties;
hw/sparc64/sun4u.c:    dc->props = ram_properties;
hw/mips/gt64xxx_pci.c:    dc->cannot_instantiate_with_device_add_yet = true;
hw/mips/gt64xxx_pci.c:    sdc->init = gt64120_init;
hw/ftrtc011.c:    dc->vmsd    = &vmstate_ftrtc011;
hw/ftrtc011.c:    dc->reset   = ftrtc011_reset;
hw/ftrtc011.c:    dc->realize = ftrtc011_realize;
hw/ftrtc011.c:    dc->no_user = 1;
hw/virtio/virtio.c:    if (vdc->realize != NULL) {
hw/virtio/virtio.c:        vdc->realize(dev, &err);
hw/virtio/virtio.c:    if (vdc->unrealize != NULL) {
hw/virtio/virtio.c:        vdc->unrealize(dev, &err);
hw/virtio/virtio.c:    dc->realize = virtio_device_realize;
hw/virtio/virtio.c:    dc->unrealize = virtio_device_unrealize;
hw/virtio/virtio.c:    dc->bus_type = TYPE_VIRTIO_BUS;
hw/virtio/virtio-balloon.c:    dc->props = virtio_balloon_properties;
hw/virtio/virtio-balloon.c:    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
hw/virtio/virtio-balloon.c:    vdc->realize = virtio_balloon_device_realize;
hw/virtio/virtio-balloon.c:    vdc->unrealize = virtio_balloon_device_unrealize;
hw/virtio/virtio-balloon.c:    vdc->get_config = virtio_balloon_get_config;
hw/virtio/virtio-balloon.c:    vdc->set_config = virtio_balloon_set_config;
hw/virtio/virtio-balloon.c:    vdc->get_features = virtio_balloon_get_features;
hw/virtio/virtio-mmio.c:    dc->realize = virtio_mmio_realizefn;
hw/virtio/virtio-mmio.c:    dc->reset = virtio_mmio_reset;
hw/virtio/virtio-mmio.c:    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
hw/virtio/virtio-rng.c:    dc->props = virtio_rng_properties;
hw/virtio/virtio-rng.c:    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
hw/virtio/virtio-rng.c:    vdc->realize = virtio_rng_device_realize;
hw/virtio/virtio-rng.c:    vdc->unrealize = virtio_rng_device_unrealize;
hw/virtio/virtio-rng.c:    vdc->get_features = get_features;
hw/virtio/virtio-pci.c:    if (!msix_enabled(&proxy->pci_dev) && vdc->guest_notifier_mask) {
hw/virtio/virtio-pci.c:        vdc->guest_notifier_mask(vdev, n, !assign);
hw/virtio/virtio-pci.c:    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
hw/virtio/virtio-pci.c:    dc->props = virtio_9p_pci_properties;
hw/virtio/virtio-pci.c:    dc->reset = virtio_pci_reset;
hw/virtio/virtio-pci.c:    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
hw/virtio/virtio-pci.c:    dc->props = virtio_blk_pci_properties;
hw/virtio/virtio-pci.c:    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
hw/virtio/virtio-pci.c:    dc->props = virtio_scsi_pci_properties;
hw/virtio/virtio-pci.c:    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
hw/virtio/virtio-pci.c:    dc->props = vhost_scsi_pci_properties;
hw/virtio/virtio-pci.c:    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
hw/virtio/virtio-pci.c:    dc->props = virtio_balloon_pci_properties;
hw/virtio/virtio-pci.c:    set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
hw/virtio/virtio-pci.c:    dc->props = virtio_serial_pci_properties;
hw/virtio/virtio-pci.c:    set_bit(DEVICE_CATEGORY_NETWORK, dc->categories);
hw/virtio/virtio-pci.c:    dc->props = virtio_net_properties;
hw/virtio/virtio-pci.c:    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
hw/virtio/virtio-pci.c:    dc->props = virtio_rng_pci_properties;
hw/input/tsc210x.c:    dc->reset = tsc2301_reset;
hw/input/lm832x.c:    dc->vmsd = &vmstate_lm_kbd;
hw/input/tsc2005.c:    dc->reset = tsc2005_reset;
hw/input/vmmouse.c:    dc->realize = vmmouse_realizefn;
hw/input/vmmouse.c:    dc->reset = vmmouse_reset;
hw/input/vmmouse.c:    dc->vmsd = &vmstate_vmmouse;
hw/input/vmmouse.c:    dc->props = vmmouse_properties;
hw/input/vmmouse.c:    dc->cannot_instantiate_with_device_add_yet = true;
hw/input/pl050.c:    sdc->init = pl050_initfn;
hw/input/pl050.c:    dc->vmsd = &vmstate_pl050;
hw/input/pckbd.c:    dc->realize = i8042_realizefn;
hw/input/pckbd.c:    dc->vmsd = &vmstate_kbd_isa;
hw/input/adb.c:            return adc->devreq(d, obuf, buf, len);
hw/input/adb.c:    dc->realize = adb_device_realizefn;
hw/input/adb.c:    dc->bus_type = TYPE_ADB_BUS;
hw/input/adb.c:    akc->parent_realize = dc->realize;
hw/input/adb.c:    dc->realize = adb_kbd_realizefn;
hw/input/adb.c:    adc->devreq = adb_kbd_request;
hw/input/adb.c:    dc->reset = adb_kbd_reset;
hw/input/adb.c:    dc->vmsd = &vmstate_adb_kbd;
hw/input/adb.c:    amc->parent_realize = dc->realize;
hw/input/adb.c:    dc->realize = adb_mouse_realizefn;
hw/input/adb.c:    adc->devreq = adb_mouse_request;
hw/input/adb.c:    dc->reset = adb_mouse_reset;
hw/input/adb.c:    dc->vmsd = &vmstate_adb_mouse;
hw/input/milkymist-softusb.c:    dc->reset = milkymist_softusb_reset;
hw/input/milkymist-softusb.c:    dc->vmsd = &vmstate_milkymist_softusb;
hw/input/milkymist-softusb.c:    dc->props = milkymist_softusb_properties;
hw/ftnandc021.c:    dc->vmsd    = &vmstate_ftnandc021;
hw/ftnandc021.c:    dc->reset   = ftnandc021_reset;
hw/ftnandc021.c:    dc->realize = ftnandc021_realize;
hw/ftnandc021.c:    dc->no_user = 1;
hw/timer/pl031.c:    dc->vmsd = &vmstate_pl031;
hw/timer/puv3_ost.c:    sdc->init = puv3_ost_init;
hw/timer/hpet.c:    dc->realize = hpet_realize;
hw/timer/hpet.c:    dc->reset = hpet_reset;
hw/timer/hpet.c:    dc->vmsd = &vmstate_hpet;
hw/timer/hpet.c:    dc->props = hpet_device_properties;
hw/timer/m48t59.c:    dc->realize = m48t59_isa_realize;
hw/timer/m48t59.c:    dc->reset = m48t59_reset_isa;
hw/timer/m48t59.c:    dc->props = m48t59_isa_properties;
hw/timer/m48t59.c:    dc->cannot_instantiate_with_device_add_yet = true;
hw/timer/m48t59.c:    dc->reset = m48t59_reset_sysbus;
hw/timer/m48t59.c:    dc->props = m48t59_properties;
hw/timer/exynos4210_pwm.c:    dc->reset = exynos4210_pwm_reset;
hw/timer/exynos4210_pwm.c:    dc->vmsd = &vmstate_exynos4210_pwm_state;
hw/timer/digic-timer.c:    dc->reset = digic_timer_reset;
hw/timer/digic-timer.c:    dc->vmsd = &vmstate_digic_timer;
hw/timer/slavio_timer.c:    dc->reset = slavio_timer_reset;
hw/timer/slavio_timer.c:    dc->vmsd = &vmstate_slavio_timer;
hw/timer/slavio_timer.c:    dc->props = slavio_timer_properties;
hw/timer/pxa2xx_timer.c:    dc->desc = "PXA25x timer";
hw/timer/pxa2xx_timer.c:    dc->props = pxa25x_timer_dev_properties;
hw/timer/pxa2xx_timer.c:    dc->desc = "PXA27x timer";
hw/timer/pxa2xx_timer.c:    dc->props = pxa27x_timer_dev_properties;
hw/timer/pxa2xx_timer.c:    sdc->init = pxa2xx_timer_init;
hw/timer/pxa2xx_timer.c:    dc->vmsd = &vmstate_pxa2xx_timer_regs;
hw/timer/i8254_common.c:    dc->realize = pit_common_realize;
hw/timer/i8254_common.c:    dc->vmsd = &vmstate_pit_common;
hw/timer/i8254_common.c:    dc->cannot_instantiate_with_device_add_yet = true;
hw/timer/twl92230.c:    dc->vmsd = &vmstate_menelaus;
hw/timer/imx_epit.c:    dc->realize = imx_epit_realize;
hw/timer/imx_epit.c:    dc->reset = imx_epit_reset;
hw/timer/imx_epit.c:    dc->vmsd = &vmstate_imx_timer_epit;
hw/timer/imx_epit.c:    dc->desc = "i.MX periodic timer";
hw/timer/xilinx_timer.c:    dc->props = xilinx_timer_properties;
hw/timer/lm32_timer.c:    dc->reset = timer_reset;
hw/timer/lm32_timer.c:    dc->vmsd = &vmstate_lm32_timer;
hw/timer/lm32_timer.c:    dc->props = lm32_timer_properties;
hw/timer/i8254.c:    pc->parent_realize = dc->realize;
hw/timer/i8254.c:    dc->realize = pit_realizefn;
hw/timer/i8254.c:    dc->reset = pit_reset;
hw/timer/i8254.c:    dc->props = pit_properties;
hw/timer/cadence_ttc.c:    sdc->init = cadence_ttc_init;
hw/timer/cadence_ttc.c:    dc->vmsd = &vmstate_cadence_ttc;
hw/timer/arm_mptimer.c:    dc->realize = arm_mptimer_realize;
hw/timer/arm_mptimer.c:    dc->vmsd = &vmstate_arm_mptimer;
hw/timer/arm_mptimer.c:    dc->reset = arm_mptimer_reset;
hw/timer/arm_mptimer.c:    dc->props = arm_mptimer_properties;
hw/timer/a9gtimer.c~:    dc->realize = a9_gtimer_realize;
hw/timer/a9gtimer.c~:    dc->vmsd = &vmstate_a9_gtimer;
hw/timer/a9gtimer.c~:    dc->reset = a9_gtimer_reset;
hw/timer/a9gtimer.c~:    dc->props = a9_gtimer_properties;
hw/timer/milkymist-sysctl.c:    dc->reset = milkymist_sysctl_reset;
hw/timer/milkymist-sysctl.c:    dc->vmsd = &vmstate_milkymist_sysctl;
hw/timer/milkymist-sysctl.c:    dc->props = milkymist_sysctl_properties;
hw/timer/grlib_gptimer.c:    dc->reset = grlib_gptimer_reset;
hw/timer/grlib_gptimer.c:    dc->props = grlib_gptimer_properties;
hw/timer/mc146818rtc.c:    dc->realize = rtc_realizefn;
hw/timer/mc146818rtc.c:    dc->vmsd = &vmstate_rtc;
hw/timer/mc146818rtc.c:    dc->props = mc146818rtc_properties;
hw/timer/mc146818rtc.c:    dc->cannot_instantiate_with_device_add_yet = true;
hw/timer/exynos4210_rtc.c:    dc->reset = exynos4210_rtc_reset;
hw/timer/exynos4210_rtc.c:    dc->vmsd = &vmstate_exynos4210_rtc_state;
hw/timer/tusb6010.c:    dc->reset = tusb6010_reset;
hw/timer/imx_gpt.c:    dc->realize = imx_gpt_realize;
hw/timer/imx_gpt.c:    dc->reset = imx_gpt_reset;
hw/timer/imx_gpt.c:    dc->vmsd = &vmstate_imx_timer_gpt;
hw/timer/imx_gpt.c:    dc->desc = "i.MX general timer";
hw/timer/exynos4210_mct.c:    dc->reset = exynos4210_mct_reset;
hw/timer/exynos4210_mct.c:    dc->vmsd = &vmstate_exynos4210_mct_state;
hw/timer/ds1338.c:    dc->reset = ds1338_reset;
hw/timer/ds1338.c:    dc->vmsd = &vmstate_ds1338;
hw/timer/etraxfs_timer.c:    sdc->init = etraxfs_timer_init;
hw/timer/arm_timer.c:    sdc->init = icp_pit_init;
hw/timer/arm_timer.c:    sdc->init = sp804_init;
hw/timer/allwinner-a10-pit.c:    dc->reset = a10_pit_reset;
hw/timer/allwinner-a10-pit.c:    dc->desc = "allwinner a10 timer";
hw/timer/allwinner-a10-pit.c:    dc->vmsd = &vmstate_a10_pit;
hw/timer/a9gtimer.c:    dc->realize = a9_gtimer_realize;
hw/timer/a9gtimer.c:    dc->vmsd = &vmstate_a9_gtimer;
hw/timer/a9gtimer.c:    dc->reset = a9_gtimer_reset;
hw/timer/a9gtimer.c:    dc->props = a9_gtimer_properties;
hw/fttsc010.c:    dc->reset   = fttsc010_reset;
hw/fttsc010.c:    dc->realize = fttsc010_realize;
hw/fttsc010.c:    dc->vmsd    = &vmstate_fttsc010;
hw/fttsc010.c:    dc->props   = properties_fttsc010;
hw/fttsc010.c:    dc->no_user = 1;
hw/wm8731.c:    dc->vmsd  = &vmstate_wm8731;
hw/ppc/spapr_iommu.c:    dc->vmsd = &vmstate_spapr_tce_table;
hw/ppc/spapr_iommu.c:    dc->init = spapr_tce_table_realize;
hw/ppc/spapr_iommu.c:    dc->reset = spapr_tce_reset;
hw/ppc/spapr_pci.c:    dc->realize = spapr_phb_realize;
hw/ppc/spapr_pci.c:    dc->props = spapr_phb_properties;
hw/ppc/spapr_pci.c:    dc->reset = spapr_phb_reset;
hw/ppc/spapr_pci.c:    dc->vmsd = &vmstate_spapr_pci;
hw/ppc/spapr_pci.c:    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);
hw/ppc/spapr_pci.c:    dc->cannot_instantiate_with_device_add_yet = false;
hw/ppc/spapr_vio.c:    dc->fw_name = "vdevice";
hw/ppc/spapr.c:        snprintf(cpu_model, 32, "/cpus/%s@%x", dc->fw_name,
hw/ppc/spapr.c:        nodename = g_strdup_printf("%s@%x", dc->fw_name, index);
hw/ppc/ppc4xx_pci.c:    dc->desc        = "Host bridge";
hw/ppc/ppc4xx_pci.c:    dc->cannot_instantiate_with_device_add_yet = true;
hw/ppc/ppc4xx_pci.c:    dc->vmsd = &vmstate_ppc4xx_pci;
hw/ftsdc010.c:    dc->vmsd    = &vmstate_ftsdc010;
hw/ftsdc010.c:    dc->reset   = ftsdc010_reset;
hw/ftsdc010.c:    dc->realize = ftsdc010_realize;
hw/ftsdc010.c:    dc->no_user = 1;
hw/nvram/ds1225y.c:    dc->vmsd = &vmstate_nvram;
hw/nvram/ds1225y.c:    dc->props = nvram_sysbus_properties;
hw/nvram/spapr_nvram.c:    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
hw/nvram/spapr_nvram.c:    dc->props = spapr_nvram_properties;
hw/nvram/mac_nvram.c:    dc->realize = macio_nvram_realizefn;
hw/nvram/mac_nvram.c:    dc->unrealize = macio_nvram_unrealizefn;
hw/nvram/mac_nvram.c:    dc->reset = macio_nvram_reset;
hw/nvram/mac_nvram.c:    dc->vmsd = &vmstate_macio_nvram;
hw/nvram/mac_nvram.c:    dc->props = macio_nvram_properties;
hw/nvram/fw_cfg.c:    dc->realize = fw_cfg_realize;
hw/nvram/fw_cfg.c:    dc->reset = fw_cfg_reset;
hw/nvram/fw_cfg.c:    dc->vmsd = &vmstate_fw_cfg;
hw/nvram/fw_cfg.c:    dc->props = fw_cfg_properties;
hw/intc/arm_gic_common.c:    dc->reset = arm_gic_common_reset;
hw/intc/arm_gic_common.c:    dc->realize = arm_gic_common_realize;
hw/intc/arm_gic_common.c:    dc->props = arm_gic_common_properties;
hw/intc/arm_gic_common.c:    dc->vmsd = &vmstate_gic;
hw/intc/apic_common.c:    dc->vmsd = &vmstate_apic_common;
hw/intc/apic_common.c:    dc->reset = apic_reset_common;
hw/intc/apic_common.c:    dc->props = apic_properties_common;
hw/intc/apic_common.c:    idc->realize = apic_common_realize;
hw/intc/apic_common.c:    dc->cannot_instantiate_with_device_add_yet = true;
hw/intc/openpic_kvm.c:    dc->realize = kvm_openpic_realize;
hw/intc/openpic_kvm.c:    dc->props = kvm_openpic_properties;
hw/intc/openpic_kvm.c:    dc->reset = kvm_openpic_reset;
hw/intc/xics.c:    dc->reset = xics_common_reset;
hw/intc/xics.c:    dc->reset = icp_reset;
hw/intc/xics.c:    dc->vmsd = &vmstate_icp_server;
hw/intc/xics.c:    dc->realize = ics_realize;
hw/intc/xics.c:    dc->vmsd = &vmstate_ics;
hw/intc/xics.c:    dc->reset = ics_reset;
hw/intc/xics.c:    dc->realize = xics_realize;
hw/intc/exynos4210_gic.c:    dc->props = exynos4210_gic_properties;
hw/intc/exynos4210_gic.c:    dc->reset = exynos4210_irq_gate_reset;
hw/intc/exynos4210_gic.c:    dc->vmsd = &vmstate_exynos4210_irq_gate;
hw/intc/exynos4210_gic.c:    dc->props = exynos4210_irq_gate_properties;
hw/intc/etraxfs_pic.c:    dc->props = etraxfs_pic_properties;
hw/intc/etraxfs_pic.c:     * no need for dc->cannot_instantiate_with_device_add_yet = true;
hw/intc/i8259_common.c:    dc->vmsd = &vmstate_pic_common;
hw/intc/i8259_common.c:    dc->props = pic_properties_common;
hw/intc/i8259_common.c:    dc->realize = pic_common_realize;
hw/intc/i8259_common.c:    dc->cannot_instantiate_with_device_add_yet = true;
hw/intc/realview_gic.c:    dc->realize = realview_gic_realize;
hw/intc/broadcom_gic.c:    dc->realize = realview_gic_realize;
hw/intc/armv7m_nvic.c:    nc->parent_reset = dc->reset;
hw/intc/armv7m_nvic.c:    nc->parent_realize = dc->realize;
hw/intc/armv7m_nvic.c:    dc->vmsd  = &vmstate_nvic;
hw/intc/armv7m_nvic.c:    dc->reset = armv7m_nvic_reset;
hw/intc/armv7m_nvic.c:    dc->realize = armv7m_nvic_realize;
hw/intc/arm_gic_kvm.c:    kgc->parent_realize = dc->realize;
hw/intc/arm_gic_kvm.c:    kgc->parent_reset = dc->reset;
hw/intc/arm_gic_kvm.c:    dc->realize = kvm_arm_gic_realize;
hw/intc/arm_gic_kvm.c:    dc->reset = kvm_arm_gic_reset;
hw/intc/arm_gic.c:    agc->parent_realize = dc->realize;
hw/intc/arm_gic.c:    dc->realize = arm_gic_realize;
hw/intc/pl190.c:    dc->reset = pl190_reset;
hw/intc/pl190.c:    dc->vmsd = &vmstate_pl190;
hw/intc/exynos4210_combiner.c:    dc->reset = exynos4210_combiner_reset;
hw/intc/exynos4210_combiner.c:    dc->props = exynos4210_combiner_properties;
hw/intc/exynos4210_combiner.c:    dc->vmsd = &vmstate_exynos4210_combiner;
hw/intc/grlib_irqmp.c:    dc->reset = grlib_irqmp_reset;
hw/intc/grlib_irqmp.c:    dc->props = grlib_irqmp_properties;
hw/intc/grlib_irqmp.c:    dc->cannot_instantiate_with_device_add_yet = true;
hw/intc/puv3_intc.c:    sdc->init = puv3_intc_init;
hw/intc/allwinner-a10-pic.c:    dc->reset = aw_a10_pic_reset;
hw/intc/allwinner-a10-pic.c:    dc->desc = "allwinner a10 pic";
hw/intc/allwinner-a10-pic.c:    dc->vmsd = &vmstate_aw_a10_pic;
hw/intc/xilinx_intc.c:    dc->props = xilinx_intc_properties;
hw/intc/i8259.c:    k->parent_realize = dc->realize;
hw/intc/i8259.c:    dc->realize = pic_realize;
hw/intc/i8259.c:    dc->reset = pic_reset;
hw/intc/ioapic.c:    dc->reset = ioapic_reset_common;
hw/intc/slavio_intctl.c:    dc->reset = slavio_intctl_reset;
hw/intc/slavio_intctl.c:    dc->vmsd = &vmstate_intctl;
hw/intc/s390_flic.c:    dc->realize = kvm_s390_flic_realize;
hw/intc/s390_flic.c:    dc->unrealize = kvm_s390_flic_unrealize;
hw/intc/s390_flic.c:    dc->reset = kvm_s390_flic_reset;
hw/intc/openpic.c:    dc->realize = openpic_realize;
hw/intc/openpic.c:    dc->props = openpic_properties;
hw/intc/openpic.c:    dc->reset = openpic_reset;
hw/intc/imx_avic.c:    dc->vmsd = &vmstate_imx_avic;
hw/intc/imx_avic.c:    dc->reset = imx_avic_reset;
hw/intc/imx_avic.c:    dc->desc = "i.MX Advanced Vector Interrupt Controller";
hw/intc/omap_intc.c:    dc->reset = omap_inth_reset;
hw/intc/omap_intc.c:    dc->props = omap_intc_properties;
hw/intc/omap_intc.c:    dc->cannot_instantiate_with_device_add_yet = true;
hw/intc/omap_intc.c:    dc->reset = omap_inth_reset;
hw/intc/omap_intc.c:    dc->props = omap2_intc_properties;
hw/intc/omap_intc.c:    dc->cannot_instantiate_with_device_add_yet = true;
hw/intc/ioapic_common.c:    dc->realize = ioapic_common_realize;
hw/intc/ioapic_common.c:    dc->vmsd = &vmstate_ioapic_common;
hw/intc/xics_kvm.c:    dc->reset = icp_kvm_reset;
hw/intc/xics_kvm.c:    dc->realize = ics_kvm_realize;
hw/intc/xics_kvm.c:    dc->reset = ics_kvm_reset;
hw/intc/xics_kvm.c:    dc->realize = xics_kvm_realize;
hw/intc/lm32_pic.c:    dc->reset = pic_reset;
hw/intc/lm32_pic.c:    dc->vmsd = &vmstate_lm32_pic;
hw/fttmr010.c:    dc->vmsd    = &vmstate_fttmr010;
hw/fttmr010.c:    dc->props   = fttmr010_properties;
hw/fttmr010.c:    dc->reset   = fttmr010_reset;
hw/fttmr010.c:    dc->realize = fttmr010_realize;
hw/fttmr010.c:    dc->no_user = 1;
hw/ftwdt010.c:    dc->vmsd    = &vmstate_ftwdt010;
hw/ftwdt010.c:    dc->props   = ftwdt010_properties;
hw/ftwdt010.c:    dc->reset   = ftwdt010_reset;
hw/ftwdt010.c:    dc->realize = ftwdt010_realize;
hw/ftwdt010.c:    dc->no_user = 1;
hw/char/sclpconsole-lm.c:    dc->props = console_properties;
hw/char/sclpconsole-lm.c:    dc->reset = console_reset;
hw/char/sclpconsole-lm.c:    dc->vmsd = &vmstate_sclplmconsole;
hw/char/cadence_uart.c:    sdc->init = cadence_uart_init;
hw/char/cadence_uart.c:    dc->vmsd = &vmstate_cadence_uart;
hw/char/cadence_uart.c:    dc->reset = cadence_uart_reset;
hw/char/debugcon.c:    dc->realize = debugcon_isa_realizefn;
hw/char/debugcon.c:    dc->props = debugcon_isa_properties;
hw/char/debugcon.c:    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
hw/char/imx_serial.c:    dc->vmsd = &vmstate_imx_serial;
hw/char/imx_serial.c:    dc->reset = imx_serial_reset_at_boot;
hw/char/imx_serial.c:    set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
hw/char/imx_serial.c:    dc->desc = "i.MX series UART";
hw/char/imx_serial.c:    dc->props = imx32_serial_properties;
hw/char/serial-isa.c:    dc->realize = serial_isa_realizefn;
hw/char/serial-isa.c:    dc->vmsd = &vmstate_isa_serial;
hw/char/serial-isa.c:    dc->props = serial_isa_properties;
hw/char/serial-isa.c:    set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
hw/char/pl011.c:    dc->realize = pl011_realize;
hw/char/pl011.c:    dc->vmsd = &vmstate_pl011;
hw/char/lm32_juart.c:    dc->reset = juart_reset;
hw/char/lm32_juart.c:    dc->vmsd = &vmstate_lm32_juart;
hw/char/xilinx_uartlite.c:    sdc->init = xilinx_uartlite_init;
hw/char/spapr_vty.c:    set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
hw/char/spapr_vty.c:    dc->props = spapr_vty_properties;
hw/char/spapr_vty.c:    dc->vmsd = &vmstate_spapr_vty;
hw/char/sclpconsole.c:    dc->props = console_properties;
hw/char/sclpconsole.c:    dc->reset = console_reset;
hw/char/sclpconsole.c:    dc->vmsd = &vmstate_sclpconsole;
hw/char/virtio-serial-bus.c:    dc->props = virtio_serial_properties;
hw/char/virtio-serial-bus.c:    set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
hw/char/virtio-serial-bus.c:    vdc->realize = virtio_serial_device_realize;
hw/char/virtio-serial-bus.c:    vdc->unrealize = virtio_serial_device_unrealize;
hw/char/virtio-serial-bus.c:    vdc->get_features = get_features;
hw/char/virtio-serial-bus.c:    vdc->get_config = get_config;
hw/char/virtio-serial-bus.c:    vdc->set_config = set_config;
hw/char/virtio-serial-bus.c:    vdc->set_status = set_status;
hw/char/virtio-serial-bus.c:    vdc->reset = vser_reset;
hw/char/grlib_apbuart.c:    dc->reset = grlib_apbuart_reset;
hw/char/grlib_apbuart.c:    dc->props = grlib_apbuart_properties;
hw/char/digic-uart.c:    dc->realize = digic_uart_realize;
hw/char/digic-uart.c:    dc->reset = digic_uart_reset;
hw/char/digic-uart.c:    dc->vmsd = &vmstate_digic_uart;
hw/char/virtio-console.c:    dc->props = virtserialport_properties;
hw/char/escc.c:    dc->reset = escc_reset;
hw/char/escc.c:    dc->vmsd = &vmstate_escc;
hw/char/escc.c:    dc->props = escc_properties;
hw/char/lm32_uart.c:    dc->reset = uart_reset;
hw/char/lm32_uart.c:    dc->vmsd = &vmstate_lm32_uart;
hw/char/milkymist-uart.c:    dc->realize = milkymist_uart_realize;
hw/char/milkymist-uart.c:    dc->reset = milkymist_uart_reset;
hw/char/milkymist-uart.c:    dc->vmsd = &vmstate_milkymist_uart;
hw/char/serial-pci.c:    dc->vmsd = &vmstate_pci_serial;
hw/char/serial-pci.c:    dc->props = serial_pci_properties;
hw/char/serial-pci.c:    set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
hw/char/serial-pci.c:    dc->vmsd = &vmstate_pci_multi_serial;
hw/char/serial-pci.c:    dc->props = multi_2x_serial_pci_properties;
hw/char/serial-pci.c:    set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
hw/char/serial-pci.c:    dc->vmsd = &vmstate_pci_multi_serial;
hw/char/serial-pci.c:    dc->props = multi_4x_serial_pci_properties;
hw/char/serial-pci.c:    set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
hw/char/etraxfs_ser.c:    dc->reset = etraxfs_ser_reset;
hw/char/ipoctal232.c:    set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
hw/char/ipoctal232.c:    dc->desc    = "GE IP-Octal 232 8-channel RS-232 IndustryPack";
hw/char/ipoctal232.c:    dc->props   = ipoctal_properties;
hw/char/ipoctal232.c:    dc->vmsd    = &vmstate_ipoctal;
hw/char/exynos4210_uart.c:    dc->reset = exynos4210_uart_reset;
hw/char/exynos4210_uart.c:    dc->props = exynos4210_uart_properties;
hw/char/exynos4210_uart.c:    dc->vmsd = &vmstate_exynos4210_uart;
hw/char/parallel.c:    dc->realize = parallel_isa_realizefn;
hw/char/parallel.c:    dc->props = parallel_isa_properties;
hw/char/parallel.c:    set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
hw/char/omap_uart.c:    dc->props = omap_uart_properties;
hw/char/omap_uart.c:    dc->reset = omap_uart_reset;
hw/ftpwmtmr010.c:    dc->vmsd    = &vmstate_ftpwmtmr010;
hw/ftpwmtmr010.c:    dc->props   = ftpwmtmr010_properties;
hw/ftpwmtmr010.c:    dc->reset   = ftpwmtmr010_reset;
hw/ftpwmtmr010.c:    dc->realize = ftpwmtmr010_realize;
hw/ftpwmtmr010.c:    dc->no_user = 1;
hw/cpu/a9mpcore.c~:    dc->realize = a9mp_priv_realize;
hw/cpu/a9mpcore.c~:    dc->props = a9mp_priv_properties;
hw/cpu/icc_bus.c:    if (idc->realize) {
hw/cpu/icc_bus.c:        idc->realize(dev, errp);
hw/cpu/icc_bus.c:    dc->realize = icc_device_realize;
hw/cpu/icc_bus.c:    dc->bus_type = TYPE_ICC_BUS;
hw/cpu/icc_bus.c:    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);
hw/cpu/realview_mpcore.c:    dc->realize = realview_mpcore_realize;
hw/cpu/realview_mpcore.c:    dc->props = mpcore_rirq_properties;
hw/cpu/a15mpcore.c:    dc->realize = a15mp_priv_realize;
hw/cpu/a15mpcore.c:    dc->props = a15mp_priv_properties;
hw/cpu/arm11mpcore.c:    dc->realize = mpcore_priv_realize;
hw/cpu/arm11mpcore.c:    dc->props = mpcore_priv_properties;
hw/cpu/a9mpcore.c:    dc->realize = a9mp_priv_realize;
hw/cpu/a9mpcore.c:    dc->props = a9mp_priv_properties;
hw/cpu/broadcom_mpcore.c:    dc->realize = realview_mpcore_realize;
hw/cpu/broadcom_mpcore.c:    dc->props = mpcore_rirq_properties;
hw/ftspi020.c:    dc->vmsd    = &vmstate_ftspi020;
hw/ftspi020.c:    dc->reset   = ftspi020_reset;
hw/ftspi020.c:    dc->realize = ftspi020_realize;
hw/ftspi020.c:    dc->no_user = 1;
hw/ssi/xilinx_spi.c:    dc->reset = xlx_spi_reset;
hw/ssi/xilinx_spi.c:    dc->props = xilinx_spi_properties;
hw/ssi/xilinx_spi.c:    dc->vmsd = &vmstate_xilinx_spi;
hw/ssi/ssi.c:    dc->init = ssi_slave_init;
hw/ssi/ssi.c:    dc->bus_type = TYPE_SSI_BUS;
hw/ssi/omap_spi.c:    dc->props = omap_mcspi_properties;
hw/ssi/omap_spi.c:    dc->reset = omap_mcspi_reset;
hw/ssi/xilinx_spips.c:    dc->realize = xilinx_qspips_realize;
hw/ssi/xilinx_spips.c:    dc->realize = xilinx_spips_realize;
hw/ssi/xilinx_spips.c:    dc->reset = xilinx_spips_reset;
hw/ssi/xilinx_spips.c:    dc->props = xilinx_spips_properties;
hw/ssi/xilinx_spips.c:    dc->vmsd = &vmstate_xilinx_spips;
hw/ssi/pl022.c:    sdc->init = pl022_init;
hw/fti2c010.c:    dc->vmsd    = &vmstate_fti2c010;
hw/fti2c010.c:    dc->reset   = fti2c010_reset;
hw/fti2c010.c:    dc->realize = fti2c010_realize;
hw/fti2c010.c:    dc->no_user = 1;
hw/s390x/event-facility.c:    dc->reset = reset_event_facility;
hw/s390x/event-facility.c:    dc->vmsd = &vmstate_event_facility;
hw/s390x/event-facility.c:    dc->bus_type = TYPE_SCLP_EVENTS_BUS;
hw/s390x/event-facility.c:    dc->unplug = qdev_simple_unplug_cb;
hw/s390x/event-facility.c:    dc->realize = event_realize;
hw/s390x/event-facility.c:    dc->unrealize = event_unrealize;
hw/s390x/virtio-ccw.c:    dc->reset = virtio_ccw_reset;
hw/s390x/virtio-ccw.c:    dc->props = virtio_ccw_net_properties;
hw/s390x/virtio-ccw.c:    dc->reset = virtio_ccw_reset;
hw/s390x/virtio-ccw.c:    dc->props = virtio_ccw_blk_properties;
hw/s390x/virtio-ccw.c:    dc->reset = virtio_ccw_reset;
hw/s390x/virtio-ccw.c:    dc->props = virtio_ccw_serial_properties;
hw/s390x/virtio-ccw.c:    dc->reset = virtio_ccw_reset;
hw/s390x/virtio-ccw.c:    dc->props = virtio_ccw_balloon_properties;
hw/s390x/virtio-ccw.c:    dc->reset = virtio_ccw_reset;
hw/s390x/virtio-ccw.c:    dc->props = virtio_ccw_scsi_properties;
hw/s390x/virtio-ccw.c:    dc->reset = virtio_ccw_reset;
hw/s390x/virtio-ccw.c:    dc->props = vhost_ccw_scsi_properties;
hw/s390x/virtio-ccw.c:    dc->reset = virtio_ccw_reset;
hw/s390x/virtio-ccw.c:    dc->props = virtio_ccw_rng_properties;
hw/s390x/virtio-ccw.c:    dc->init = virtio_ccw_busdev_init;
hw/s390x/virtio-ccw.c:    dc->exit = virtio_ccw_busdev_exit;
hw/s390x/virtio-ccw.c:    dc->unplug = virtio_ccw_busdev_unplug;
hw/s390x/virtio-ccw.c:    dc->bus_type = TYPE_VIRTUAL_CSS_BUS;
hw/s390x/s390-virtio-bus.c:    dc->props = s390_virtio_net_properties;
hw/s390x/s390-virtio-bus.c:    dc->props = s390_virtio_blk_properties;
hw/s390x/s390-virtio-bus.c:    dc->props = s390_virtio_serial_properties;
hw/s390x/s390-virtio-bus.c:    dc->props = s390_virtio_rng_properties;
hw/s390x/s390-virtio-bus.c:    dc->init = s390_virtio_busdev_init;
hw/s390x/s390-virtio-bus.c:    dc->bus_type = TYPE_S390_VIRTIO_BUS;
hw/s390x/s390-virtio-bus.c:    dc->unplug = qdev_simple_unplug_cb;
hw/s390x/s390-virtio-bus.c:    dc->reset = s390_virtio_busdev_reset;
hw/s390x/s390-virtio-bus.c:    dc->props = s390_virtio_scsi_properties;
hw/s390x/s390-virtio-bus.c:    dc->props = s390_vhost_scsi_properties;
hw/s390x/sclpquiesce.c:    dc->reset = quiesce_reset;
hw/s390x/sclpquiesce.c:    dc->vmsd = &vmstate_sclpquiesce;
hw/s390x/ipl.c:    dc->props = s390_ipl_properties;
hw/s390x/ipl.c:    dc->reset = s390_ipl_reset;
hw/display/vga-isa.c:    dc->realize = vga_isa_realizefn;
hw/display/vga-isa.c:    dc->reset = vga_isa_reset;
hw/display/vga-isa.c:    dc->vmsd = &vmstate_vga_common;
hw/display/vga-isa.c:    dc->props = vga_isa_properties;
hw/display/vga-isa.c:    set_bit(DEVICE_CATEGORY_DISPLAY, dc->categories);
hw/display/cg3.c:    dc->realize = cg3_realizefn;
hw/display/cg3.c:    dc->reset = cg3_reset;
hw/display/cg3.c:    dc->vmsd = &vmstate_cg3;
hw/display/cg3.c:    dc->props = cg3_properties;
hw/display/ssd0303.c:    dc->vmsd = &vmstate_ssd0303;
hw/display/milkymist-vgafb.c:    dc->reset = milkymist_vgafb_reset;
hw/display/milkymist-vgafb.c:    dc->vmsd = &vmstate_milkymist_vgafb;
hw/display/milkymist-vgafb.c:    dc->props = milkymist_vgafb_properties;
hw/display/g364fb.c:    set_bit(DEVICE_CATEGORY_DISPLAY, dc->categories);
hw/display/g364fb.c:    dc->desc = "G364 framebuffer";
hw/display/g364fb.c:    dc->reset = g364fb_sysbus_reset;
hw/display/g364fb.c:    dc->vmsd = &vmstate_g364fb;
hw/display/g364fb.c:    dc->props = g364fb_sysbus_properties;
hw/display/pl110.c:    set_bit(DEVICE_CATEGORY_DISPLAY, dc->categories);
hw/display/pl110.c:    dc->vmsd = &vmstate_pl110;
hw/display/vga-pci.c:    dc->vmsd = &vmstate_vga_pci;
hw/display/vga-pci.c:    dc->props = vga_pci_properties;
hw/display/vga-pci.c:    dc->hotpluggable = false;
hw/display/vga-pci.c:    set_bit(DEVICE_CATEGORY_DISPLAY, dc->categories);
hw/display/dsi.c:            dc->write(dev, payload & 0xff, 1);
hw/display/dsi.c:            return dc->read(dev, payload & 0xff, 1);
hw/display/dsi.c:            dc->write(dev, payload, 2);
hw/display/dsi.c:            dc->write(dev, payload, counter > 4 ? 4 : counter);
hw/display/dsi.c:            return dc->blt(dev, data, width, height,
hw/display/dsi.c:            dc->bltdone(dev);
hw/display/dsi.c:    return dc->init(dsi_dev);
hw/display/dsi.c:    dc->write = dsi_common_write;
hw/display/dsi.c:    dc->read = dsi_common_read;
hw/display/exynos4210_fimd.c:    dc->vmsd = &exynos4210_fimd_vmstate;
hw/display/exynos4210_fimd.c:    dc->reset = exynos4210_fimd_reset;
hw/display/milkymist-tmu2.c:    dc->reset = milkymist_tmu2_reset;
hw/display/milkymist-tmu2.c:    dc->vmsd = &vmstate_milkymist_tmu2;
hw/display/qxl.c:    set_bit(DEVICE_CATEGORY_DISPLAY, dc->categories);
hw/display/qxl.c:    dc->desc = "Spice QXL GPU (primary, vga compatible)";
hw/display/qxl.c:    dc->reset = qxl_reset_handler;
hw/display/qxl.c:    dc->vmsd = &qxl_vmstate;
hw/display/qxl.c:    dc->props = qxl_properties;
hw/display/qxl.c:    dc->hotpluggable = false;
hw/display/qxl.c:    set_bit(DEVICE_CATEGORY_DISPLAY, dc->categories);
hw/display/qxl.c:    dc->desc = "Spice QXL GPU (secondary)";
hw/display/qxl.c:    dc->reset = qxl_reset_handler;
hw/display/qxl.c:    dc->vmsd = &qxl_vmstate;
hw/display/qxl.c:    dc->props = qxl_properties;
hw/display/jazz_led.c:    dc->desc = "Jazz LED display",
hw/display/jazz_led.c:    dc->vmsd = &vmstate_jazz_led;
hw/display/jazz_led.c:    dc->reset = jazz_led_reset;
hw/display/cirrus_vga.c:    dc->vmsd  = &vmstate_cirrus_vga;
hw/display/cirrus_vga.c:    dc->realize = isa_cirrus_vga_realizefn;
hw/display/cirrus_vga.c:    dc->props = isa_cirrus_vga_properties;
hw/display/cirrus_vga.c:    set_bit(DEVICE_CATEGORY_DISPLAY, dc->categories);
hw/display/cirrus_vga.c:    set_bit(DEVICE_CATEGORY_DISPLAY, dc->categories);
hw/display/cirrus_vga.c:    dc->desc = "Cirrus CLGD 54xx VGA";
hw/display/cirrus_vga.c:    dc->vmsd = &vmstate_pci_cirrus_vga;
hw/display/cirrus_vga.c:    dc->props = pci_vga_cirrus_properties;
hw/display/cirrus_vga.c:    dc->hotpluggable = false;
hw/display/omap_dss.c:    dc->reset = omap_dss_reset;
hw/display/omap_dss.c:    dc->props = omap_dss_properties;
hw/display/tcx.c:    dc->reset = tcx_reset;
hw/display/tcx.c:    dc->vmsd = &vmstate_tcx;
hw/display/tcx.c:    dc->props = tcx_properties;
hw/display/vmware_vga.c:    dc->reset = vmsvga_reset;
hw/display/vmware_vga.c:    dc->vmsd = &vmstate_vmware_vga;
hw/display/vmware_vga.c:    dc->props = vga_vmware_properties;
hw/display/vmware_vga.c:    dc->hotpluggable = false;
hw/display/vmware_vga.c:    set_bit(DEVICE_CATEGORY_DISPLAY, dc->categories);
hw/core/qdev.c:    return dc->vmsd;
hw/core/qdev.c:    if (dc->fw_name) {
hw/core/qdev.c:        return dc->fw_name;
hw/core/qdev.c:    if (dc->init) {
hw/core/qdev.c:        int rc = dc->init(dev);
hw/core/qdev.c:    if (dc->exit) {
hw/core/qdev.c:        int rc = dc->exit(dev);
hw/core/qdev.c:    if (!dc->hotpluggable) {
hw/core/qdev.c:        assert(dc->unplug != NULL);
hw/core/qdev.c:        if (dc->unplug(dev) < 0) { /* legacy handler */
hw/core/qdev.c:    if (dev->hotplugged && !dc->hotpluggable) {
hw/core/qdev.c:        if (dc->realize) {
hw/core/qdev.c:            dc->realize(dev, &local_err);
hw/core/qdev.c:        if (dc->unrealize && local_err == NULL) {
hw/core/qdev.c:            dc->unrealize(dev, &local_err);
hw/core/qdev.c:    return dc->hotpluggable && (dev->parent_bus == NULL ||
hw/core/qdev.c:    dc->realize = device_realize;
hw/core/qdev.c:    dc->unrealize = device_unrealize;
hw/core/qdev.c:    dc->hotpluggable = true;
hw/core/hotplug.c:    if (hdc->plug) {
hw/core/hotplug.c:        hdc->plug(plug_handler, plugged_dev, errp);
hw/core/hotplug.c:    if (hdc->unplug) {
hw/core/hotplug.c:        hdc->unplug(plug_handler, plugged_dev, errp);
Binary file hw/core/qdev.o matches
hw/xen/xen_pvdevice.c:    dc->desc = "Xen PV Device";
hw/xen/xen_pvdevice.c:    dc->props = xen_pv_props;
hw/xen/xen_platform.c:    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
hw/xen/xen_platform.c:    dc->desc = "XEN platform pci device";
hw/xen/xen_platform.c:    dc->reset = platform_reset;
hw/xen/xen_platform.c:    dc->vmsd = &vmstate_xen_platform;
hw/xen/xen_pt.c:    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
hw/xen/xen_pt.c:    dc->desc = "Assign an host PCI device with Xen";
hw/xen/xen_pt.c:    dc->props = xen_pci_passthrough_properties;
hw/usb/dev-smartcard-reader.c:    dc->desc = "CCID Rev 1.1 smartcard reader";
hw/usb/dev-smartcard-reader.c:    dc->vmsd = &ccid_vmstate;
hw/usb/dev-smartcard-reader.c:    dc->props = ccid_properties;
hw/usb/dev-smartcard-reader.c:    set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
hw/usb/dev-wacom.c:    set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
hw/usb/dev-wacom.c:    dc->desc = "QEMU PenPartner Tablet";
hw/usb/dev-wacom.c:    dc->vmsd = &vmstate_usb_wacom;
hw/usb/hcd-uhci.c:    dc->hotpluggable = false;
hw/usb/hcd-uhci.c:    dc->vmsd = &vmstate_uhci;
hw/usb/hcd-uhci.c:    dc->props = uhci_properties;
hw/usb/hcd-uhci.c:    set_bit(DEVICE_CATEGORY_USB, dc->categories);
hw/usb/dev-bluetooth.c:    dc->vmsd = &vmstate_usb_bt;
hw/usb/dev-bluetooth.c:    set_bit(DEVICE_CATEGORY_NETWORK, dc->categories);
hw/usb/dev-uas.c:    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
hw/usb/dev-uas.c:    dc->fw_name = "storage";
hw/usb/dev-uas.c:    dc->vmsd = &vmstate_usb_uas;
hw/usb/dev-uas.c:    dc->props = uas_properties;
hw/usb/ccid-card-emulated.c:    set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
hw/usb/ccid-card-emulated.c:    dc->desc = "emulated smartcard";
hw/usb/ccid-card-emulated.c:    dc->props = emulated_card_properties;
hw/usb/dev-serial.c:    dc->vmsd = &vmstate_usb_serial;
hw/usb/dev-serial.c:    dc->props = serial_properties;
hw/usb/dev-serial.c:    set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
hw/usb/dev-serial.c:    dc->vmsd = &vmstate_usb_serial;
hw/usb/dev-serial.c:    dc->props = braille_properties;
hw/usb/dev-serial.c:    set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
hw/usb/host-libusb.c:    dc->vmsd = &vmstate_usb_host;
hw/usb/host-libusb.c:    dc->props = usb_host_dev_properties;
hw/usb/host-libusb.c:    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);
hw/usb/redirect.c:    dc->vmsd           = &usbredir_vmstate;
hw/usb/redirect.c:    dc->props          = usbredir_properties;
hw/usb/redirect.c:    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
hw/usb/hcd-ohci.c:    set_bit(DEVICE_CATEGORY_USB, dc->categories);
hw/usb/hcd-ohci.c:    dc->desc = "Apple USB Controller";
hw/usb/hcd-ohci.c:    dc->props = ohci_pci_properties;
hw/usb/hcd-ohci.c:    dc->hotpluggable = false;
hw/usb/hcd-ohci.c:    dc->realize = ohci_realize_pxa;
hw/usb/hcd-ohci.c:    set_bit(DEVICE_CATEGORY_USB, dc->categories);
hw/usb/hcd-ohci.c:    dc->desc = "OHCI USB Controller";
hw/usb/hcd-ohci.c:    dc->props = ohci_sysbus_properties;
hw/usb/dev-audio.c:    dc->vmsd          = &vmstate_usb_audio;
hw/usb/dev-audio.c:    dc->props         = usb_audio_properties;
hw/usb/dev-audio.c:    set_bit(DEVICE_CATEGORY_SOUND, dc->categories);
hw/usb/dev-storage.c:    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
hw/usb/dev-storage.c:    dc->fw_name = "storage";
hw/usb/dev-storage.c:    dc->vmsd = &vmstate_usb_msd;
hw/usb/dev-storage.c:    dc->props = msd_properties;
hw/usb/hcd-uhci.c~:    dc->hotpluggable = false;
hw/usb/hcd-uhci.c~:    dc->vmsd = &vmstate_uhci;
hw/usb/hcd-uhci.c~:    dc->props = uhci_properties;
hw/usb/hcd-uhci.c~:    set_bit(DEVICE_CATEGORY_USB, dc->categories);
hw/usb/dev-hid.c:    dc->vmsd = &vmstate_usb_ptr;
hw/usb/dev-hid.c:    dc->props = usb_tablet_properties;
hw/usb/dev-hid.c:    set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
hw/usb/dev-hid.c:    dc->vmsd = &vmstate_usb_ptr;
hw/usb/dev-hid.c:    set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
hw/usb/dev-hid.c:    dc->vmsd = &vmstate_usb_kbd;
hw/usb/dev-hid.c:    set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
hw/usb/ccid-card-passthru.c:    set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
hw/usb/ccid-card-passthru.c:    dc->desc = "passthrough smartcard";
hw/usb/ccid-card-passthru.c:    dc->vmsd = &passthru_vmstate;
hw/usb/ccid-card-passthru.c:    dc->props = passthru_card_properties;
hw/usb/dev-network.c:    set_bit(DEVICE_CATEGORY_NETWORK, dc->categories);
hw/usb/dev-network.c:    dc->fw_name = "network";
hw/usb/dev-network.c:    dc->vmsd = &vmstate_usb_net;
hw/usb/dev-network.c:    dc->props = net_properties;
hw/usb/hcd-xhci.c:    dc->hotpluggable   = false;
hw/usb/hcd-xhci.c:    dc->vmsd           = &vmstate_xhci;
hw/usb/hcd-xhci.c:    dc->props  	       = xhci_properties;
hw/usb/hcd-xhci.c://    dc->reset          = xhci_reset;
hw/usb/hcd-xhci.c:    set_bit(DEVICE_CATEGORY_USB, dc->categories);
hw/usb/dev-hub.c:    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);
hw/usb/dev-hub.c:    dc->fw_name = "hub";
hw/usb/dev-hub.c:    dc->vmsd = &vmstate_usb_hub;
hw/usb/hcd-ehci-pci.c:    dc->hotpluggable = false;
hw/usb/hcd-ehci-pci.c:    dc->vmsd = &vmstate_ehci_pci;
hw/usb/hcd-ehci-pci.c:    dc->props = ehci_pci_properties;
hw/usb/hcd-ehci-pci.c:    set_bit(DEVICE_CATEGORY_USB, dc->categories);
hw/usb/hcd-omap.c:    dc->reset = omap3_hsusb_otg_reset;
hw/usb/hcd-omap.c:    dc->reset = omap3_hsusb_host_reset;
hw/usb/hcd-xhci.c~:    dc->hotpluggable   = false;
hw/usb/hcd-xhci.c~:    dc->vmsd           = &vmstate_xhci;
hw/usb/hcd-xhci.c~:    dc->props  	       = xhci_properties;
hw/usb/hcd-xhci.c~://    dc->reset          = xhci_reset;
hw/usb/hcd-xhci.c~:    set_bit(DEVICE_CATEGORY_USB, dc->categories);
hw/usb/hcd-ehci-sysbus.c:    dc->realize = usb_ehci_sysbus_realize;
hw/usb/hcd-ehci-sysbus.c:    dc->vmsd = &vmstate_ehci_sysbus;
hw/usb/hcd-ehci-sysbus.c:    dc->props = ehci_sysbus_properties;
hw/usb/hcd-ehci-sysbus.c:    set_bit(DEVICE_CATEGORY_USB, dc->categories);
hw/usb/hcd-ehci-sysbus.c:    set_bit(DEVICE_CATEGORY_USB, dc->categories);
hw/usb/hcd-ehci-sysbus.c:    set_bit(DEVICE_CATEGORY_USB, dc->categories);
hw/usb/hcd-ehci-sysbus.c:    set_bit(DEVICE_CATEGORY_USB, dc->categories);
hw/usb/hcd-ehci-sysbus.c:    set_bit(DEVICE_CATEGORY_USB, dc->categories);
hw/sparc/sun4m.c:    dc->props = prom_properties;
hw/sparc/sun4m.c:    dc->props = ram_properties;
hw/misc/sb_hwregs.c: //   dc->realize = sbhwregs_realize;
hw/misc/sb_hwregs.c:    dc->reset = sbhwregs_reset;
hw/misc/sb_hwregs.c:    dc->vmsd = &vmstate_sbhwregs;
hw/misc/sb_hwregs.c:    dc->props = sbhwregs_properties;
hw/misc/zynq_slcr.c~:    sdc->init = zynq_slcr_init;
hw/misc/zynq_slcr.c~:    dc->vmsd = &vmstate_zynq_slcr;
hw/misc/zynq_slcr.c~:    dc->reset = zynq_slcr_reset;
hw/misc/lm32_sys.c:    dc->reset = sys_reset;
hw/misc/lm32_sys.c:    dc->vmsd = &vmstate_lm32_sys;
hw/misc/lm32_sys.c:    dc->props = lm32_sys_properties;
hw/misc/eccmemctl.c:    dc->reset = ecc_reset;
hw/misc/eccmemctl.c:    dc->vmsd = &vmstate_ecc;
hw/misc/eccmemctl.c:    dc->props = ecc_properties;
hw/misc/sb_chipc.c~: //   dc->realize = chipcregs_realize;
hw/misc/sb_chipc.c~:    dc->reset = chipcregs_reset;
hw/misc/sb_chipc.c~:    dc->vmsd = &vmstate_chipcregs;
hw/misc/sb_chipc.c~:    dc->props = chipcregs_properties;
hw/misc/aidmp.c~: //   dc->realize = chipcregs_realize;
hw/misc/aidmp.c~:    dc->reset = aidmpregs_reset;
hw/misc/aidmp.c~:    dc->vmsd = &vmstate_aidmpregs;
hw/misc/aidmp.c~:    dc->props = aidmpregs_properties;
hw/misc/slavio_misc.c:    dc->reset = slavio_misc_reset;
hw/misc/slavio_misc.c:    dc->vmsd = &vmstate_misc;
hw/misc/sbchipc.c: //   dc->realize = chipcregs_realize;
hw/misc/sbchipc.c:    dc->reset = chipcregs_reset;
hw/misc/sbchipc.c:    dc->vmsd = &vmstate_chipcregs;
hw/misc/sbchipc.c:    dc->props = chipcregs_properties;
hw/misc/nand_core.c: //   dc->realize = chipcregs_realize;
hw/misc/nand_core.c:    dc->reset = ncregs_reset;
hw/misc/nand_core.c:    dc->vmsd = &vmstate_ncregs;
hw/misc/nand_core.c:    dc->props = ncregs_properties;
hw/misc/nand_core.c~: //   dc->realize = chipcregs_realize;
hw/misc/nand_core.c~:    dc->reset = ncregs_reset;
hw/misc/nand_core.c~:    dc->vmsd = &vmstate_ncregs;
hw/misc/nand_core.c~:    dc->props = ncregs_properties;
hw/misc/arm_l2x0.c:    dc->vmsd = &vmstate_l2x0;
hw/misc/arm_l2x0.c:    dc->props = l2x0_properties;
hw/misc/arm_l2x0.c:    dc->reset = l2x0_priv_reset;
hw/misc/broadcom_sysctl.c~: //   dc->realize = chipcregs_realize;
hw/misc/broadcom_sysctl.c~:    dc->reset = chipcregs_reset;
hw/misc/broadcom_sysctl.c~:    dc->vmsd = &vmstate_chipcregs;
hw/misc/broadcom_sysctl.c~:    dc->props = chipcregs_properties;
hw/misc/pci-testdev.c:    dc->desc = "PCI Test Device";
hw/misc/pci-testdev.c:    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
hw/misc/pci-testdev.c:    dc->reset = qdev_pci_testdev_reset;
hw/misc/pvpanic.c:    dc->realize = pvpanic_isa_realizefn;
hw/misc/pvpanic.c:    dc->props = pvpanic_isa_properties;
hw/misc/pvpanic.c:    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
hw/misc/debugexit.c:    dc->realize = debug_exit_realizefn;
hw/misc/debugexit.c:    dc->props = debug_exit_properties;
hw/misc/debugexit.c:    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
hw/misc/pc-testdev.c:    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
hw/misc/pc-testdev.c:    dc->realize = testdev_realizefn;
hw/misc/arm11scu.c:    dc->realize = arm11_scu_realize;
hw/misc/arm11scu.c:    dc->props = arm11_scu_properties;
hw/misc/sga.c:    set_bit(DEVICE_CATEGORY_DISPLAY, dc->categories);
hw/misc/sga.c:    dc->realize = sga_realizefn;
hw/misc/sga.c:    dc->desc = "Serial Graphics Adapter";
hw/misc/imx_ccm.c:    dc->reset = imx_ccm_reset;
hw/misc/imx_ccm.c:    dc->vmsd = &vmstate_imx_ccm;
hw/misc/imx_ccm.c:    dc->desc = "i.MX Clock Control Module";
hw/misc/a9scu.c:    dc->props = a9_scu_properties;
hw/misc/a9scu.c:    dc->vmsd = &vmstate_a9_scu;
hw/misc/a9scu.c:    dc->reset = a9_scu_reset;
hw/misc/broadcom_sysctl.c: //   dc->realize = chipcregs_realize;
hw/misc/broadcom_sysctl.c:    dc->reset = chipcregs_reset;
hw/misc/broadcom_sysctl.c:    dc->vmsd = &vmstate_chipcregs;
hw/misc/broadcom_sysctl.c:    dc->props = chipcregs_properties;
hw/misc/vfio.c:    dc->reset = vfio_pci_reset;
hw/misc/vfio.c:    dc->props = vfio_pci_dev_properties;
hw/misc/vfio.c:    dc->vmsd = &vfio_pci_vmstate;
hw/misc/vfio.c:    dc->desc = "VFIO-based PCI device assignment";
hw/misc/vfio.c:    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
hw/misc/vfio.c:    pdc->init = vfio_initfn;
hw/misc/vfio.c:    pdc->exit = vfio_exitfn;
hw/misc/vfio.c:    pdc->config_read = vfio_pci_read_config;
hw/misc/vfio.c:    pdc->config_write = vfio_pci_write_config;
hw/misc/vfio.c:    pdc->is_express = 1; /* We might be */
hw/misc/sbchipc.c~: //   dc->realize = chipcregs_realize;
hw/misc/sbchipc.c~:    dc->reset = chipcregs_reset;
hw/misc/sbchipc.c~:    dc->vmsd = &vmstate_chipcregs;
hw/misc/sbchipc.c~:    dc->props = chipcregs_properties;
hw/misc/mst_fpga.c:    dc->desc = "Mainstone II FPGA";
hw/misc/mst_fpga.c:    dc->vmsd = &vmstate_mst_fpga_regs;
hw/misc/broadcom_systl.c~:    dc->realize = arm_sysctl_realize;
hw/misc/broadcom_systl.c~:    dc->reset = arm_sysctl_reset;
hw/misc/broadcom_systl.c~:    dc->vmsd = &vmstate_arm_sysctl;
hw/misc/broadcom_systl.c~:    dc->props = arm_sysctl_properties;
hw/misc/sb_hwregs.c~: //   dc->realize = sbhwregs_realize;
hw/misc/sb_hwregs.c~:    dc->reset = sbhwregs_reset;
hw/misc/sb_hwregs.c~:    dc->vmsd = &vmstate_sbhwregs;
hw/misc/sb_hwregs.c~:    dc->props = sbhwregs_properties;
hw/misc/arm_sysctl.c~:    dc->realize = arm_sysctl_realize;
hw/misc/arm_sysctl.c~:    dc->reset = arm_sysctl_reset;
hw/misc/arm_sysctl.c~:    dc->vmsd = &vmstate_arm_sysctl;
hw/misc/arm_sysctl.c~:    dc->props = arm_sysctl_properties;
hw/misc/ivshmem.c:    dc->reset = ivshmem_reset;
hw/misc/ivshmem.c:    dc->props = ivshmem_properties;
hw/misc/ivshmem.c:    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
hw/misc/sb_chipc.c: //   dc->realize = chipcregs_realize;
hw/misc/sb_chipc.c:    dc->reset = chipcregs_reset;
hw/misc/sb_chipc.c:    dc->vmsd = &vmstate_chipcregs;
hw/misc/sb_chipc.c:    dc->props = chipcregs_properties;
hw/misc/aidmp.c: //   dc->realize = chipcregs_realize;
hw/misc/aidmp.c:    dc->reset = aidmpregs_reset;
hw/misc/aidmp.c:    dc->vmsd = &vmstate_aidmpregs;
hw/misc/aidmp.c:    dc->props = aidmpregs_properties;
hw/misc/broadcom_systl.c:    dc->realize = arm_sysctl_realize;
hw/misc/broadcom_systl.c:    dc->reset = arm_sysctl_reset;
hw/misc/broadcom_systl.c:    dc->vmsd = &vmstate_arm_sysctl;
hw/misc/broadcom_systl.c:    dc->props = arm_sysctl_properties;
hw/misc/applesmc.c:    dc->realize = applesmc_isa_realize;
hw/misc/applesmc.c:    dc->reset = qdev_applesmc_isa_reset;
hw/misc/applesmc.c:    dc->props = applesmc_isa_properties;
hw/misc/applesmc.c:    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
hw/misc/vmport.c:    dc->realize = vmport_realizefn;
hw/misc/vmport.c:    dc->cannot_instantiate_with_device_add_yet = true;
hw/misc/exynos4210_pmu.c:    dc->reset = exynos4210_pmu_reset;
hw/misc/exynos4210_pmu.c:    dc->vmsd = &exynos4210_pmu_vmstate;
hw/misc/macio/macio.c:    pdc->init = macio_oldworld_initfn;
hw/misc/macio/macio.c:    pdc->device_id = PCI_DEVICE_ID_APPLE_343S1201;
hw/misc/macio/macio.c:    pdc->init = macio_newworld_initfn;
hw/misc/macio/macio.c:    pdc->device_id = PCI_DEVICE_ID_APPLE_UNI_N_KEYL;
hw/misc/macio/cuda.c:    dc->realize = cuda_realizefn;
hw/misc/macio/cuda.c:    dc->reset = cuda_reset;
hw/misc/macio/cuda.c:    dc->vmsd = &vmstate_cuda;
hw/misc/milkymist-pfpu.c:    dc->reset = milkymist_pfpu_reset;
hw/misc/milkymist-pfpu.c:    dc->vmsd = &vmstate_milkymist_pfpu;
hw/misc/milkymist-hpdmc.c:    dc->reset = milkymist_hpdmc_reset;
hw/misc/milkymist-hpdmc.c:    dc->vmsd = &vmstate_milkymist_hpdmc;
hw/misc/arm_sysctl.c:    dc->realize = arm_sysctl_realize;
hw/misc/arm_sysctl.c:    dc->reset = arm_sysctl_reset;
hw/misc/arm_sysctl.c:    dc->vmsd = &vmstate_arm_sysctl;
hw/misc/arm_sysctl.c:    dc->props = arm_sysctl_properties;
hw/misc/puv3_pm.c:    sdc->init = puv3_pm_init;
hw/misc/zynq_slcr.c:    sdc->init = zynq_slcr_init;
hw/misc/zynq_slcr.c:    dc->vmsd = &vmstate_zynq_slcr;
hw/misc/zynq_slcr.c:    dc->reset = zynq_slcr_reset;
hw/misc/tmp105.c:    dc->vmsd = &vmstate_tmp105;
hw/ipack/tpci200.c:    set_bit(DEVICE_CATEGORY_INPUT, dc->categories);
hw/ipack/tpci200.c:    dc->desc = "TEWS TPCI200 IndustryPack carrier";
hw/ipack/tpci200.c:    dc->vmsd = &vmstate_tpci200;
hw/pci/pcie_port.c:    dc->props = pcie_port_props;
hw/pci/pcie_port.c:    dc->props = pcie_slot_props;
hw/block/pflash_cfi02.c:    dc->realize = pflash_cfi02_realize;
hw/block/pflash_cfi02.c:    dc->props = pflash_cfi02_properties;
hw/block/pflash_cfi01.c:    dc->realize = pflash_cfi01_realize;
hw/block/pflash_cfi01.c:    dc->props = pflash_cfi01_properties;
hw/block/pflash_cfi01.c:    dc->vmsd = &vmstate_pflash;
hw/block/pflash_cfi01.c:    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
hw/block/onenand.c:    dc->reset = onenand_system_reset;
hw/block/onenand.c:    dc->props = onenand_properties;
hw/block/nand.c:    dc->realize = nand_realize;
hw/block/nand.c:    dc->reset = nand_reset;
hw/block/nand.c:    dc->vmsd = &vmstate_nand;
hw/block/nand.c:    dc->props = nand_properties;
hw/block/virtio-blk.c:    dc->props = virtio_blk_properties;
hw/block/virtio-blk.c:    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
hw/block/virtio-blk.c:    vdc->realize = virtio_blk_device_realize;
hw/block/virtio-blk.c:    vdc->unrealize = virtio_blk_device_unrealize;
hw/block/virtio-blk.c:    vdc->get_config = virtio_blk_update_config;
hw/block/virtio-blk.c:    vdc->set_config = virtio_blk_set_config;
hw/block/virtio-blk.c:    vdc->get_features = virtio_blk_get_features;
hw/block/virtio-blk.c:    vdc->set_status = virtio_blk_set_status;
hw/block/virtio-blk.c:    vdc->reset = virtio_blk_reset;
hw/block/nvme.c:    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
hw/block/nvme.c:    dc->desc = "Non-Volatile Memory Express";
hw/block/nvme.c:    dc->props = nvme_props;
hw/block/nvme.c:    dc->vmsd = &nvme_vmstate;
hw/block/m25p80.c:    dc->vmsd = &vmstate_m25p80;
hw/block/fdc.c:    dc->realize = isabus_fdc_realize;
hw/block/fdc.c:    dc->fw_name = "fdc";
hw/block/fdc.c:    dc->reset = fdctrl_external_reset_isa;
hw/block/fdc.c:    dc->vmsd = &vmstate_isa_fdc;
hw/block/fdc.c:    dc->props = isa_fdc_properties;
hw/block/fdc.c:    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
hw/block/fdc.c:    dc->props = sysbus_fdc_properties;
hw/block/fdc.c:    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
hw/block/fdc.c:    dc->props = sun4m_fdc_properties;
hw/block/fdc.c:    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
hw/block/fdc.c:    dc->realize = sysbus_fdc_common_realize;
hw/block/fdc.c:    dc->reset = fdctrl_external_reset_sysbus;
hw/block/fdc.c:    dc->vmsd = &vmstate_sysbus_fdc;
hw/block/pflash_cfi02.c~:    dc->realize = pflash_cfi02_realize;
hw/block/pflash_cfi02.c~:    dc->props = pflash_cfi02_properties;
hw/9pfs/virtio-9p-device.c:    dc->props = virtio_9p_properties;
hw/9pfs/virtio-9p-device.c:    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
hw/9pfs/virtio-9p-device.c:    vdc->realize = virtio_9p_device_realize;
hw/9pfs/virtio-9p-device.c:    vdc->get_features = virtio_9p_get_features;
hw/9pfs/virtio-9p-device.c:    vdc->get_config = virtio_9p_get_config;
hw/audio/milkymist-ac97.c:    dc->reset = milkymist_ac97_reset;
hw/audio/milkymist-ac97.c:    dc->vmsd = &vmstate_milkymist_ac97;
hw/audio/ac97.c:    set_bit(DEVICE_CATEGORY_SOUND, dc->categories);
hw/audio/ac97.c:    dc->desc = "Intel 82801AA AC97 Audio";
hw/audio/ac97.c:    dc->vmsd = &vmstate_ac97;
hw/audio/ac97.c:    dc->props = ac97_properties;
hw/audio/marvell_88w8618.c~:    dc->reset = mv88w8618_audio_reset;
hw/audio/marvell_88w8618.c~:    dc->vmsd = &mv88w8618_audio_vmsd;
hw/audio/marvell_88w8618.c~:    dc->props = mv88w8618_audio_properties;
hw/audio/marvell_88w8618.c~:    dc->cannot_instantiate_with_device_add_yet = true;
hw/audio/pl041.c:    set_bit(DEVICE_CATEGORY_SOUND, dc->categories);
hw/audio/pl041.c:    dc->reset = pl041_device_reset;
hw/audio/pl041.c:    dc->vmsd = &vmstate_pl041;
hw/audio/pl041.c:    dc->props = pl041_device_properties;
hw/audio/gus.c:    dc->realize = gus_realizefn;
hw/audio/gus.c:    set_bit(DEVICE_CATEGORY_SOUND, dc->categories);
hw/audio/gus.c:    dc->desc = "Gravis Ultrasound GF1";
hw/audio/gus.c:    dc->vmsd = &vmstate_gus;
hw/audio/gus.c:    dc->props = gus_properties;
hw/audio/cs4231.c:    dc->reset = cs_reset;
hw/audio/cs4231.c:    dc->vmsd = &vmstate_cs4231;
hw/audio/cs4231.c:    dc->props = cs4231_properties;
hw/audio/adlib.c:    dc->realize = adlib_realizefn;
hw/audio/adlib.c:    set_bit(DEVICE_CATEGORY_SOUND, dc->categories);
hw/audio/adlib.c:    dc->desc = ADLIB_DESC;
hw/audio/adlib.c:    dc->props = adlib_properties;
hw/audio/es1370.c:    set_bit(DEVICE_CATEGORY_SOUND, dc->categories);
hw/audio/es1370.c:    dc->desc = "ENSONIQ AudioPCI ES1370";
hw/audio/es1370.c:    dc->vmsd = &vmstate_es1370;
hw/audio/hda-codec.c:    set_bit(DEVICE_CATEGORY_SOUND, dc->categories);
hw/audio/hda-codec.c:    dc->reset = hda_audio_reset;
hw/audio/hda-codec.c:    dc->vmsd = &vmstate_hda_audio;
hw/audio/hda-codec.c:    dc->props = hda_audio_properties;
hw/audio/hda-codec.c:    dc->desc = "HDA Audio Codec, output-only (line-out)";
hw/audio/hda-codec.c:    dc->desc = "HDA Audio Codec, duplex (line-out, line-in)";
hw/audio/hda-codec.c:    dc->desc = "HDA Audio Codec, duplex (speaker, microphone)";
hw/audio/wm8731.c:    dc->vmsd  = &vmstate_wm8731;
hw/audio/cs4231a.c:    dc->realize = cs4231a_realizefn;
hw/audio/cs4231a.c:    dc->reset = cs4231a_reset;
hw/audio/cs4231a.c:    set_bit(DEVICE_CATEGORY_SOUND, dc->categories);
hw/audio/cs4231a.c:    dc->desc = "Crystal Semiconductor CS4231A";
hw/audio/cs4231a.c:    dc->vmsd = &vmstate_cs4231a;
hw/audio/cs4231a.c:    dc->props = cs4231a_properties;
hw/audio/marvell_88w8618.c:    dc->reset = mv88w8618_audio_reset;
hw/audio/marvell_88w8618.c:    dc->vmsd = &mv88w8618_audio_vmsd;
hw/audio/marvell_88w8618.c:    dc->props = mv88w8618_audio_properties;
hw/audio/marvell_88w8618.c:    dc->cannot_instantiate_with_device_add_yet = true;
hw/audio/marvell_88w8618.c.orig:    dc->reset = mv88w8618_audio_reset;
hw/audio/marvell_88w8618.c.orig:    dc->vmsd = &mv88w8618_audio_vmsd;
hw/audio/marvell_88w8618.c.orig:    dc->props = mv88w8618_audio_properties;
hw/audio/marvell_88w8618.c.orig:    dc->cannot_instantiate_with_device_add_yet = true;
hw/audio/wm8750.c~:    dc->vmsd = &vmstate_wm8750;
hw/audio/wm8731.c~:    dc->vmsd  = &vmstate_wm8731;
hw/audio/pcspk.c:    dc->realize = pcspk_realizefn;
hw/audio/pcspk.c:    set_bit(DEVICE_CATEGORY_SOUND, dc->categories);
hw/audio/pcspk.c:    dc->props = pcspk_properties;
hw/audio/pcspk.c:    dc->cannot_instantiate_with_device_add_yet = true;
hw/audio/intel-hda.c:    return cdc->init(dev);
hw/audio/intel-hda.c:    if (cdc->exit) {
hw/audio/intel-hda.c:        cdc->exit(dev);
hw/audio/intel-hda.c:    cdc->command(codec, nid, data);
hw/audio/intel-hda.c:        if (cdc->stream) {
hw/audio/intel-hda.c:            cdc->stream(cdev, stream, running, output);
hw/audio/intel-hda.c:    dc->reset = intel_hda_reset;
hw/audio/intel-hda.c:    dc->vmsd = &vmstate_intel_hda;
hw/audio/intel-hda.c:    dc->props = intel_hda_properties;
hw/audio/intel-hda.c:    set_bit(DEVICE_CATEGORY_SOUND, dc->categories);
hw/audio/intel-hda.c:    dc->desc = "Intel HD Audio Controller (ich6)";
hw/audio/intel-hda.c:    set_bit(DEVICE_CATEGORY_SOUND, dc->categories);
hw/audio/intel-hda.c:    dc->desc = "Intel HD Audio Controller (ich9)";
hw/audio/wm8750.c:    dc->vmsd = &vmstate_wm8750;
hw/audio/sb16.c:    dc->realize = sb16_realizefn;
hw/audio/sb16.c:    set_bit(DEVICE_CATEGORY_SOUND, dc->categories);
hw/audio/sb16.c:    dc->desc = "Creative Sound Blaster 16";
hw/audio/sb16.c:    dc->vmsd = &vmstate_sb16;
hw/audio/sb16.c:    dc->props = sb16_properties;
hw/audio/wm8750.c.orig:    dc->vmsd = &vmstate_wm8750;
hw/ide/mmio.c:    dc->realize = mmio_ide_realizefn;
hw/ide/mmio.c:    dc->reset = mmio_ide_reset;
hw/ide/mmio.c:    dc->props = mmio_ide_properties;
hw/ide/mmio.c:    dc->vmsd = &vmstate_ide_mmio;
hw/ide/ich.c:    dc->vmsd = &vmstate_ich9_ahci;
hw/ide/ich.c:    dc->reset = pci_ich9_reset;
hw/ide/ich.c:    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
hw/ide/qdev.c:    return dc->init(dev);
hw/ide/qdev.c:    dc->fw_name = "drive";
hw/ide/qdev.c:    dc->desc = "virtual IDE disk";
hw/ide/qdev.c:    dc->props = ide_hd_properties;
hw/ide/qdev.c:    dc->fw_name = "drive";
hw/ide/qdev.c:    dc->desc = "virtual IDE CD-ROM";
hw/ide/qdev.c:    dc->props = ide_cd_properties;
hw/ide/qdev.c:    dc->fw_name = "drive";
hw/ide/qdev.c:    dc->desc = "virtual IDE disk or CD-ROM (legacy)";
hw/ide/qdev.c:    dc->props = ide_drive_properties;
hw/ide/via.c:    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
hw/ide/isa.c:    dc->realize = isa_ide_realizefn;
hw/ide/isa.c:    dc->fw_name = "ide";
hw/ide/isa.c:    dc->reset = isa_ide_reset;
hw/ide/isa.c:    dc->props = isa_ide_properties;
hw/ide/isa.c:    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
hw/ide/microdrive.c:    dc->realize = microdrive_realize;
hw/ide/microdrive.c:    dc->reset = md_reset;
hw/ide/microdrive.c:    dc->vmsd = &vmstate_microdrive;
hw/ide/ahci.c:    dc->realize = sysbus_ahci_realize;
hw/ide/ahci.c:    dc->vmsd = &vmstate_sysbus_ahci;
hw/ide/ahci.c:    dc->props = sysbus_ahci_properties;
hw/ide/ahci.c:    dc->reset = sysbus_ahci_reset;
hw/ide/ahci.c:    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
hw/ide/cmd646.c:    dc->props = cmd646_ide_properties;
hw/ide/piix.c:    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
hw/ide/piix.c:    dc->hotpluggable = false;
hw/ide/piix.c:    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
hw/ide/piix.c:    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
hw/ide/piix.c:    dc->hotpluggable = false;
hw/ide/macio.c:    dc->realize = macio_ide_realizefn;
hw/ide/macio.c:    dc->reset = macio_ide_reset;
hw/ide/macio.c:    dc->vmsd = &vmstate_pmac;
hw/arm/stellaris.c:    sdc->init = stellaris_i2c_init;
hw/arm/stellaris.c:    sdc->init = stellaris_gptm_init;
hw/arm/stellaris.c:    sdc->init = stellaris_adc_init;
hw/arm/strongarm.c:    dc->desc = "StrongARM PIC";
hw/arm/strongarm.c:    dc->vmsd = &vmstate_strongarm_pic_regs;
hw/arm/strongarm.c:    dc->desc = "StrongARM RTC Controller";
hw/arm/strongarm.c:    dc->vmsd = &vmstate_strongarm_rtc_regs;
hw/arm/strongarm.c:    dc->desc = "StrongARM GPIO controller";
hw/arm/strongarm.c:    dc->desc = "StrongARM PPC controller";
hw/arm/strongarm.c:    dc->desc = "StrongARM UART controller";
hw/arm/strongarm.c:    dc->reset = strongarm_uart_reset;
hw/arm/strongarm.c:    dc->vmsd = &vmstate_strongarm_uart_regs;
hw/arm/strongarm.c:    dc->props = strongarm_uart_properties;
hw/arm/strongarm.c:    dc->desc = "StrongARM SSP controller";
hw/arm/strongarm.c:    dc->reset = strongarm_ssp_reset;
hw/arm/strongarm.c:    dc->vmsd = &vmstate_strongarm_ssp_regs;
hw/arm/integratorcp.c:    dc->props = core_properties;
hw/arm/integratorcp.c:    sdc->init = icp_pic_init;
hw/arm/z2.c:    dc->vmsd = &vmstate_zipit_lcd_state;
hw/arm/z2.c:    dc->vmsd = &vmstate_aer915_state;
hw/arm/pxa2xx.c:    dc->desc = "PXA2xx RTC Controller";
hw/arm/pxa2xx.c:    dc->vmsd = &vmstate_pxa2xx_rtc_regs;
hw/arm/pxa2xx.c:    dc->desc = "PXA2xx I2C Bus Controller";
hw/arm/pxa2xx.c:    dc->vmsd = &vmstate_pxa2xx_i2c;
hw/arm/pxa2xx.c:    dc->props = pxa2xx_i2c_properties;
hw/arm/pxa2xx.c:    sdc->init = pxa2xx_ssp_init;
hw/arm/highbank.c:    dc->desc = "Calxeda Highbank registers";
hw/arm/highbank.c:    dc->vmsd = &vmstate_highbank_regs;
hw/arm/highbank.c:    dc->reset = highbank_regs_reset;
hw/arm/armv7m.c:    dc->props = bitband_properties;
hw/arm/z2.c.orig:    dc->vmsd = &vmstate_zipit_lcd_state;
hw/arm/z2.c.orig:    dc->vmsd = &vmstate_aer915_state;
hw/arm/ftplat_a369soc.c:    dc->desc  = TYPE_FARADAY_SOC;
hw/arm/ftplat_a369soc.c:    dc->vmsd  = &vmstate_a369soc;
hw/arm/ftplat_a369soc.c:    dc->reset = a369soc_reset;
hw/arm/ftplat_a369soc.c:    dc->realize = a369soc_realize;
hw/arm/ftplat_a369soc.c:    dc->no_user = 1;
hw/arm/pxa2xx_gpio.c:    dc->desc = "PXA2xx GPIO controller";
hw/arm/pxa2xx_gpio.c:    dc->props = pxa2xx_gpio_properties;
hw/arm/nseries.c:    dc->reset = mipid_reset;
hw/arm/nseries.c:    dc->props = mipid_properties;
hw/arm/nseries.c:    dc->props = lis302dl_properties;
hw/arm/nseries.c:    dc->reset = lis302dl_reset;
hw/arm/nseries.c:    dc->props = bq2415x_properties;
hw/arm/nseries.c:    dc->reset = bq2415x_reset;
hw/arm/nseries.c:    dc->reset = tpa6130_reset;
hw/arm/spitz.c:    dc->vmsd = &vmstate_sl_nand_info;
hw/arm/spitz.c:    dc->props = sl_nand_properties;
hw/arm/spitz.c:    dc->vmsd = &vmstate_spitz_kbd;
hw/arm/spitz.c:    dc->props = spitz_keyboard_properties;
hw/arm/spitz.c:    dc->vmsd = &vmstate_corgi_ssp_regs;
hw/arm/spitz.c:    dc->vmsd = &vmstate_spitz_lcdtg_regs;
hw/arm/versatilepb.c:    dc->vmsd = &vmstate_vpb_sic;
hw/arm/ftplat_a369scu.c:    dc->desc  = TYPE_A369SCU;
hw/arm/ftplat_a369scu.c:    dc->vmsd  = &vmstate_a369scu;
hw/arm/ftplat_a369scu.c:    dc->reset = a369scu_reset;
hw/arm/ftplat_a369scu.c:    dc->realize = a369scu_realize;
hw/arm/ftplat_a369scu.c:    dc->no_user = 1;
hw/arm/digic.c:    dc->realize = digic_realize;
hw/arm/pxa2xx_pic.c:    dc->desc = "PXA2xx PIC";
hw/arm/pxa2xx_pic.c:    dc->vmsd = &vmstate_pxa2xx_pic_regs;
hw/arm/musicpal.c:    dc->vmsd = &mv88w8618_eth_vmsd;
hw/arm/musicpal.c:    dc->props = mv88w8618_eth_properties;
hw/arm/musicpal.c:    dc->vmsd = &musicpal_lcd_vmsd;
hw/arm/musicpal.c:    dc->reset = mv88w8618_pic_reset;
hw/arm/musicpal.c:    dc->vmsd = &mv88w8618_pic_vmsd;
hw/arm/musicpal.c:    dc->reset = mv88w8618_pit_reset;
hw/arm/musicpal.c:    dc->vmsd = &mv88w8618_pit_vmsd;
hw/arm/musicpal.c:    dc->vmsd = &mv88w8618_flashcfg_vmsd;
hw/arm/musicpal.c:    dc->reset = musicpal_gpio_reset;
hw/arm/musicpal.c:    dc->vmsd = &musicpal_gpio_vmsd;
hw/arm/musicpal.c:    dc->vmsd = &musicpal_key_vmsd;
hw/arm/musicpal.c:    sdc->init = mv88w8618_wlan_init;
hw/arm/spitz.c.orig:    dc->vmsd = &vmstate_sl_nand_info;
hw/arm/spitz.c.orig:    dc->props = sl_nand_properties;
hw/arm/spitz.c.orig:    dc->vmsd = &vmstate_spitz_kbd;
hw/arm/spitz.c.orig:    dc->props = spitz_keyboard_properties;
hw/arm/spitz.c.orig:    dc->vmsd = &vmstate_corgi_ssp_regs;
hw/arm/spitz.c.orig:    dc->vmsd = &vmstate_spitz_lcdtg_regs;
hw/arm/ftplat_a369kpd.c:    dc->desc  = TYPE_A369KPD;
hw/arm/ftplat_a369kpd.c:    dc->vmsd  = &vmstate_ftkbc010;
hw/arm/ftplat_a369kpd.c:    dc->reset = a369kpd_reset;
hw/arm/ftplat_a369kpd.c:    dc->realize = a369kpd_realize;
hw/arm/ftplat_a369soc.c~:    dc->desc  = TYPE_FARADAY_SOC;
hw/arm/ftplat_a369soc.c~:    dc->vmsd  = &vmstate_a369soc;
hw/arm/ftplat_a369soc.c~:    dc->reset = a369soc_reset;
hw/arm/ftplat_a369soc.c~:    dc->realize = a369soc_realize;
hw/arm/ftplat_a369soc.c~:    dc->no_user = 1;
hw/arm/allwinner-a10.c:    dc->realize = aw_a10_realize;
hw/arm/ftplat_a369soc.c.orig:    dc->desc  = TYPE_FARADAY_SOC;
hw/arm/ftplat_a369soc.c.orig:    dc->vmsd  = &vmstate_a369soc;
hw/arm/ftplat_a369soc.c.orig:    dc->reset = a369soc_reset;
hw/arm/ftplat_a369soc.c.orig:    dc->realize = a369soc_realize;
hw/arm/ftplat_a369soc.c.orig:    dc->no_user = 1;
hw/ftssp010.c:    dc->vmsd    = &vmstate_ftssp010;
hw/ftssp010.c:    dc->reset   = ftssp010_reset;
hw/ftssp010.c:    dc->realize = ftssp010_realize;
hw/ftssp010.c:    dc->no_user = 1;
hw/tpm/tpm_tis.c:    dc->realize = tpm_tis_realizefn;
hw/tpm/tpm_tis.c:    dc->props = tpm_tis_properties;
hw/tpm/tpm_tis.c:    dc->reset = tpm_tis_reset;
hw/tpm/tpm_tis.c:    dc->vmsd  = &vmstate_tpm_tis;
Binary file i386-linux-user/qemu-i386 matches
Binary file i386-softmmu/qemu-system-i386 matches
include/hw/qdev-properties.h: *   dc->cannot_instantiate_with_device_add_yet = true;
include/hw/qdev-properties.h: *    * no need for dc->cannot_instantiate_with_device_add_yet = true;
include/qom/object.h: *     dc->reset = my_device_reset;
include/qom/object.h: *     dc->parent_do_something(obj);
include/qom/object.h: *     dc->parent_do_something = mc->do_something;
Binary file lm32-softmmu/qemu-system-lm32 matches
Binary file m68k-linux-user/qemu-m68k matches
Binary file m68k-softmmu/qemu-system-m68k matches
Binary file microblazeel-linux-user/qemu-microblazeel matches
Binary file microblazeel-softmmu/qemu-system-microblazeel matches
Binary file microblaze-linux-user/qemu-microblaze matches
Binary file microblaze-softmmu/qemu-system-microblaze matches
Binary file mips64el-linux-user/qemu-mips64el matches
Binary file mips64el-softmmu/qemu-system-mips64el matches
Binary file mips64-linux-user/qemu-mips64 matches
Binary file mips64-softmmu/qemu-system-mips64 matches
Binary file mipsel-linux-user/qemu-mipsel matches
Binary file mipsel-softmmu/qemu-system-mipsel matches
Binary file mips-linux-user/qemu-mips matches
Binary file mipsn32el-linux-user/qemu-mipsn32el matches
Binary file mipsn32-linux-user/qemu-mipsn32 matches
Binary file mips-softmmu/qemu-system-mips matches
Binary file moxie-softmmu/qemu-system-moxie matches
Binary file or32-linux-user/qemu-or32 matches
Binary file or32-softmmu/qemu-system-or32 matches
pc-bios/optionrom/linuxboot.asm:# 1 "/usr/include/stdc-predef.h" 1 3 4
pc-bios/optionrom/kvmvapic.asm:# 1 "/usr/include/stdc-predef.h" 1 3 4
pc-bios/optionrom/multiboot.asm:# 1 "/usr/include/stdc-predef.h" 1 3 4
Binary file ppc64abi32-linux-user/qemu-ppc64abi32 matches
Binary file ppc64-linux-user/qemu-ppc64 matches
Binary file ppc64-softmmu/qemu-system-ppc64 matches
Binary file ppcemb-softmmu/qemu-system-ppcemb matches
Binary file ppc-linux-user/qemu-ppc matches
Binary file ppc-softmmu/qemu-system-ppc matches
qdev-monitor.c:    if (dc->bus_type) {
qdev-monitor.c:        error_printf(", bus %s", dc->bus_type);
qdev-monitor.c:    if (dc->desc) {
qdev-monitor.c:        error_printf(", desc \"%s\"", dc->desc);
qdev-monitor.c:    if (dc->cannot_instantiate_with_device_add_yet) {
qdev-monitor.c:                 ? !test_bit(i, dc->categories)
qdev-monitor.c:                 : !bitmap_empty(dc->categories, DEVICE_CATEGORY_MAX))
qdev-monitor.c:                    && dc->cannot_instantiate_with_device_add_yet)) {
qdev-monitor.c:    if (dc->cannot_instantiate_with_device_add_yet) {
qdev-monitor.c:        if (!object_dynamic_cast(OBJECT(bus), dc->bus_type)) {
qdev-monitor.c:    } else if (dc->bus_type != NULL) {
qdev-monitor.c:        bus = qbus_find_recursive(sysbus_get_default(), NULL, dc->bus_type);
qdev-monitor.c:                          dc->bus_type, driver);
qdict-test-data.txt:cdc-acm.c: 43081
qdict-test-data.txt:cdc-acm.h: 3737
qdict-test-data.txt:cdc-wdm.c: 19634
qom/cpu.c:    dc->realize = cpu_common_realizefn;
qom/cpu.c:    dc->cannot_instantiate_with_device_add_yet = true;
Binary file s390x-linux-user/qemu-s390x matches
Binary file s390x-softmmu/qemu-system-s390x matches
Binary file sh4eb-linux-user/qemu-sh4eb matches
Binary file sh4eb-softmmu/qemu-system-sh4eb matches
Binary file sh4-linux-user/qemu-sh4 matches
Binary file sh4-softmmu/qemu-system-sh4 matches
Binary file sparc32plus-linux-user/qemu-sparc32plus matches
Binary file sparc64-linux-user/qemu-sparc64 matches
Binary file sparc64-softmmu/qemu-system-sparc64 matches
Binary file sparc-linux-user/qemu-sparc matches
Binary file sparc-softmmu/qemu-system-sparc matches
target-alpha/cpu.c:    acc->parent_realize = dc->realize;
target-alpha/cpu.c:    dc->realize = alpha_cpu_realizefn;
target-alpha/cpu.c:    dc->vmsd = &vmstate_alpha_cpu;
target-arm/translate.c:    dc->tb = tb;
target-arm/translate.c:    dc->is_jmp = DISAS_NEXT;
target-arm/translate.c:    dc->pc = pc_start;
target-arm/translate.c:    dc->singlestep_enabled = cs->singlestep_enabled;
target-arm/translate.c:    dc->condjmp = 0;
target-arm/translate.c:    dc->aarch64 = 0;
target-arm/translate.c:    dc->thumb = ARM_TBFLAG_THUMB(tb->flags);
target-arm/translate.c:    dc->bswap_code = ARM_TBFLAG_BSWAP_CODE(tb->flags);
target-arm/translate.c:    dc->condexec_mask = (ARM_TBFLAG_CONDEXEC(tb->flags) & 0xf) << 1;
target-arm/translate.c:    dc->condexec_cond = ARM_TBFLAG_CONDEXEC(tb->flags) >> 4;
target-arm/translate.c:    dc->user = (ARM_TBFLAG_PRIV(tb->flags) == 0);
target-arm/translate.c:    dc->vfp_enabled = ARM_TBFLAG_VFPEN(tb->flags);
target-arm/translate.c:    dc->vec_len = ARM_TBFLAG_VECLEN(tb->flags);
target-arm/translate.c:    dc->vec_stride = ARM_TBFLAG_VECSTRIDE(tb->flags);
target-arm/translate.c:    dc->cp_regs = cpu->cp_regs;
target-arm/translate.c:    dc->current_pl = arm_current_pl(env);
target-arm/translate.c:    dc->features = env->features;
target-arm/translate.c:    if (dc->condexec_mask || dc->condexec_cond)
target-arm/translate.c:        if (dc->pc >= 0xffff0000) {
target-arm/translate.c:            dc->is_jmp = DISAS_UPDATE;
target-arm/translate.c:        if (dc->pc >= 0xfffffff0 && IS_M(env)) {
target-arm/translate.c:            dc->is_jmp = DISAS_UPDATE;
target-arm/translate.c:                if (bp->pc == dc->pc) {
target-arm/translate.c:                    dc->pc += 2;
target-arm/translate.c:            tcg_ctx.gen_opc_pc[lj] = dc->pc;
target-arm/translate.c:            gen_opc_condexec_bits[lj] = (dc->condexec_cond << 4) | (dc->condexec_mask >> 1);
target-arm/translate.c:            tcg_gen_debug_insn_start(dc->pc);
target-arm/translate.c:        if (dc->thumb) {
target-arm/translate.c:            if (dc->condexec_mask) {
target-arm/translate.c:                dc->condexec_cond = (dc->condexec_cond & 0xe)
target-arm/translate.c:                                   | ((dc->condexec_mask >> 4) & 1);
target-arm/translate.c:                dc->condexec_mask = (dc->condexec_mask << 1) & 0x1f;
target-arm/translate.c:                if (dc->condexec_mask == 0) {
target-arm/translate.c:                    dc->condexec_cond = 0;
target-arm/translate.c:        if (dc->condjmp && !dc->is_jmp) {
target-arm/translate.c:            gen_set_label(dc->condlabel);
target-arm/translate.c:            dc->condjmp = 0;
target-arm/translate.c:                    dc->pc);
target-arm/translate.c:    } while (!dc->is_jmp && tcg_ctx.gen_opc_ptr < gen_opc_end &&
target-arm/translate.c:             dc->pc < next_page_start &&
target-arm/translate.c:        if (dc->condjmp) {
target-arm/translate.c:    /* At this stage dc->condjmp will only be set when the skipped
target-arm/translate.c:        if (dc->condjmp) {
target-arm/translate.c:            if (dc->is_jmp == DISAS_SWI) {
target-arm/translate.c:            } else if (dc->is_jmp == DISAS_SMC) {
target-arm/translate.c:            gen_set_label(dc->condlabel);
target-arm/translate.c:        if (dc->condjmp || !dc->is_jmp) {
target-arm/translate.c:            gen_set_pc_im(dc, dc->pc);
target-arm/translate.c:            dc->condjmp = 0;
target-arm/translate.c:        if (dc->is_jmp == DISAS_SWI && !dc->condjmp) {
target-arm/translate.c:        } else if (dc->is_jmp == DISAS_SMC && !dc->condjmp) {
target-arm/translate.c:        switch(dc->is_jmp) {
target-arm/translate.c:            gen_goto_tb(dc, 1, dc->pc);
target-arm/translate.c:        if (dc->condjmp) {
target-arm/translate.c:            gen_set_label(dc->condlabel);
target-arm/translate.c:            gen_goto_tb(dc, 1, dc->pc);
target-arm/translate.c:            dc->condjmp = 0;
target-arm/translate.c:        log_target_disas(env, pc_start, dc->pc - pc_start,
target-arm/translate.c:                         dc->thumb | (dc->bswap_code << 1));
target-arm/translate.c:        tb->size = dc->pc - pc_start;
target-arm/cpu.c.orig:    acc->parent_realize = dc->realize;
target-arm/cpu.c.orig:    dc->realize = arm_cpu_realizefn;
target-arm/cpu.c.orig:    dc->props = arm_cpu_properties;
target-arm/translate.h:    return (dc->features & (1ULL << feature)) != 0;
target-arm/cpu.c:    acc->parent_realize = dc->realize;
target-arm/cpu.c:    dc->realize = arm_cpu_realizefn;
target-arm/cpu.c:    dc->props = arm_cpu_properties;
target-arm/translate-a64.c:    dc->tb = tb;
target-arm/translate-a64.c:    dc->is_jmp = DISAS_NEXT;
target-arm/translate-a64.c:    dc->pc = pc_start;
target-arm/translate-a64.c:    dc->singlestep_enabled = cs->singlestep_enabled;
target-arm/translate-a64.c:    dc->condjmp = 0;
target-arm/translate-a64.c:    dc->aarch64 = 1;
target-arm/translate-a64.c:    dc->thumb = 0;
target-arm/translate-a64.c:    dc->bswap_code = 0;
target-arm/translate-a64.c:    dc->condexec_mask = 0;
target-arm/translate-a64.c:    dc->condexec_cond = 0;
target-arm/translate-a64.c:    dc->user = (ARM_TBFLAG_AA64_EL(tb->flags) == 0);
target-arm/translate-a64.c:    dc->vfp_enabled = 0;
target-arm/translate-a64.c:    dc->vec_len = 0;
target-arm/translate-a64.c:    dc->vec_stride = 0;
target-arm/translate-a64.c:    dc->cp_regs = cpu->cp_regs;
target-arm/translate-a64.c:    dc->current_pl = arm_current_pl(env);
target-arm/translate-a64.c:    dc->features = env->features;
target-arm/translate-a64.c:                if (bp->pc == dc->pc) {
target-arm/translate-a64.c:                    dc->pc += 2;
target-arm/translate-a64.c:            tcg_ctx.gen_opc_pc[lj] = dc->pc;
target-arm/translate-a64.c:            tcg_gen_debug_insn_start(dc->pc);
target-arm/translate-a64.c:                    dc->pc);
target-arm/translate-a64.c:    } while (!dc->is_jmp && tcg_ctx.gen_opc_ptr < gen_opc_end &&
target-arm/translate-a64.c:             dc->pc < next_page_start &&
target-arm/translate-a64.c:    if (unlikely(cs->singlestep_enabled) && dc->is_jmp != DISAS_EXC) {
target-arm/translate-a64.c:        assert(dc->is_jmp != DISAS_TB_JUMP);
target-arm/translate-a64.c:        if (dc->is_jmp != DISAS_JUMP) {
target-arm/translate-a64.c:            gen_a64_set_pc_im(dc->pc);
target-arm/translate-a64.c:        switch (dc->is_jmp) {
target-arm/translate-a64.c:            gen_goto_tb(dc, 1, dc->pc);
target-arm/translate-a64.c:            gen_a64_set_pc_im(dc->pc);
target-arm/translate-a64.c:            gen_a64_set_pc_im(dc->pc);
target-arm/translate-a64.c:        log_target_disas(env, pc_start, dc->pc - pc_start,
target-arm/translate-a64.c:                         4 | (dc->bswap_code << 1));
target-arm/translate-a64.c:        tb->size = dc->pc - pc_start;
target-cris/translate.c:    printf("BUG: pc=%x %s %d\n", dc->pc, file, line);
target-cris/translate.c:    qemu_log("BUG: pc=%x %s %d\n", dc->pc, file, line);
target-cris/translate.c:    cpu_abort(CPU(dc->cpu), "%s:%d\n", file, line);
target-cris/translate.c:        if (dc->tb_flags & S_FLAG && r == PR_SPC) {
target-cris/translate.c:            dc->cpustate_changed = 1;
target-cris/translate.c:        cpu_abort(CPU(dc->cpu), "Invalid fetch size %d\n", size);
target-cris/translate.c:    dc->clear_locked_irq = 0;
target-cris/translate.c:    if (dc->flagx_known) {
target-cris/translate.c:        if (dc->flags_x) {
target-cris/translate.c:    if (dc->flagx_known) {
target-cris/translate.c:        if (dc->flags_x) {
target-cris/translate.c:    tb = dc->tb;
target-cris/translate.c:    if (dc->flagx_known && dc->flags_x) {
target-cris/translate.c:        dc->flags_uptodate = 0;
target-cris/translate.c:    dc->flagx_known = 1;
target-cris/translate.c:    dc->flags_x = 0;
target-cris/translate.c:    if (dc->cc_size_uptodate != dc->cc_size) {
target-cris/translate.c:        tcg_gen_movi_tl(cc_size, dc->cc_size);
target-cris/translate.c:        dc->cc_size_uptodate = dc->cc_size;
target-cris/translate.c:    tcg_gen_movi_tl(cc_op, dc->cc_op);
target-cris/translate.c:    tcg_gen_movi_tl(cc_mask, dc->cc_mask);
target-cris/translate.c:    if (dc->flags_uptodate) {
target-cris/translate.c:    switch (dc->cc_op) {
target-cris/translate.c:        switch (dc->cc_size) {
target-cris/translate.c:        if (dc->cc_size == 4) {
target-cris/translate.c:        switch (dc->cc_size) {
target-cris/translate.c:    if (dc->flagx_known) {
target-cris/translate.c:        if (dc->flags_x) {
target-cris/translate.c:        } else if (dc->cc_op == CC_OP_FLAGS) {
target-cris/translate.c:    dc->flags_uptodate = 1;
target-cris/translate.c:        dc->update_cc = 0;
target-cris/translate.c:    ovl = (dc->cc_mask ^ mask) & ~mask;
target-cris/translate.c:    dc->cc_mask = mask;
target-cris/translate.c:    dc->update_cc = 1;
target-cris/translate.c:    dc->cc_op = op;
target-cris/translate.c:    dc->cc_size = size;
target-cris/translate.c:    dc->flags_uptodate = 0;
target-cris/translate.c:    if (dc->flagx_known) {
target-cris/translate.c:        if (dc->cc_x_uptodate == (2 | dc->flags_x)) {
target-cris/translate.c:        tcg_gen_movi_tl(cc_x, dc->flags_x);
target-cris/translate.c:        dc->cc_x_uptodate = 2 | dc->flags_x;
target-cris/translate.c:        dc->cc_x_uptodate = 1;
target-cris/translate.c:    if (dc->update_cc) {
target-cris/translate.c:    if (dc->update_cc) {
target-cris/translate.c:    if (dc->update_cc) {
target-cris/translate.c:        switch (dc->cc_op) {
target-cris/translate.c:    arith_opt = arith_cc(dc) && !dc->flags_uptodate;
target-cris/translate.c:    move_opt = (dc->cc_op == CC_OP_MOVE);
target-cris/translate.c:                && dc->cc_x_uptodate != (2 | X_FLAG)) {
target-cris/translate.c:                && dc->cc_x_uptodate != (2 | X_FLAG)) {
target-cris/translate.c:            if (dc->cc_size == 1) {
target-cris/translate.c:            } else if (dc->cc_size == 2) {
target-cris/translate.c:            if (dc->cc_size == 1) {
target-cris/translate.c:            } else if (dc->cc_size == 2) {
target-cris/translate.c:    if (dc->jmp == JMP_DIRECT || dc->jmp == JMP_DIRECT_CC) {
target-cris/translate.c:        if (dc->jmp == JMP_DIRECT) {
target-cris/translate.c:        tcg_gen_movi_tl(env_btarget, dc->jmp_pc);
target-cris/translate.c:        dc->jmp = JMP_INDIRECT;
target-cris/translate.c:    dc->delayed_branch = 2;
target-cris/translate.c:    dc->jmp = JMP_DIRECT_CC;
target-cris/translate.c:    dc->jmp_pc = dc->pc + offset;
target-cris/translate.c:    tcg_gen_movi_tl(env_btarget, dc->jmp_pc);
target-cris/translate.c:    dc->delayed_branch = 2;
target-cris/translate.c:    dc->jmp = type;
target-cris/translate.c:    int mem_index = cpu_mmu_index(&dc->cpu->env);
target-cris/translate.c:    if (dc->delayed_branch == 1) {
target-cris/translate.c:    int mem_index = cpu_mmu_index(&dc->cpu->env);
target-cris/translate.c:    if (dc->delayed_branch == 1) {
target-cris/translate.c:    int mem_index = cpu_mmu_index(&dc->cpu->env);
target-cris/translate.c:    if (dc->delayed_branch == 1) {
target-cris/translate.c:    if (dc->flagx_known && dc->flags_x && (dc->tb_flags & P_FLAG)) {
target-cris/translate.c:        dc->postinc = 0;
target-cris/translate.c:    if (dc->flagx_known && dc->flags_x) {
target-cris/translate.c:    return dc->zsize + 1;
target-cris/translate.c:    switch (dc->zzsize) {
target-cris/translate.c:    if (dc->postinc) {
target-cris/translate.c:        tcg_gen_addi_tl(cpu_R[dc->op1], cpu_R[dc->op1], size);
target-cris/translate.c:    rs = dc->op1;
target-cris/translate.c:    is_imm = rs == 15 && dc->postinc;
target-cris/translate.c:        imm = cris_fetch(env, dc, dc->pc + 2, memsize, s_ext);
target-cris/translate.c:        dc->postinc = 0;
target-cris/translate.c:    tcg_gen_mov_tl(dst, cpu_R[dc->op2]);
target-cris/translate.c:    uint32_t cond = dc->op2;
target-cris/translate.c:    offset = EXTRACT_FIELD(dc->ir, 1, 7);
target-cris/translate.c:    sign = EXTRACT_FIELD(dc->ir, 0, 0);
target-cris/translate.c:    LOG_DIS("b%s %x\n", cc_name(cond), dc->pc + offset);
target-cris/translate.c:    dc->op1 = EXTRACT_FIELD(dc->ir, 0, 7);
target-cris/translate.c:    imm = sign_extend(dc->op1, 7);
target-cris/translate.c:    LOG_DIS("addoq %d, $r%u\n", imm, dc->op2);
target-cris/translate.c:    tcg_gen_addi_tl(cpu_R[R_ACR], cpu_R[dc->op2], imm);
target-cris/translate.c:    LOG_DIS("addq %u, $r%u\n", dc->op1, dc->op2);
target-cris/translate.c:    dc->op1 = EXTRACT_FIELD(dc->ir, 0, 5);
target-cris/translate.c:            cpu_R[dc->op2], cpu_R[dc->op2], tcg_const_tl(dc->op1), 4);
target-cris/translate.c:    dc->op1 = EXTRACT_FIELD(dc->ir, 0, 5);
target-cris/translate.c:    imm = sign_extend(dc->op1, 5);
target-cris/translate.c:    LOG_DIS("moveq %d, $r%u\n", imm, dc->op2);
target-cris/translate.c:    tcg_gen_movi_tl(cpu_R[dc->op2], imm);
target-cris/translate.c:    dc->op1 = EXTRACT_FIELD(dc->ir, 0, 5);
target-cris/translate.c:    LOG_DIS("subq %u, $r%u\n", dc->op1, dc->op2);
target-cris/translate.c:            cpu_R[dc->op2], cpu_R[dc->op2], tcg_const_tl(dc->op1), 4);
target-cris/translate.c:    dc->op1 = EXTRACT_FIELD(dc->ir, 0, 5);
target-cris/translate.c:    imm = sign_extend(dc->op1, 5);
target-cris/translate.c:    LOG_DIS("cmpq %d, $r%d\n", imm, dc->op2);
target-cris/translate.c:            cpu_R[dc->op2], cpu_R[dc->op2], tcg_const_tl(imm), 4);
target-cris/translate.c:    dc->op1 = EXTRACT_FIELD(dc->ir, 0, 5);
target-cris/translate.c:    imm = sign_extend(dc->op1, 5);
target-cris/translate.c:    LOG_DIS("andq %d, $r%d\n", imm, dc->op2);
target-cris/translate.c:            cpu_R[dc->op2], cpu_R[dc->op2], tcg_const_tl(imm), 4);
target-cris/translate.c:    dc->op1 = EXTRACT_FIELD(dc->ir, 0, 5);
target-cris/translate.c:    imm = sign_extend(dc->op1, 5);
target-cris/translate.c:    LOG_DIS("orq %d, $r%d\n", imm, dc->op2);
target-cris/translate.c:            cpu_R[dc->op2], cpu_R[dc->op2], tcg_const_tl(imm), 4);
target-cris/translate.c:    dc->op1 = EXTRACT_FIELD(dc->ir, 0, 4);
target-cris/translate.c:    LOG_DIS("btstq %u, $r%d\n", dc->op1, dc->op2);
target-cris/translate.c:        gen_helper_btst(cpu_PR[PR_CCS], cpu_env, cpu_R[dc->op2],
target-cris/translate.c:            tcg_const_tl(dc->op1), cpu_PR[PR_CCS]);
target-cris/translate.c:         cpu_R[dc->op2], cpu_R[dc->op2], cpu_R[dc->op2], 4);
target-cris/translate.c:    dc->flags_uptodate = 1;
target-cris/translate.c:    dc->op1 = EXTRACT_FIELD(dc->ir, 0, 4);
target-cris/translate.c:    LOG_DIS("asrq %u, $r%d\n", dc->op1, dc->op2);
target-cris/translate.c:    tcg_gen_sari_tl(cpu_R[dc->op2], cpu_R[dc->op2], dc->op1);
target-cris/translate.c:            cpu_R[dc->op2],
target-cris/translate.c:            cpu_R[dc->op2], cpu_R[dc->op2], 4);
target-cris/translate.c:    dc->op1 = EXTRACT_FIELD(dc->ir, 0, 4);
target-cris/translate.c:    LOG_DIS("lslq %u, $r%d\n", dc->op1, dc->op2);
target-cris/translate.c:    tcg_gen_shli_tl(cpu_R[dc->op2], cpu_R[dc->op2], dc->op1);
target-cris/translate.c:            cpu_R[dc->op2],
target-cris/translate.c:            cpu_R[dc->op2], cpu_R[dc->op2], 4);
target-cris/translate.c:    dc->op1 = EXTRACT_FIELD(dc->ir, 0, 4);
target-cris/translate.c:    LOG_DIS("lsrq %u, $r%d\n", dc->op1, dc->op2);
target-cris/translate.c:    tcg_gen_shri_tl(cpu_R[dc->op2], cpu_R[dc->op2], dc->op1);
target-cris/translate.c:            cpu_R[dc->op2],
target-cris/translate.c:            cpu_R[dc->op2], cpu_R[dc->op2], 4);
target-cris/translate.c:            memsize_char(size), dc->op1, dc->op2);
target-cris/translate.c:        dec_prep_move_r(dc, dc->op1, dc->op2, size, 0, cpu_R[dc->op2]);
target-cris/translate.c:        cris_update_result(dc, cpu_R[dc->op2]);
target-cris/translate.c:        dec_prep_move_r(dc, dc->op1, dc->op2, size, 0, t0);
target-cris/translate.c:             cpu_R[dc->op2],
target-cris/translate.c:             cpu_R[dc->op2], t0, size);
target-cris/translate.c:    int cond = dc->op2;
target-cris/translate.c:            cc_name(cond), dc->op1);
target-cris/translate.c:        gen_tst_cc(dc, cpu_R[dc->op1], cond);
target-cris/translate.c:        tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_R[dc->op1], 0, l1);
target-cris/translate.c:        tcg_gen_movi_tl(cpu_R[dc->op1], 1);
target-cris/translate.c:        tcg_gen_movi_tl(cpu_R[dc->op1], 1);
target-cris/translate.c:        t[0] = cpu_R[dc->op2];
target-cris/translate.c:        t[1] = cpu_R[dc->op1];
target-cris/translate.c:            memsize_char(size), dc->op1, dc->op2);
target-cris/translate.c:    dec_prep_alu_r(dc, dc->op1, dc->op2, size, 0, t[0], t[1]);
target-cris/translate.c:    cris_alu(dc, CC_OP_AND, cpu_R[dc->op2], t[0], t[1], size);
target-cris/translate.c:            dc->op1, dc->op2);
target-cris/translate.c:    dec_prep_alu_r(dc, dc->op1, dc->op2, 4, 0, cpu_R[dc->op2], t0);
target-cris/translate.c:    cris_alu(dc, CC_OP_LZ, cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);
target-cris/translate.c:            memsize_char(size), dc->op1, dc->op2);
target-cris/translate.c:    dec_prep_alu_r(dc, dc->op1, dc->op2, size, 0, t[0], t[1]);
target-cris/translate.c:    cris_alu(dc, CC_OP_LSL, cpu_R[dc->op2], t[0], t[1], size);
target-cris/translate.c:            memsize_char(size), dc->op1, dc->op2);
target-cris/translate.c:    dec_prep_alu_r(dc, dc->op1, dc->op2, size, 0, t[0], t[1]);
target-cris/translate.c:    cris_alu(dc, CC_OP_LSR, cpu_R[dc->op2], t[0], t[1], size);
target-cris/translate.c:            memsize_char(size), dc->op1, dc->op2);
target-cris/translate.c:    dec_prep_alu_r(dc, dc->op1, dc->op2, size, 1, t[0], t[1]);
target-cris/translate.c:    cris_alu(dc, CC_OP_ASR, cpu_R[dc->op2], t[0], t[1], size);
target-cris/translate.c:            memsize_char(size), dc->op1, dc->op2);
target-cris/translate.c:    dec_prep_alu_r(dc, dc->op1, dc->op2, size, 1, t[0], t[1]);
target-cris/translate.c:    cris_alu(dc, CC_OP_MULS, cpu_R[dc->op2], t[0], t[1], 4);
target-cris/translate.c:            memsize_char(size), dc->op1, dc->op2);
target-cris/translate.c:    dec_prep_alu_r(dc, dc->op1, dc->op2, size, 0, t[0], t[1]);
target-cris/translate.c:    cris_alu(dc, CC_OP_MULU, cpu_R[dc->op2], t[0], t[1], 4);
target-cris/translate.c:    LOG_DIS("dstep $r%u, $r%u\n", dc->op1, dc->op2);
target-cris/translate.c:            cpu_R[dc->op2], cpu_R[dc->op2], cpu_R[dc->op1], 4);
target-cris/translate.c:            memsize_char(size), dc->op1, dc->op2);
target-cris/translate.c:    dec_prep_alu_r(dc, dc->op1, dc->op2, size, 0, t[0], t[1]);
target-cris/translate.c:    cris_alu(dc, CC_OP_XOR, cpu_R[dc->op2], t[0], t[1], 4);
target-cris/translate.c:            memsize_char(size), dc->op1, dc->op2);
target-cris/translate.c:    dec_prep_move_r(dc, dc->op1, dc->op2, size, 0, l0);
target-cris/translate.c:    cris_alu(dc, CC_OP_BOUND, cpu_R[dc->op2], cpu_R[dc->op2], l0, 4);
target-cris/translate.c:            memsize_char(size), dc->op1, dc->op2);
target-cris/translate.c:    dec_prep_alu_r(dc, dc->op1, dc->op2, size, 0, t[0], t[1]);
target-cris/translate.c:    cris_alu(dc, CC_OP_CMP, cpu_R[dc->op2], t[0], t[1], size);
target-cris/translate.c:            dc->op1, dc->op2);
target-cris/translate.c:    tcg_gen_sari_tl(t0, cpu_R[dc->op1], 31);
target-cris/translate.c:    tcg_gen_xor_tl(cpu_R[dc->op2], cpu_R[dc->op1], t0);
target-cris/translate.c:    tcg_gen_sub_tl(cpu_R[dc->op2], cpu_R[dc->op2], t0);
target-cris/translate.c:            cpu_R[dc->op2], cpu_R[dc->op2], cpu_R[dc->op2], 4);
target-cris/translate.c:            memsize_char(size), dc->op1, dc->op2);
target-cris/translate.c:    dec_prep_alu_r(dc, dc->op1, dc->op2, size, 0, t[0], t[1]);
target-cris/translate.c:    cris_alu(dc, CC_OP_ADD, cpu_R[dc->op2], t[0], t[1], size);
target-cris/translate.c:            dc->op1, dc->op2);
target-cris/translate.c:    dc->flagx_known = 1;
target-cris/translate.c:    dc->flags_x = X_FLAG;
target-cris/translate.c:         cpu_R[dc->op2], cpu_R[dc->op2], cpu_R[dc->op1], 4);
target-cris/translate.c:             dc->op2, dc->op1);
target-cris/translate.c:            cpu_R[dc->op1], cpu_R[dc->op1], cpu_PR[dc->op2], 4);
target-cris/translate.c:             swapmode_name(dc->op2, modename), dc->op1);
target-cris/translate.c:    t_gen_mov_TN_reg(t0, dc->op1);
target-cris/translate.c:    if (dc->op2 & 8) {
target-cris/translate.c:    if (dc->op2 & 4) {
target-cris/translate.c:    if (dc->op2 & 2) {
target-cris/translate.c:    if (dc->op2 & 1) {
target-cris/translate.c:    cris_alu(dc, CC_OP_MOVE, cpu_R[dc->op1], cpu_R[dc->op1], t0, 4);
target-cris/translate.c:            memsize_char(size), dc->op1, dc->op2);
target-cris/translate.c:    dec_prep_alu_r(dc, dc->op1, dc->op2, size, 0, t[0], t[1]);
target-cris/translate.c:    cris_alu(dc, CC_OP_OR, cpu_R[dc->op2], t[0], t[1], size);
target-cris/translate.c:            memsize_char(memsize_zz(dc)), dc->op2, dc->op1);
target-cris/translate.c:    tcg_gen_shl_tl(t0, cpu_R[dc->op2], tcg_const_tl(dc->zzsize));
target-cris/translate.c:    tcg_gen_add_tl(cpu_R[dc->op1], cpu_R[dc->op1], t0);
target-cris/translate.c:          memsize_char(memsize_zz(dc)), dc->op2, dc->op1);
target-cris/translate.c:    tcg_gen_shl_tl(t0, cpu_R[dc->op2], tcg_const_tl(dc->zzsize));
target-cris/translate.c:    tcg_gen_add_tl(cpu_R[R_ACR], cpu_R[dc->op1], t0);
target-cris/translate.c:            memsize_char(size), dc->op1, dc->op2);
target-cris/translate.c:    dec_prep_alu_r(dc, dc->op1, dc->op2, size, 0, t[0], t[1]);
target-cris/translate.c:    cris_alu(dc, CC_OP_NEG, cpu_R[dc->op2], t[0], t[1], size);
target-cris/translate.c:            dc->op1, dc->op2);
target-cris/translate.c:        gen_helper_btst(cpu_PR[PR_CCS], cpu_env, cpu_R[dc->op2],
target-cris/translate.c:            cpu_R[dc->op1], cpu_PR[PR_CCS]);
target-cris/translate.c:    cris_alu(dc, CC_OP_MOVE, cpu_R[dc->op2],
target-cris/translate.c:         cpu_R[dc->op2], cpu_R[dc->op2], 4);
target-cris/translate.c:    dc->flags_uptodate = 1;
target-cris/translate.c:            memsize_char(size), dc->op1, dc->op2);
target-cris/translate.c:    dec_prep_alu_r(dc, dc->op1, dc->op2, size, 0, t[0], t[1]);
target-cris/translate.c:    cris_alu(dc, CC_OP_SUB, cpu_R[dc->op2], t[0], t[1], size);
target-cris/translate.c:            dc->op1, dc->op2);
target-cris/translate.c:    dec_prep_move_r(dc, dc->op1, dc->op2, size, 0, t0);
target-cris/translate.c:    cris_alu(dc, CC_OP_MOVE, cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);
target-cris/translate.c:            dc->op1, dc->op2);
target-cris/translate.c:    t_gen_sext(t0, cpu_R[dc->op1], size);
target-cris/translate.c:            cpu_R[dc->op2], cpu_R[dc->op1], t0, 4);
target-cris/translate.c:            dc->op1, dc->op2);
target-cris/translate.c:    t_gen_zext(t0, cpu_R[dc->op1], size);
target-cris/translate.c:    cris_alu(dc, CC_OP_ADD, cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);
target-cris/translate.c:            dc->op1, dc->op2);
target-cris/translate.c:    t_gen_sext(t0, cpu_R[dc->op1], size);
target-cris/translate.c:            cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);
target-cris/translate.c:            dc->op1, dc->op2);
target-cris/translate.c:    t_gen_zext(t0, cpu_R[dc->op1], size);
target-cris/translate.c:            cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);
target-cris/translate.c:            dc->op1, dc->op2);
target-cris/translate.c:    t_gen_sext(t0, cpu_R[dc->op1], size);
target-cris/translate.c:            cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);
target-cris/translate.c:    int set = (~dc->opcode >> 2) & 1;
target-cris/translate.c:    flags = (EXTRACT_FIELD(dc->ir, 12, 15) << 4)
target-cris/translate.c:        | EXTRACT_FIELD(dc->ir, 0, 3);
target-cris/translate.c:    if (dc->tb_flags & U_FLAG) {
target-cris/translate.c:        dc->flagx_known = 1;
target-cris/translate.c:            dc->flags_x = X_FLAG;
target-cris/translate.c:            dc->flags_x = 0;
target-cris/translate.c:        tcg_gen_movi_tl(env_pc, dc->pc + 2);
target-cris/translate.c:        dc->is_jmp = DISAS_UPDATE;
target-cris/translate.c:        dc->cpustate_changed = 1;
target-cris/translate.c:        tcg_gen_movi_tl(env_pc, dc->pc + 2);
target-cris/translate.c:        dc->is_jmp = DISAS_UPDATE;
target-cris/translate.c:        dc->cpustate_changed = 1;
target-cris/translate.c:    tcg_gen_movi_tl(cc_op, dc->cc_op);
target-cris/translate.c:        if (!(dc->tb_flags & U_FLAG) && (flags & U_FLAG)) {
target-cris/translate.c:            dc->cpustate_changed = 1;
target-cris/translate.c:    dc->flags_uptodate = 1;
target-cris/translate.c:    dc->clear_x = 0;
target-cris/translate.c:    LOG_DIS("move $r%u, $s%u\n", dc->op1, dc->op2);
target-cris/translate.c:        gen_helper_movl_sreg_reg(cpu_env, tcg_const_tl(dc->op2),
target-cris/translate.c:                                 tcg_const_tl(dc->op1));
target-cris/translate.c:    LOG_DIS("move $s%u, $r%u\n", dc->op2, dc->op1);
target-cris/translate.c:        gen_helper_movl_reg_sreg(cpu_env, tcg_const_tl(dc->op1),
target-cris/translate.c:                                 tcg_const_tl(dc->op2));
target-cris/translate.c:    LOG_DIS("move $r%u, $p%u\n", dc->op1, dc->op2);
target-cris/translate.c:    if (dc->op2 == PR_CCS) {
target-cris/translate.c:        t_gen_mov_TN_reg(t[0], dc->op1);
target-cris/translate.c:        if (dc->tb_flags & U_FLAG) {
target-cris/translate.c:        t_gen_mov_TN_reg(t[0], dc->op1);
target-cris/translate.c:    t_gen_mov_preg_TN(dc, dc->op2, t[0]);
target-cris/translate.c:    if (dc->op2 == PR_CCS) {
target-cris/translate.c:        dc->flags_uptodate = 1;
target-cris/translate.c:    LOG_DIS("move $p%u, $r%u\n", dc->op2, dc->op1);
target-cris/translate.c:    if (dc->op2 == PR_CCS) {
target-cris/translate.c:    if (dc->op2 == PR_DZ) {
target-cris/translate.c:        tcg_gen_movi_tl(cpu_R[dc->op1], 0);
target-cris/translate.c:        t_gen_mov_TN_preg(t0, dc->op2);
target-cris/translate.c:                cpu_R[dc->op1], cpu_R[dc->op1], t0,
target-cris/translate.c:                preg_sizes[dc->op2]);
target-cris/translate.c:            dc->op1, dc->postinc ? "+]" : "]",
target-cris/translate.c:                    dc->op2);
target-cris/translate.c:        insn_len = dec_prep_move_m(env, dc, 0, 4, cpu_R[dc->op2]);
target-cris/translate.c:        cris_update_result(dc, cpu_R[dc->op2]);
target-cris/translate.c:                cpu_R[dc->op2], cpu_R[dc->op2], t0, memsize);
target-cris/translate.c:            dc->op1, dc->postinc ? "+]" : "]",
target-cris/translate.c:            dc->op2);
target-cris/translate.c:            cpu_R[dc->op2], cpu_R[dc->op2], t[1], 4);
target-cris/translate.c:            dc->op1, dc->postinc ? "+]" : "]",
target-cris/translate.c:            dc->op2);
target-cris/translate.c:            cpu_R[dc->op2], cpu_R[dc->op2], t[1], 4);
target-cris/translate.c:            dc->op1, dc->postinc ? "+]" : "]",
target-cris/translate.c:            dc->op2);
target-cris/translate.c:    cris_alu(dc, CC_OP_ADD, cpu_R[dc->op2], cpu_R[dc->op2], t[1], 4);
target-cris/translate.c:            dc->op1, dc->postinc ? "+]" : "]",
target-cris/translate.c:            dc->op2);
target-cris/translate.c:    cris_alu(dc, CC_OP_SUB, cpu_R[dc->op2], cpu_R[dc->op2], t[1], 4);
target-cris/translate.c:            dc->op1, dc->postinc ? "+]" : "]",
target-cris/translate.c:            dc->op2);
target-cris/translate.c:    cris_alu(dc, CC_OP_SUB, cpu_R[dc->op2], cpu_R[dc->op2], t[1], 4);
target-cris/translate.c:            dc->op1, dc->postinc ? "+]" : "]",
target-cris/translate.c:            dc->op2);
target-cris/translate.c:    cris_alu(dc, CC_OP_MOVE, cpu_R[dc->op2], cpu_R[dc->op2], t[1], 4);
target-cris/translate.c:            dc->op1, dc->postinc ? "+]" : "]",
target-cris/translate.c:            dc->op2);
target-cris/translate.c:    cris_alu(dc, CC_OP_CMP, cpu_R[dc->op2], cpu_R[dc->op2], t[1], 4);
target-cris/translate.c:            dc->op1, dc->postinc ? "+]" : "]",
target-cris/translate.c:            dc->op2);
target-cris/translate.c:            cpu_R[dc->op2], cpu_R[dc->op2], t[1],
target-cris/translate.c:            dc->op1, dc->postinc ? "+]" : "]",
target-cris/translate.c:            dc->op2);
target-cris/translate.c:            cpu_R[dc->op2], cpu_R[dc->op2], t[1],
target-cris/translate.c:            dc->op1, dc->postinc ? "+]" : "]",
target-cris/translate.c:            dc->op2);
target-cris/translate.c:         cpu_R[dc->op2], t[1], tcg_const_tl(0), memsize_zz(dc));
target-cris/translate.c:            dc->op1, dc->postinc ? "+]" : "]",
target-cris/translate.c:            dc->op2);
target-cris/translate.c:    cris_alu(dc, CC_OP_AND, cpu_R[dc->op2], t[0], t[1], memsize_zz(dc));
target-cris/translate.c:            dc->op1, dc->postinc ? "+]" : "]",
target-cris/translate.c:            dc->op2);
target-cris/translate.c:         cpu_R[dc->op2], t[0], t[1], memsize_zz(dc));
target-cris/translate.c:            dc->op1, dc->postinc ? "+]" : "]",
target-cris/translate.c:            dc->op2);
target-cris/translate.c:            dc->op1, dc->postinc ? "+]" : "]",
target-cris/translate.c:            dc->op2);
target-cris/translate.c:    cris_alu(dc, CC_OP_BOUND, cpu_R[dc->op2], l[0], l[1], 4);
target-cris/translate.c:            dc->op1, dc->postinc ? "+]" : "]",
target-cris/translate.c:            dc->op2);
target-cris/translate.c:    dc->flagx_known = 1;
target-cris/translate.c:    dc->flags_x = X_FLAG;
target-cris/translate.c:    cris_alu(dc, CC_OP_ADDC, cpu_R[dc->op2], t[0], t[1], 4);
target-cris/translate.c:            dc->op1, dc->postinc ? "+]" : "]",
target-cris/translate.c:            dc->op2, dc->ir, dc->zzsize);
target-cris/translate.c:    cris_alu(dc, CC_OP_SUB, cpu_R[dc->op2], t[0], t[1], memsize);
target-cris/translate.c:            dc->op1, dc->postinc ? "+]" : "]",
target-cris/translate.c:            dc->op2, dc->pc);
target-cris/translate.c:            cpu_R[dc->op2], t[0], t[1], memsize_zz(dc));
target-cris/translate.c:            dc->op1,
target-cris/translate.c:            dc->postinc ? "+]" : "]",
target-cris/translate.c:            dc->op2);
target-cris/translate.c:    if (dc->op2 == PR_CCS) {
target-cris/translate.c:        if (dc->tb_flags & U_FLAG) {
target-cris/translate.c:    t_gen_mov_preg_TN(dc, dc->op2, t[1]);
target-cris/translate.c:    memsize = preg_sizes[dc->op2];
target-cris/translate.c:            dc->op2, dc->op1, dc->postinc ? "+]" : "]");
target-cris/translate.c:    if (dc->op2 == PR_CCS) {
target-cris/translate.c:    t_gen_mov_TN_preg(t0, dc->op2);
target-cris/translate.c:    gen_store(dc, cpu_R[dc->op1], t0, memsize);
target-cris/translate.c:    if (dc->postinc) {
target-cris/translate.c:        tcg_gen_addi_tl(cpu_R[dc->op1], cpu_R[dc->op1], memsize);
target-cris/translate.c:    int nr = dc->op2 + 1;
target-cris/translate.c:    LOG_DIS("movem [$r%u%s, $r%u\n", dc->op1,
target-cris/translate.c:            dc->postinc ? "+]" : "]", dc->op2);
target-cris/translate.c:        tcg_gen_addi_tl(addr, cpu_R[dc->op1], i * 8);
target-cris/translate.c:        tcg_gen_addi_tl(addr, cpu_R[dc->op1], i * 8);
target-cris/translate.c:        tcg_gen_mov_tl(cpu_R[dc->op2], tmp32);
target-cris/translate.c:    if (dc->postinc) {
target-cris/translate.c:        tcg_gen_addi_tl(cpu_R[dc->op1], cpu_R[dc->op1], nr * 4);
target-cris/translate.c:    LOG_DIS("movem $r%u, [$r%u%s\n", dc->op2, dc->op1,
target-cris/translate.c:            dc->postinc ? "+]" : "]");
target-cris/translate.c:    tcg_gen_mov_tl(addr, cpu_R[dc->op1]);
target-cris/translate.c:    for (i = 0; i <= dc->op2; i++) {
target-cris/translate.c:    if (dc->postinc) {
target-cris/translate.c:        tcg_gen_mov_tl(cpu_R[dc->op1], addr);
target-cris/translate.c:            memsize_char(memsize), dc->op2, dc->op1);
target-cris/translate.c:    gen_store(dc, cpu_R[dc->op1], cpu_R[dc->op2], memsize);
target-cris/translate.c:    if (dc->postinc) {
target-cris/translate.c:        tcg_gen_addi_tl(cpu_R[dc->op1], cpu_R[dc->op1], memsize);
target-cris/translate.c:            dc->pc + dc->op1*2, dc->op2);
target-cris/translate.c:    tcg_gen_movi_tl(cpu_R[dc->op2], dc->pc + dc->op1 * 2);
target-cris/translate.c:    rd = dc->op2;
target-cris/translate.c:    imm = cris_fetch(env, dc, dc->pc + 2, 4, 0);
target-cris/translate.c:    LOG_DIS("lapc 0x%x, $r%u\n", imm + dc->pc, dc->op2);
target-cris/translate.c:    pc = dc->pc;
target-cris/translate.c:    LOG_DIS("jump $p%u\n", dc->op2);
target-cris/translate.c:    if (dc->op2 == PR_CCS) {
target-cris/translate.c:    t_gen_mov_TN_preg(env_btarget, dc->op2);
target-cris/translate.c:    LOG_DIS("jas $r%u, $p%u\n", dc->op1, dc->op2);
target-cris/translate.c:    tcg_gen_mov_tl(env_btarget, cpu_R[dc->op1]);
target-cris/translate.c:    if (dc->op2 > 15) {
target-cris/translate.c:    t_gen_mov_preg_TN(dc, dc->op2, tcg_const_tl(dc->pc + 4));
target-cris/translate.c:    imm = cris_fetch(env, dc, dc->pc + 2, 4, 0);
target-cris/translate.c:    t_gen_mov_preg_TN(dc, dc->op2, tcg_const_tl(dc->pc + 8));
target-cris/translate.c:    dc->jmp_pc = imm;
target-cris/translate.c:    imm = cris_fetch(env, dc, dc->pc + 2, 4, 0);
target-cris/translate.c:    t_gen_mov_preg_TN(dc, dc->op2, tcg_const_tl(dc->pc + 8 + 4));
target-cris/translate.c:    dc->jmp_pc = imm;
target-cris/translate.c:    LOG_DIS("jasc_r $r%u, $p%u\n", dc->op1, dc->op2);
target-cris/translate.c:    tcg_gen_mov_tl(env_btarget, cpu_R[dc->op1]);
target-cris/translate.c:    t_gen_mov_preg_TN(dc, dc->op2, tcg_const_tl(dc->pc + 4 + 4));
target-cris/translate.c:    uint32_t cond = dc->op2;
target-cris/translate.c:    offset = cris_fetch(env, dc, dc->pc + 2, 2, 1);
target-cris/translate.c:            dc->pc, dc->pc + offset);
target-cris/translate.c:    simm = cris_fetch(env, dc, dc->pc + 2, 4, 0);
target-cris/translate.c:    LOG_DIS("bas 0x%x, $p%u\n", dc->pc + simm, dc->op2);
target-cris/translate.c:    t_gen_mov_preg_TN(dc, dc->op2, tcg_const_tl(dc->pc + 8));
target-cris/translate.c:    dc->jmp_pc = dc->pc + simm;
target-cris/translate.c:    simm = cris_fetch(env, dc, dc->pc + 2, 4, 0);
target-cris/translate.c:    LOG_DIS("basc 0x%x, $p%u\n", dc->pc + simm, dc->op2);
target-cris/translate.c:    t_gen_mov_preg_TN(dc, dc->op2, tcg_const_tl(dc->pc + 12));
target-cris/translate.c:    dc->jmp_pc = dc->pc + simm;
target-cris/translate.c:    if (dc->op2 == 15) {
target-cris/translate.c:        tcg_gen_movi_tl(env_pc, dc->pc + 2);
target-cris/translate.c:    switch (dc->op2 & 7) {
target-cris/translate.c:        dc->is_jmp = DISAS_UPDATE;
target-cris/translate.c:        dc->is_jmp = DISAS_UPDATE;
target-cris/translate.c:        LOG_DIS("break %d\n", dc->op1);
target-cris/translate.c:        tcg_gen_movi_tl(env_pc, dc->pc + 2);
target-cris/translate.c:                tcg_const_tl(dc->op1 + 16));
target-cris/translate.c:        dc->is_jmp = DISAS_UPDATE;
target-cris/translate.c:        printf("op2=%x\n", dc->op2);
target-cris/translate.c:        dc->pc, dc->opcode, dc->op1, dc->op2);
target-cris/translate.c:        tcg_gen_debug_insn_start(dc->pc);
target-cris/translate.c:        dc->ir = cris_fetch(env, dc, dc->pc, 2, 0);
target-cris/translate.c:    dc->opcode   = EXTRACT_FIELD(dc->ir, 4, 11);
target-cris/translate.c:    dc->op1      = EXTRACT_FIELD(dc->ir, 0, 3);
target-cris/translate.c:    dc->op2      = EXTRACT_FIELD(dc->ir, 12, 15);
target-cris/translate.c:    dc->zsize    = EXTRACT_FIELD(dc->ir, 4, 4);
target-cris/translate.c:    dc->zzsize   = EXTRACT_FIELD(dc->ir, 4, 5);
target-cris/translate.c:    dc->postinc  = EXTRACT_FIELD(dc->ir, 10, 10);
target-cris/translate.c:        if ((dc->opcode & decinfo[i].mask) == decinfo[i].bits) {
target-cris/translate.c:    if (dc->tb_flags & S_FLAG) {
target-cris/translate.c:        tcg_gen_brcondi_tl(TCG_COND_NE, cpu_PR[PR_SPC], dc->pc, l1);
target-cris/translate.c:        tcg_gen_movi_tl(env_pc, dc->pc + insn_len);
target-cris/translate.c:        tcg_gen_movi_tl(cpu_PR[PR_SPC], dc->pc + insn_len);
target-cris/translate.c:            if (bp->pc == dc->pc) {
target-cris/translate.c:                tcg_gen_movi_tl(env_pc, dc->pc);
target-cris/translate.c:                dc->is_jmp = DISAS_UPDATE;
target-cris/translate.c:        dc->decoder = crisv32_decoder;
target-cris/translate.c:        dc->clear_locked_irq = 0;
target-cris/translate.c:        dc->decoder = crisv10_decoder;
target-cris/translate.c:        dc->clear_locked_irq = 1;
target-cris/translate.c:    dc->cpu = cpu;
target-cris/translate.c:    dc->tb = tb;
target-cris/translate.c:    dc->is_jmp = DISAS_NEXT;
target-cris/translate.c:    dc->ppc = pc_start;
target-cris/translate.c:    dc->pc = pc_start;
target-cris/translate.c:    dc->singlestep_enabled = cs->singlestep_enabled;
target-cris/translate.c:    dc->flags_uptodate = 1;
target-cris/translate.c:    dc->flagx_known = 1;
target-cris/translate.c:    dc->flags_x = tb->flags & X_FLAG;
target-cris/translate.c:    dc->cc_x_uptodate = 0;
target-cris/translate.c:    dc->cc_mask = 0;
target-cris/translate.c:    dc->update_cc = 0;
target-cris/translate.c:    dc->clear_prefix = 0;
target-cris/translate.c:    dc->cc_size_uptodate = -1;
target-cris/translate.c:    dc->tb_flags = tb->flags & (S_FLAG | P_FLAG | U_FLAG \
target-cris/translate.c:    dc->delayed_branch = !!(tb->flags & 7);
target-cris/translate.c:    if (dc->delayed_branch) {
target-cris/translate.c:        dc->jmp = JMP_INDIRECT;
target-cris/translate.c:        dc->jmp = JMP_NOJMP;
target-cris/translate.c:    dc->cpustate_changed = 0;
target-cris/translate.c:                search_pc, dc->pc, dc->ppc,
target-cris/translate.c:            if (dc->delayed_branch == 1) {
target-cris/translate.c:                tcg_ctx.gen_opc_pc[lj] = dc->ppc | 1;
target-cris/translate.c:                tcg_ctx.gen_opc_pc[lj] = dc->pc;
target-cris/translate.c:        LOG_DIS("%8.8x:\t", dc->pc);
target-cris/translate.c:        dc->clear_x = 1;
target-cris/translate.c:        insn_len = dc->decoder(env, dc);
target-cris/translate.c:        dc->ppc = dc->pc;
target-cris/translate.c:        dc->pc += insn_len;
target-cris/translate.c:        if (dc->clear_x) {
target-cris/translate.c:        if (dc->delayed_branch) {
target-cris/translate.c:            dc->delayed_branch--;
target-cris/translate.c:            if (dc->delayed_branch == 0) {
target-cris/translate.c:                if (dc->cpustate_changed || !dc->flagx_known
target-cris/translate.c:                    || (dc->flags_x != (tb->flags & X_FLAG))) {
target-cris/translate.c:                if (dc->clear_locked_irq) {
target-cris/translate.c:                    dc->clear_locked_irq = 0;
target-cris/translate.c:                if (dc->jmp == JMP_DIRECT_CC) {
target-cris/translate.c:                    gen_goto_tb(dc, 1, dc->jmp_pc);
target-cris/translate.c:                    gen_goto_tb(dc, 0, dc->pc);
target-cris/translate.c:                    dc->is_jmp = DISAS_TB_JUMP;
target-cris/translate.c:                    dc->jmp = JMP_NOJMP;
target-cris/translate.c:                } else if (dc->jmp == JMP_DIRECT) {
target-cris/translate.c:                    gen_goto_tb(dc, 0, dc->jmp_pc);
target-cris/translate.c:                    dc->is_jmp = DISAS_TB_JUMP;
target-cris/translate.c:                    dc->jmp = JMP_NOJMP;
target-cris/translate.c:                    t_gen_cc_jmp(env_btarget, tcg_const_tl(dc->pc));
target-cris/translate.c:                    dc->is_jmp = DISAS_JUMP;
target-cris/translate.c:    } while (!dc->is_jmp && !dc->cpustate_changed
target-cris/translate.c:            && (dc->pc < next_page_start)
target-cris/translate.c:    if (dc->clear_locked_irq) {
target-cris/translate.c:    npc = dc->pc;
target-cris/translate.c:    if (dc->is_jmp == DISAS_NEXT
target-cris/translate.c:        && (dc->cpustate_changed || !dc->flagx_known
target-cris/translate.c:        || (dc->flags_x != (tb->flags & X_FLAG)))) {
target-cris/translate.c:        dc->is_jmp = DISAS_UPDATE;
target-cris/translate.c:    if (dc->delayed_branch == 1) {
target-cris/translate.c:        t_gen_mov_env_TN(dslot, tcg_const_tl(dc->pc - dc->ppc));
target-cris/translate.c:        if (dc->is_jmp == DISAS_NEXT) {
target-cris/translate.c:        switch (dc->is_jmp) {
target-cris/translate.c:        tb->size = dc->pc - pc_start;
target-cris/translate.c:        log_target_disas(env, pc_start, dc->pc - pc_start,
target-cris/translate.c:            dc->pc - pc_start, tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf);
target-cris/cpu.c:    ccc->parent_realize = dc->realize;
target-cris/cpu.c:    dc->realize = cris_cpu_realizefn;
target-cris/translate_v10.c:    qemu_log("illegal insn at pc=%x\n", dc->pc);
target-cris/translate_v10.c:    dc->postinc = 0;
target-cris/translate_v10.c:    int mem_index = cpu_mmu_index(&dc->cpu->env);
target-cris/translate_v10.c:    if (dc->delayed_branch == 1) {
target-cris/translate_v10.c:    if (dc->flagx_known && dc->flags_x) {
target-cris/translate_v10.c:    dc->clear_prefix = 0;
target-cris/translate_v10.c:    dc->tb_flags |= PFIX_FLAG;
target-cris/translate_v10.c:    dc->clear_x = 0;
target-cris/translate_v10.c:    if (dc->tb_flags & PFIX_FLAG) {
target-cris/translate_v10.c:        tcg_gen_mov_tl(addr, cpu_R[dc->src]);
target-cris/translate_v10.c:    if (dc->tb_flags & PFIX_FLAG) {
target-cris/translate_v10.c:        if (dc->mode == CRISV10_MODE_AUTOINC) {
target-cris/translate_v10.c:            tcg_gen_mov_tl(cpu_R[dc->src], cpu_PR[PR_PREFIX]);
target-cris/translate_v10.c:        if (dc->mode == CRISV10_MODE_AUTOINC) {
target-cris/translate_v10.c:            if (dc->src == 15) {
target-cris/translate_v10.c:                tcg_gen_addi_tl(cpu_R[dc->src], cpu_R[dc->src], size);
target-cris/translate_v10.c:    rs = dc->src;
target-cris/translate_v10.c:    is_imm = rs == 15 && !(dc->tb_flags & PFIX_FLAG);
target-cris/translate_v10.c:             rs, dc->dst, is_imm, dc->mode, dc->tb_flags & PFIX_FLAG);
target-cris/translate_v10.c:                    imm = cpu_ldsb_code(env, dc->pc + 2);
target-cris/translate_v10.c:                    imm = cpu_ldsw_code(env, dc->pc + 2);
target-cris/translate_v10.c:                    imm = cpu_ldub_code(env, dc->pc + 2);
target-cris/translate_v10.c:                    imm = cpu_lduw_code(env, dc->pc + 2);
target-cris/translate_v10.c:            imm = cpu_ldl_code(env, dc->pc + 2);
target-cris/translate_v10.c:        if (dc->mode == CRISV10_MODE_AUTOINC) {
target-cris/translate_v10.c:    if (dc->mode == CRISV10_MODE_INDIRECT && (dc->tb_flags & PFIX_FLAG)) {
target-cris/translate_v10.c:        dc->dst = dc->src;
target-cris/translate_v10.c:    imm = dc->ir & ((1 << 6) - 1);
target-cris/translate_v10.c:    switch (dc->opcode) {
target-cris/translate_v10.c:            simm = (int8_t)dc->ir;
target-cris/translate_v10.c:            LOG_DIS("bdap %d $r%d\n", simm, dc->dst);
target-cris/translate_v10.c:                     dc->pc, dc->mode, dc->opcode, dc->src, dc->dst);
target-cris/translate_v10.c:            if (dc->dst == 15) {
target-cris/translate_v10.c:                tcg_gen_movi_tl(cpu_PR[PR_PREFIX], dc->pc + 2 + simm);
target-cris/translate_v10.c:                tcg_gen_addi_tl(cpu_PR[PR_PREFIX], cpu_R[dc->dst], simm);
target-cris/translate_v10.c:            LOG_DIS("moveq %d, $r%d\n", simm, dc->dst);
target-cris/translate_v10.c:            cris_alu(dc, CC_OP_MOVE, cpu_R[dc->dst],
target-cris/translate_v10.c:                     cpu_R[dc->dst], tcg_const_tl(simm), 4);
target-cris/translate_v10.c:            LOG_DIS("cmpq %d, $r%d\n", simm, dc->dst);
target-cris/translate_v10.c:            cris_alu(dc, CC_OP_CMP, cpu_R[dc->dst],
target-cris/translate_v10.c:                     cpu_R[dc->dst], tcg_const_tl(simm), 4);
target-cris/translate_v10.c:            LOG_DIS("addq %d, $r%d\n", imm, dc->dst);
target-cris/translate_v10.c:            cris_alu(dc, CC_OP_ADD, cpu_R[dc->dst],
target-cris/translate_v10.c:                     cpu_R[dc->dst], tcg_const_tl(imm), 4);
target-cris/translate_v10.c:            LOG_DIS("andq %d, $r%d\n", simm, dc->dst);
target-cris/translate_v10.c:            cris_alu(dc, CC_OP_AND, cpu_R[dc->dst],
target-cris/translate_v10.c:                     cpu_R[dc->dst], tcg_const_tl(simm), 4);
target-cris/translate_v10.c:            LOG_DIS("ashq %d, $r%d\n", simm, dc->dst);
target-cris/translate_v10.c:                cris_alu(dc, CC_OP_ASR, cpu_R[dc->dst],
target-cris/translate_v10.c:                          cpu_R[dc->dst], tcg_const_tl(imm), 4);
target-cris/translate_v10.c:                gen_helper_btst(cpu_PR[PR_CCS], cpu_env, cpu_R[dc->dst],
target-cris/translate_v10.c:            LOG_DIS("lshq %d, $r%d\n", simm, dc->dst);
target-cris/translate_v10.c:            cris_alu(dc, op, cpu_R[dc->dst],
target-cris/translate_v10.c:                     cpu_R[dc->dst], tcg_const_tl(imm), 4);
target-cris/translate_v10.c:            LOG_DIS("subq %d, $r%d\n", imm, dc->dst);
target-cris/translate_v10.c:            cris_alu(dc, CC_OP_SUB, cpu_R[dc->dst],
target-cris/translate_v10.c:                     cpu_R[dc->dst], tcg_const_tl(imm), 4);
target-cris/translate_v10.c:            LOG_DIS("andq %d, $r%d\n", simm, dc->dst);
target-cris/translate_v10.c:            cris_alu(dc, CC_OP_OR, cpu_R[dc->dst],
target-cris/translate_v10.c:                     cpu_R[dc->dst], tcg_const_tl(simm), 4);
target-cris/translate_v10.c:            imm = dc->ir & 0xff;
target-cris/translate_v10.c:            LOG_DIS("b%s %d\n", cc_name(dc->cond), imm);
target-cris/translate_v10.c:            cris_prepare_cc_branch(dc, imm, dc->cond); 
target-cris/translate_v10.c:                     dc->pc, dc->mode, dc->opcode, dc->src, dc->dst);
target-cris/translate_v10.c:            cpu_abort(CPU(dc->cpu), "Unhandled quickimm\n");
target-cris/translate_v10.c:    unsigned int set = ~dc->opcode & 1;
target-cris/translate_v10.c:    flags = EXTRACT_FIELD(dc->ir, 0, 3)
target-cris/translate_v10.c:            | (EXTRACT_FIELD(dc->ir, 12, 15) << 4);
target-cris/translate_v10.c:        dc->flagx_known = 1;
target-cris/translate_v10.c:            dc->flags_x = X_FLAG;
target-cris/translate_v10.c:            dc->flags_x = 0;
target-cris/translate_v10.c:    tcg_gen_movi_tl(cc_op, dc->cc_op);
target-cris/translate_v10.c:    dc->flags_uptodate = 1;
target-cris/translate_v10.c:    dc->clear_x = 0;
target-cris/translate_v10.c:                        t[0], t[1], cpu_R[dc->dst], cpu_R[dc->src]);
target-cris/translate_v10.c:    assert(dc->dst != 15);
target-cris/translate_v10.c:    cris_alu(dc, op, cpu_R[dc->dst], t[0], t[1], size);
target-cris/translate_v10.c:    t_gen_zext(t, cpu_R[dc->src], size);
target-cris/translate_v10.c:    cris_alu(dc, CC_OP_BOUND, cpu_R[dc->dst], cpu_R[dc->dst], t, 4);
target-cris/translate_v10.c:                        t[0], t[1], cpu_R[dc->dst], cpu_R[dc->src]);
target-cris/translate_v10.c:    cris_alu(dc, op, cpu_R[dc->dst], t[0], t[1], 4);
target-cris/translate_v10.c:    int size = (dc->size & 1) + 1;
target-cris/translate_v10.c:    LOG_DIS("movx.%d $r%d, $r%d\n", size, dc->src, dc->dst);
target-cris/translate_v10.c:    if (dc->ir & 32)
target-cris/translate_v10.c:        t_gen_sext(t, cpu_R[dc->src], size);
target-cris/translate_v10.c:        t_gen_zext(t, cpu_R[dc->src], size);
target-cris/translate_v10.c:    cris_alu(dc, CC_OP_MOVE, cpu_R[dc->dst], cpu_R[dc->dst], t, 4);
target-cris/translate_v10.c:    int size = (dc->size & 1) + 1;
target-cris/translate_v10.c:    LOG_DIS("movx.%d $r%d, $r%d\n", size, dc->src, dc->dst);
target-cris/translate_v10.c:    if (dc->ir & 32)
target-cris/translate_v10.c:        t_gen_sext(t, cpu_R[dc->src], size);
target-cris/translate_v10.c:        t_gen_zext(t, cpu_R[dc->src], size);
target-cris/translate_v10.c:    cris_alu(dc, op, cpu_R[dc->dst], cpu_R[dc->dst], t, 4);
target-cris/translate_v10.c:    LOG_DIS("move p%d r%d sz=%d\n", dc->dst, dc->src, preg_sizes_v10[dc->dst]);
target-cris/translate_v10.c:    if (dc->src == 15) {
target-cris/translate_v10.c:        tcg_gen_mov_tl(env_btarget, cpu_PR[dc->dst]);
target-cris/translate_v10.c:    if (dc->dst == PR_CCS) {
target-cris/translate_v10.c:    cris_alu(dc, CC_OP_MOVE, cpu_R[dc->src],
target-cris/translate_v10.c:                 cpu_R[dc->src], cpu_PR[dc->dst], preg_sizes_v10[dc->dst]);
target-cris/translate_v10.c:    LOG_DIS("abs $r%u, $r%u\n", dc->src, dc->dst);
target-cris/translate_v10.c:    assert(dc->dst != 15);
target-cris/translate_v10.c:    tcg_gen_sari_tl(t0, cpu_R[dc->src], 31);
target-cris/translate_v10.c:    tcg_gen_xor_tl(cpu_R[dc->dst], cpu_R[dc->src], t0);
target-cris/translate_v10.c:    tcg_gen_sub_tl(t0, cpu_R[dc->dst], t0);
target-cris/translate_v10.c:    cris_alu(dc, CC_OP_MOVE, cpu_R[dc->dst], cpu_R[dc->dst], t0, 4);
target-cris/translate_v10.c:    LOG_DIS("not $r%d, $r%d\n", dc->src, dc->dst);
target-cris/translate_v10.c:    t_gen_mov_TN_reg(t0, dc->src);
target-cris/translate_v10.c:    if (dc->dst & 8)
target-cris/translate_v10.c:    if (dc->dst & 4)
target-cris/translate_v10.c:    if (dc->dst & 2)
target-cris/translate_v10.c:    if (dc->dst & 1)
target-cris/translate_v10.c:    cris_alu(dc, CC_OP_MOVE, cpu_R[dc->src], cpu_R[dc->src], t0, 4);
target-cris/translate_v10.c:    int cond = dc->dst;
target-cris/translate_v10.c:    LOG_DIS("s%s $r%u\n", cc_name(cond), dc->src);
target-cris/translate_v10.c:        gen_tst_cc (dc, cpu_R[dc->src], cond);
target-cris/translate_v10.c:        tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_R[dc->src], 0, l1);
target-cris/translate_v10.c:        tcg_gen_movi_tl(cpu_R[dc->src], 1);
target-cris/translate_v10.c:        tcg_gen_movi_tl(cpu_R[dc->src], 1);
target-cris/translate_v10.c:    unsigned int size = dec10_size(dc->size);
target-cris/translate_v10.c:    if (dc->size != 3) {
target-cris/translate_v10.c:        switch (dc->opcode) {
target-cris/translate_v10.c:                LOG_DIS("move.%d $r%d, $r%d\n", dc->size, dc->src, dc->dst);
target-cris/translate_v10.c:                if (dc->dst == 15) {
target-cris/translate_v10.c:                    tcg_gen_mov_tl(env_btarget, cpu_R[dc->dst]);
target-cris/translate_v10.c:                    dc->delayed_branch = 1;
target-cris/translate_v10.c:                LOG_DIS("add $r%d, $r%d sz=%d\n", dc->src, dc->dst, size);
target-cris/translate_v10.c:                LOG_DIS("sub $r%d, $r%d sz=%d\n", dc->src, dc->dst, size);
target-cris/translate_v10.c:                LOG_DIS("cmp $r%d, $r%d sz=%d\n", dc->src, dc->dst, size);
target-cris/translate_v10.c:                LOG_DIS("bound $r%d, $r%d sz=%d\n", dc->src, dc->dst, size);
target-cris/translate_v10.c:                LOG_DIS("and $r%d, $r%d sz=%d\n", dc->src, dc->dst, size);
target-cris/translate_v10.c:                if (dc->src == 15) {
target-cris/translate_v10.c:                LOG_DIS("addi r%d r%d size=%d\n", dc->src, dc->dst, dc->size);
target-cris/translate_v10.c:                tcg_gen_shli_tl(t, cpu_R[dc->dst], dc->size & 3);
target-cris/translate_v10.c:                tcg_gen_add_tl(cpu_R[dc->src], cpu_R[dc->src], t);
target-cris/translate_v10.c:                LOG_DIS("lsl $r%d, $r%d sz=%d\n", dc->src, dc->dst, size);
target-cris/translate_v10.c:                LOG_DIS("lsr $r%d, $r%d sz=%d\n", dc->src, dc->dst, size);
target-cris/translate_v10.c:                LOG_DIS("asr $r%d, $r%d sz=%d\n", dc->src, dc->dst, size);
target-cris/translate_v10.c:                LOG_DIS("or $r%d, $r%d sz=%d\n", dc->src, dc->dst, size);
target-cris/translate_v10.c:                LOG_DIS("neg $r%d, $r%d sz=%d\n", dc->src, dc->dst, size);
target-cris/translate_v10.c:                LOG_DIS("BIAP pc=%x reg %d r%d r%d size=%d\n", dc->pc,
target-cris/translate_v10.c:                         dc->opcode, dc->src, dc->dst, size);
target-cris/translate_v10.c:                        cpu_abort(CPU(dc->cpu), "Unhandled BIAP");
target-cris/translate_v10.c:                tcg_gen_shli_tl(t, cpu_R[dc->dst], tmp);
target-cris/translate_v10.c:                if (dc->src == 15) {
target-cris/translate_v10.c:                    tcg_gen_addi_tl(cpu_PR[PR_PREFIX], t, ((dc->pc +2)| 1) + 1);
target-cris/translate_v10.c:                    tcg_gen_add_tl(cpu_PR[PR_PREFIX], cpu_R[dc->src], t);
target-cris/translate_v10.c:                LOG_DIS("pc=%x reg %d r%d r%d\n", dc->pc,
target-cris/translate_v10.c:                         dc->opcode, dc->src, dc->dst);
target-cris/translate_v10.c:                cpu_abort(CPU(dc->cpu), "Unhandled opcode");
target-cris/translate_v10.c:        switch (dc->opcode) {
target-cris/translate_v10.c:                LOG_DIS("move r%d p%d\n", dc->src, dc->dst);
target-cris/translate_v10.c:                if (dc->src != 11) /* fast for srp.  */
target-cris/translate_v10.c:                    dc->cpustate_changed = 1;
target-cris/translate_v10.c:                t_gen_mov_preg_TN(dc, dc->dst, cpu_R[dc->src]);
target-cris/translate_v10.c:                LOG_DIS("lz $r%d, $r%d sz=%d\n", dc->src, dc->dst, size);
target-cris/translate_v10.c:                LOG_DIS("xor $r%d, $r%d sz=%d\n", dc->src, dc->dst, size);
target-cris/translate_v10.c:                LOG_DIS("btst $r%d, $r%d sz=%d\n", dc->src, dc->dst, size);
target-cris/translate_v10.c:                gen_helper_btst(cpu_PR[PR_CCS], cpu_env, cpu_R[dc->dst],
target-cris/translate_v10.c:                           cpu_R[dc->src], cpu_PR[PR_CCS]);
target-cris/translate_v10.c:                LOG_DIS("dstep $r%d, $r%d sz=%d\n", dc->src, dc->dst, size);
target-cris/translate_v10.c:                cris_alu(dc, CC_OP_DSTEP, cpu_R[dc->dst],
target-cris/translate_v10.c:                            cpu_R[dc->dst], cpu_R[dc->src], 4);
target-cris/translate_v10.c:                LOG_DIS("mstep $r%d, $r%d sz=%d\n", dc->src, dc->dst, size);
target-cris/translate_v10.c:                cris_alu(dc, CC_OP_MSTEP, cpu_R[dc->dst],
target-cris/translate_v10.c:                            cpu_R[dc->dst], cpu_R[dc->src], 4);
target-cris/translate_v10.c:                LOG_DIS("pc=%x reg %d r%d r%d\n", dc->pc,
target-cris/translate_v10.c:                         dc->opcode, dc->src, dc->dst);
target-cris/translate_v10.c:                cpu_abort(CPU(dc->cpu), "Unhandled opcode");
target-cris/translate_v10.c:             size, dc->src, dc->dst);
target-cris/translate_v10.c:    cris_alu(dc, CC_OP_MOVE, cpu_R[dc->dst], cpu_R[dc->dst], t, size);
target-cris/translate_v10.c:    if (dc->dst == 15) {
target-cris/translate_v10.c:        tcg_gen_mov_tl(env_btarget, cpu_R[dc->dst]);
target-cris/translate_v10.c:        dc->delayed_branch = 1;
target-cris/translate_v10.c:    LOG_DIS("move.%d $r%d, [$r%d]\n", dc->size, dc->src, dc->dst);
target-cris/translate_v10.c:    gen_store_v10(dc, addr, cpu_R[dc->dst], size);
target-cris/translate_v10.c:    unsigned int insn_len = 2, rd = dc->dst;
target-cris/translate_v10.c:    LOG_DIS("move.%d $p%d, [$r%d]\n", dc->size, dc->dst, dc->src);
target-cris/translate_v10.c:        dc->delayed_branch = 1;
target-cris/translate_v10.c:    dc->cpustate_changed = 1;
target-cris/translate_v10.c:    unsigned int insn_len = 2, size = preg_sizes_v10[dc->dst];
target-cris/translate_v10.c:    LOG_DIS("move.%d $p%d, [$r%d]\n", dc->size, dc->dst, dc->src);
target-cris/translate_v10.c:    if (dc->dst == PR_CCS) {
target-cris/translate_v10.c:        gen_store_v10(dc, addr, cpu_PR[dc->dst], size);
target-cris/translate_v10.c:    int i, pfix = dc->tb_flags & PFIX_FLAG;
target-cris/translate_v10.c:              dc->dst, dc->src, dc->postinc, dc->ir);
target-cris/translate_v10.c:    for (i = dc->dst; i >= 0; i--) {
target-cris/translate_v10.c:        if ((pfix && dc->mode == CRISV10_MODE_AUTOINC) && dc->src == i) {
target-cris/translate_v10.c:    if (pfix && dc->mode == CRISV10_MODE_AUTOINC) {
target-cris/translate_v10.c:        tcg_gen_mov_tl(cpu_R[dc->src], t0);
target-cris/translate_v10.c:    if (!pfix && dc->mode == CRISV10_MODE_AUTOINC) {
target-cris/translate_v10.c:        tcg_gen_mov_tl(cpu_R[dc->src], addr);
target-cris/translate_v10.c:    int i, pfix = dc->tb_flags & PFIX_FLAG;
target-cris/translate_v10.c:              dc->src, dc->dst, dc->postinc, dc->ir);
target-cris/translate_v10.c:    for (i = dc->dst; i >= 0; i--) {
target-cris/translate_v10.c:    if (pfix && dc->mode == CRISV10_MODE_AUTOINC) {
target-cris/translate_v10.c:        tcg_gen_mov_tl(cpu_R[dc->src], t0);
target-cris/translate_v10.c:    if (!pfix && dc->mode == CRISV10_MODE_AUTOINC) {
target-cris/translate_v10.c:        tcg_gen_mov_tl(cpu_R[dc->src], addr);
target-cris/translate_v10.c:    int rd = dc->dst;
target-cris/translate_v10.c:    cris_alu(dc, op, cpu_R[dc->dst], cpu_R[rd], t[0], size);
target-cris/translate_v10.c:    if (dc->dst == 15) {
target-cris/translate_v10.c:        tcg_gen_mov_tl(env_btarget, cpu_R[dc->dst]);
target-cris/translate_v10.c:        dc->delayed_branch = 1;
target-cris/translate_v10.c:    int rd = dc->dst;
target-cris/translate_v10.c:    cris_alu(dc, CC_OP_BOUND, cpu_R[dc->dst], cpu_R[rd], t, 4);
target-cris/translate_v10.c:    if (dc->dst == 15) {
target-cris/translate_v10.c:        tcg_gen_mov_tl(env_btarget, cpu_R[dc->dst]);
target-cris/translate_v10.c:        dc->delayed_branch = 1;
target-cris/translate_v10.c:    unsigned int size = (dc->size & 1) ? 2 : 1;
target-cris/translate_v10.c:    unsigned int sx = !!(dc->size & 2);
target-cris/translate_v10.c:    int rd = dc->dst;
target-cris/translate_v10.c:    LOG_DIS("addx size=%d sx=%d op=%d %d\n", size, sx, dc->src, dc->dst);
target-cris/translate_v10.c:    cris_alu(dc, op, cpu_R[dc->dst], cpu_R[rd], t, 4);
target-cris/translate_v10.c:    if (dc->dst == 15) {
target-cris/translate_v10.c:        tcg_gen_mov_tl(env_btarget, cpu_R[dc->dst]);
target-cris/translate_v10.c:        dc->delayed_branch = 1;
target-cris/translate_v10.c:              dc->pc, dc->opcode, dc->src, dc->dst);
target-cris/translate_v10.c:    if (dc->src == 15) {
target-cris/translate_v10.c:        imm = cpu_ldl_code(env, dc->pc + 2);
target-cris/translate_v10.c:        if (dc->postinc)
target-cris/translate_v10.c:        gen_load(dc, cpu_PR[PR_PREFIX], cpu_R[dc->src], 4, 0);
target-cris/translate_v10.c:        if (dc->postinc)
target-cris/translate_v10.c:            tcg_gen_addi_tl(cpu_R[dc->src], cpu_R[dc->src], 4);
target-cris/translate_v10.c:    int rd = dc->dst;
target-cris/translate_v10.c:              dc->pc, dc->opcode, dc->src, dc->dst, size);
target-cris/translate_v10.c:    assert(dc->dst != 15);
target-cris/translate_v10.c:    if (!dc->postinc && (dc->ir & (1 << 11))) {
target-cris/translate_v10.c:        int simm = dc->ir & 0xff;
target-cris/translate_v10.c:        /* cpu_abort(CPU(dc->cpu), "Unhandled opcode"); */
target-cris/translate_v10.c:        tcg_gen_addi_tl(cpu_PR[PR_PREFIX], cpu_R[dc->dst], simm);
target-cris/translate_v10.c:    unsigned int size = dec10_size(dc->size);
target-cris/translate_v10.c:    if (dc->size != 3) {
target-cris/translate_v10.c:        switch (dc->opcode) {
target-cris/translate_v10.c:                LOG_DIS("cmp size=%d op=%d %d\n",  size, dc->src, dc->dst);
target-cris/translate_v10.c:                LOG_DIS("test size=%d op=%d %d\n",  size, dc->src, dc->dst);
target-cris/translate_v10.c:                cris_alu(dc, CC_OP_CMP, cpu_R[dc->dst],
target-cris/translate_v10.c:                LOG_DIS("add size=%d op=%d %d\n",  size, dc->src, dc->dst);
target-cris/translate_v10.c:                LOG_DIS("sub size=%d op=%d %d\n",  size, dc->src, dc->dst);
target-cris/translate_v10.c:                LOG_DIS("bound size=%d op=%d %d\n",  size, dc->src, dc->dst);
target-cris/translate_v10.c:                LOG_DIS("and size=%d op=%d %d\n",  size, dc->src, dc->dst);
target-cris/translate_v10.c:                LOG_DIS("or size=%d op=%d %d\n",  size, dc->src, dc->dst);
target-cris/translate_v10.c:                LOG_DIS("mul pc=%x opcode=%d\n", dc->pc, dc->opcode);
target-cris/translate_v10.c:                dec10_reg_mul(dc, size, dc->ir & (1 << 10));
target-cris/translate_v10.c:                          dc->pc, size, dc->opcode, dc->src, dc->dst);
target-cris/translate_v10.c:                cpu_abort(CPU(dc->cpu), "Unhandled opcode");
target-cris/translate_v10.c:    switch (dc->opcode) {
target-cris/translate_v10.c:            if (dc->src == 15) {
target-cris/translate_v10.c:                         dc->opcode, dc->src, dc->dst);
target-cris/translate_v10.c:                imm = cpu_ldl_code(env, dc->pc + 2);
target-cris/translate_v10.c:                if (dc->mode == CRISV10_MODE_AUTOINC)
target-cris/translate_v10.c:                t_gen_mov_preg_TN(dc, dc->dst, tcg_const_tl(dc->pc + insn_len));
target-cris/translate_v10.c:                dc->jmp_pc = imm;
target-cris/translate_v10.c:                dc->delayed_branch--; /* v10 has no dslot here.  */
target-cris/translate_v10.c:                if (dc->dst == 14) {
target-cris/translate_v10.c:                    LOG_DIS("break %d\n", dc->src);
target-cris/translate_v10.c:                    tcg_gen_movi_tl(env_pc, dc->pc + 2);
target-cris/translate_v10.c:                    t_gen_mov_env_TN(trap_vector, tcg_const_tl(dc->src + 2));
target-cris/translate_v10.c:                    dc->is_jmp = DISAS_UPDATE;
target-cris/translate_v10.c:                         dc->opcode, dc->src, dc->dst);
target-cris/translate_v10.c:                t_gen_mov_preg_TN(dc, dc->dst, tcg_const_tl(dc->pc + insn_len));
target-cris/translate_v10.c:                dc->delayed_branch--; /* v10 has no dslot here.  */
target-cris/translate_v10.c:                        dc->pc, dc->opcode, dc->dst, dc->src);
target-cris/translate_v10.c:            LOG_DIS("movem_m_r pc=%x opcode=%d\n", dc->pc, dc->opcode);
target-cris/translate_v10.c:                        dc->pc, dc->opcode, dc->dst, dc->src);
target-cris/translate_v10.c:            tcg_gen_mov_tl(env_btarget, cpu_R[dc->src]);
target-cris/translate_v10.c:            t_gen_mov_preg_TN(dc, dc->dst, tcg_const_tl(dc->pc + insn_len));
target-cris/translate_v10.c:            dc->delayed_branch--; /* v10 has no dslot here.  */
target-cris/translate_v10.c:            imm = cpu_ldsw_code(env, dc->pc + 2);
target-cris/translate_v10.c:            LOG_DIS("bcc_m: b%s %x\n", cc_name(dc->cond), dc->pc + simm);
target-cris/translate_v10.c:            cris_prepare_cc_branch(dc, simm, dc->cond);
target-cris/translate_v10.c:            LOG_DIS("ERROR pc=%x opcode=%d\n", dc->pc, dc->opcode);
target-cris/translate_v10.c:            cpu_abort(CPU(dc->cpu), "Unhandled opcode");
target-cris/translate_v10.c:        tcg_gen_debug_insn_start(dc->pc);
target-cris/translate_v10.c:    dc->ir = cpu_lduw_code(env, dc->pc);
target-cris/translate_v10.c:    dc->opcode   = EXTRACT_FIELD(dc->ir, 6, 9);
target-cris/translate_v10.c:    dc->mode     = EXTRACT_FIELD(dc->ir, 10, 11);
target-cris/translate_v10.c:    dc->src      = EXTRACT_FIELD(dc->ir, 0, 3);
target-cris/translate_v10.c:    dc->size     = EXTRACT_FIELD(dc->ir, 4, 5);
target-cris/translate_v10.c:    dc->cond = dc->dst = EXTRACT_FIELD(dc->ir, 12, 15);
target-cris/translate_v10.c:    dc->postinc  = EXTRACT_FIELD(dc->ir, 10, 10);
target-cris/translate_v10.c:    dc->clear_prefix = 1;
target-cris/translate_v10.c:    if (dc->src == 15 || dc->dst == 15)
target-cris/translate_v10.c:        tcg_gen_movi_tl(cpu_R[15], dc->pc + 2);
target-cris/translate_v10.c:    switch (dc->mode) {
target-cris/translate_v10.c:    if (dc->clear_prefix && dc->tb_flags & PFIX_FLAG) {
target-cris/translate_v10.c:        dc->tb_flags &= ~PFIX_FLAG;
target-cris/translate_v10.c:        if (dc->tb_flags != dc->tb->flags) {
target-cris/translate_v10.c:            dc->cpustate_changed = 1;
target-cris/translate_v10.c:    if (dc->delayed_branch == 2) {
target-i386/translate.c:    dc->pe = (flags >> HF_PE_SHIFT) & 1;
target-i386/translate.c:    dc->code32 = (flags >> HF_CS32_SHIFT) & 1;
target-i386/translate.c:    dc->ss32 = (flags >> HF_SS32_SHIFT) & 1;
target-i386/translate.c:    dc->addseg = (flags >> HF_ADDSEG_SHIFT) & 1;
target-i386/translate.c:    dc->f_st = 0;
target-i386/translate.c:    dc->vm86 = (flags >> VM_SHIFT) & 1;
target-i386/translate.c:    dc->cpl = (flags >> HF_CPL_SHIFT) & 3;
target-i386/translate.c:    dc->iopl = (flags >> IOPL_SHIFT) & 3;
target-i386/translate.c:    dc->tf = (flags >> TF_SHIFT) & 1;
target-i386/translate.c:    dc->singlestep_enabled = cs->singlestep_enabled;
target-i386/translate.c:    dc->cc_op = CC_OP_DYNAMIC;
target-i386/translate.c:    dc->cc_op_dirty = false;
target-i386/translate.c:    dc->cs_base = cs_base;
target-i386/translate.c:    dc->tb = tb;
target-i386/translate.c:    dc->popl_esp_hack = 0;
target-i386/translate.c:    dc->mem_index = 0;
target-i386/translate.c:        dc->mem_index = cpu_mmu_index(env);
target-i386/translate.c:    dc->cpuid_features = env->features[FEAT_1_EDX];
target-i386/translate.c:    dc->cpuid_ext_features = env->features[FEAT_1_ECX];
target-i386/translate.c:    dc->cpuid_ext2_features = env->features[FEAT_8000_0001_EDX];
target-i386/translate.c:    dc->cpuid_ext3_features = env->features[FEAT_8000_0001_ECX];
target-i386/translate.c:    dc->cpuid_7_0_ebx_features = env->features[FEAT_7_0_EBX];
target-i386/translate.c:    dc->lma = (flags >> HF_LMA_SHIFT) & 1;
target-i386/translate.c:    dc->code64 = (flags >> HF_CS64_SHIFT) & 1;
target-i386/translate.c:    dc->flags = flags;
target-i386/translate.c:    dc->jmp_opt = !(dc->tf || cs->singlestep_enabled ||
target-i386/translate.c:    if (!dc->addseg && (dc->vm86 || !dc->pe || !dc->code32))
target-i386/translate.c:    dc->is_jmp = DISAS_NEXT;
target-i386/translate.c:                    gen_debug(dc, pc_ptr - dc->cs_base);
target-i386/translate.c:            gen_opc_cc_op[lj] = dc->cc_op;
target-i386/translate.c:        if (dc->is_jmp)
target-i386/translate.c:        if (dc->tf || dc->singlestep_enabled ||
target-i386/translate.c:            gen_jmp_im(pc_ptr - dc->cs_base);
target-i386/translate.c:            gen_jmp_im(pc_ptr - dc->cs_base);
target-i386/translate.c:            gen_jmp_im(pc_ptr - dc->cs_base);
target-i386/translate.c:        if (dc->code64)
target-i386/translate.c:            disas_flags = !dc->code32;
target-i386/cpu.c:    xcc->parent_realize = dc->realize;
target-i386/cpu.c:    dc->realize = x86_cpu_realizefn;
target-i386/cpu.c:    dc->bus_type = TYPE_ICC_BUS;
target-i386/cpu.c:    dc->props = x86_cpu_properties;
target-lm32/translate.c:    tcg_gen_movi_tl(cpu_pc, dc->pc);
target-lm32/translate.c:    tb = dc->tb;
target-lm32/translate.c:            likely(!dc->singlestep_enabled)) {
target-lm32/translate.c:        if (dc->singlestep_enabled) {
target-lm32/translate.c:    if (dc->format == OP_FMT_RI) {
target-lm32/translate.c:        if (dc->r0 == R_R0) {
target-lm32/translate.c:            if (dc->r1 == R_R0 && dc->imm16 == 0) {
target-lm32/translate.c:                LOG_DIS("mvi r%d, %d\n", dc->r1, sign_extend(dc->imm16, 16));
target-lm32/translate.c:            LOG_DIS("addi r%d, r%d, %d\n", dc->r1, dc->r0,
target-lm32/translate.c:                    sign_extend(dc->imm16, 16));
target-lm32/translate.c:        LOG_DIS("add r%d, r%d, r%d\n", dc->r2, dc->r0, dc->r1);
target-lm32/translate.c:    if (dc->format == OP_FMT_RI) {
target-lm32/translate.c:        tcg_gen_addi_tl(cpu_R[dc->r1], cpu_R[dc->r0],
target-lm32/translate.c:                sign_extend(dc->imm16, 16));
target-lm32/translate.c:        tcg_gen_add_tl(cpu_R[dc->r2], cpu_R[dc->r0], cpu_R[dc->r1]);
target-lm32/translate.c:    if (dc->format == OP_FMT_RI) {
target-lm32/translate.c:        LOG_DIS("andi r%d, r%d, %d\n", dc->r1, dc->r0,
target-lm32/translate.c:                zero_extend(dc->imm16, 16));
target-lm32/translate.c:        LOG_DIS("and r%d, r%d, r%d\n", dc->r2, dc->r0, dc->r1);
target-lm32/translate.c:    if (dc->format == OP_FMT_RI) {
target-lm32/translate.c:        tcg_gen_andi_tl(cpu_R[dc->r1], cpu_R[dc->r0],
target-lm32/translate.c:                zero_extend(dc->imm16, 16));
target-lm32/translate.c:        if (dc->r0 == 0 && dc->r1 == 0 && dc->r2 == 0) {
target-lm32/translate.c:            tcg_gen_movi_tl(cpu_pc, dc->pc + 4);
target-lm32/translate.c:            tcg_gen_and_tl(cpu_R[dc->r2], cpu_R[dc->r0], cpu_R[dc->r1]);
target-lm32/translate.c:    LOG_DIS("andhi r%d, r%d, %d\n", dc->r2, dc->r0, dc->imm16);
target-lm32/translate.c:    tcg_gen_andi_tl(cpu_R[dc->r1], cpu_R[dc->r0], (dc->imm16 << 16));
target-lm32/translate.c:    if (dc->r0 == R_RA) {
target-lm32/translate.c:    } else if (dc->r0 == R_EA) {
target-lm32/translate.c:    } else if (dc->r0 == R_BA) {
target-lm32/translate.c:        LOG_DIS("b r%d\n", dc->r0);
target-lm32/translate.c:    if (dc->r0 == R_EA) {
target-lm32/translate.c:    } else if (dc->r0 == R_BA) {
target-lm32/translate.c:    tcg_gen_mov_tl(cpu_pc, cpu_R[dc->r0]);
target-lm32/translate.c:    dc->is_jmp = DISAS_JUMP;
target-lm32/translate.c:    LOG_DIS("bi %d\n", sign_extend(dc->imm26 << 2, 26));
target-lm32/translate.c:    gen_goto_tb(dc, 0, dc->pc + (sign_extend(dc->imm26 << 2, 26)));
target-lm32/translate.c:    dc->is_jmp = DISAS_TB_JUMP;
target-lm32/translate.c:    tcg_gen_brcond_tl(cond, cpu_R[dc->r0], cpu_R[dc->r1], l1);
target-lm32/translate.c:    gen_goto_tb(dc, 0, dc->pc + 4);
target-lm32/translate.c:    gen_goto_tb(dc, 1, dc->pc + (sign_extend(dc->imm16 << 2, 16)));
target-lm32/translate.c:    dc->is_jmp = DISAS_TB_JUMP;
target-lm32/translate.c:    LOG_DIS("be r%d, r%d, %d\n", dc->r0, dc->r1,
target-lm32/translate.c:            sign_extend(dc->imm16, 16) * 4);
target-lm32/translate.c:    LOG_DIS("bg r%d, r%d, %d\n", dc->r0, dc->r1,
target-lm32/translate.c:            sign_extend(dc->imm16, 16 * 4));
target-lm32/translate.c:    LOG_DIS("bge r%d, r%d, %d\n", dc->r0, dc->r1,
target-lm32/translate.c:            sign_extend(dc->imm16, 16) * 4);
target-lm32/translate.c:    LOG_DIS("bgeu r%d, r%d, %d\n", dc->r0, dc->r1,
target-lm32/translate.c:            sign_extend(dc->imm16, 16) * 4);
target-lm32/translate.c:    LOG_DIS("bgu r%d, r%d, %d\n", dc->r0, dc->r1,
target-lm32/translate.c:            sign_extend(dc->imm16, 16) * 4);
target-lm32/translate.c:    LOG_DIS("bne r%d, r%d, %d\n", dc->r0, dc->r1,
target-lm32/translate.c:            sign_extend(dc->imm16, 16) * 4);
target-lm32/translate.c:    LOG_DIS("call r%d\n", dc->r0);
target-lm32/translate.c:    tcg_gen_movi_tl(cpu_R[R_RA], dc->pc + 4);
target-lm32/translate.c:    tcg_gen_mov_tl(cpu_pc, cpu_R[dc->r0]);
target-lm32/translate.c:    dc->is_jmp = DISAS_JUMP;
target-lm32/translate.c:    LOG_DIS("calli %d\n", sign_extend(dc->imm26, 26) * 4);
target-lm32/translate.c:    tcg_gen_movi_tl(cpu_R[R_RA], dc->pc + 4);
target-lm32/translate.c:    gen_goto_tb(dc, 0, dc->pc + (sign_extend(dc->imm26 << 2, 26)));
target-lm32/translate.c:    dc->is_jmp = DISAS_TB_JUMP;
target-lm32/translate.c:    int rX = (dc->format == OP_FMT_RR) ? dc->r2 : dc->r1;
target-lm32/translate.c:    int rY = (dc->format == OP_FMT_RR) ? dc->r0 : dc->r0;
target-lm32/translate.c:    int rZ = (dc->format == OP_FMT_RR) ? dc->r1 : -1;
target-lm32/translate.c:    if (dc->format == OP_FMT_RI) {
target-lm32/translate.c:            i = zero_extend(dc->imm16, 16);
target-lm32/translate.c:            i = sign_extend(dc->imm16, 16);
target-lm32/translate.c:    if (dc->format == OP_FMT_RI) {
target-lm32/translate.c:        LOG_DIS("cmpei r%d, r%d, %d\n", dc->r0, dc->r1,
target-lm32/translate.c:                sign_extend(dc->imm16, 16));
target-lm32/translate.c:        LOG_DIS("cmpe r%d, r%d, r%d\n", dc->r2, dc->r0, dc->r1);
target-lm32/translate.c:    if (dc->format == OP_FMT_RI) {
target-lm32/translate.c:        LOG_DIS("cmpgi r%d, r%d, %d\n", dc->r0, dc->r1,
target-lm32/translate.c:                sign_extend(dc->imm16, 16));
target-lm32/translate.c:        LOG_DIS("cmpg r%d, r%d, r%d\n", dc->r2, dc->r0, dc->r1);
target-lm32/translate.c:    if (dc->format == OP_FMT_RI) {
target-lm32/translate.c:        LOG_DIS("cmpgei r%d, r%d, %d\n", dc->r0, dc->r1,
target-lm32/translate.c:                sign_extend(dc->imm16, 16));
target-lm32/translate.c:        LOG_DIS("cmpge r%d, r%d, r%d\n", dc->r2, dc->r0, dc->r1);
target-lm32/translate.c:    if (dc->format == OP_FMT_RI) {
target-lm32/translate.c:        LOG_DIS("cmpgeui r%d, r%d, %d\n", dc->r0, dc->r1,
target-lm32/translate.c:                zero_extend(dc->imm16, 16));
target-lm32/translate.c:        LOG_DIS("cmpgeu r%d, r%d, r%d\n", dc->r2, dc->r0, dc->r1);
target-lm32/translate.c:    if (dc->format == OP_FMT_RI) {
target-lm32/translate.c:        LOG_DIS("cmpgui r%d, r%d, %d\n", dc->r0, dc->r1,
target-lm32/translate.c:                zero_extend(dc->imm16, 16));
target-lm32/translate.c:        LOG_DIS("cmpgu r%d, r%d, r%d\n", dc->r2, dc->r0, dc->r1);
target-lm32/translate.c:    if (dc->format == OP_FMT_RI) {
target-lm32/translate.c:        LOG_DIS("cmpnei r%d, r%d, %d\n", dc->r0, dc->r1,
target-lm32/translate.c:                sign_extend(dc->imm16, 16));
target-lm32/translate.c:        LOG_DIS("cmpne r%d, r%d, r%d\n", dc->r2, dc->r0, dc->r1);
target-lm32/translate.c:    LOG_DIS("divu r%d, r%d, r%d\n", dc->r2, dc->r0, dc->r1);
target-lm32/translate.c:    if (!(dc->features & LM32_FEATURE_DIVIDE)) {
target-lm32/translate.c:    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[dc->r1], 0, l1);
target-lm32/translate.c:    tcg_gen_movi_tl(cpu_pc, dc->pc);
target-lm32/translate.c:    tcg_gen_divu_tl(cpu_R[dc->r2], cpu_R[dc->r0], cpu_R[dc->r1]);
target-lm32/translate.c:    LOG_DIS("lb r%d, (r%d+%d)\n", dc->r1, dc->r0, dc->imm16);
target-lm32/translate.c:    tcg_gen_addi_tl(t0, cpu_R[dc->r0], sign_extend(dc->imm16, 16));
target-lm32/translate.c:    tcg_gen_qemu_ld8s(cpu_R[dc->r1], t0, MEM_INDEX);
target-lm32/translate.c:    LOG_DIS("lbu r%d, (r%d+%d)\n", dc->r1, dc->r0, dc->imm16);
target-lm32/translate.c:    tcg_gen_addi_tl(t0, cpu_R[dc->r0], sign_extend(dc->imm16, 16));
target-lm32/translate.c:    tcg_gen_qemu_ld8u(cpu_R[dc->r1], t0, MEM_INDEX);
target-lm32/translate.c:    LOG_DIS("lh r%d, (r%d+%d)\n", dc->r1, dc->r0, dc->imm16);
target-lm32/translate.c:    tcg_gen_addi_tl(t0, cpu_R[dc->r0], sign_extend(dc->imm16, 16));
target-lm32/translate.c:    tcg_gen_qemu_ld16s(cpu_R[dc->r1], t0, MEM_INDEX);
target-lm32/translate.c:    LOG_DIS("lhu r%d, (r%d+%d)\n", dc->r1, dc->r0, dc->imm16);
target-lm32/translate.c:    tcg_gen_addi_tl(t0, cpu_R[dc->r0], sign_extend(dc->imm16, 16));
target-lm32/translate.c:    tcg_gen_qemu_ld16u(cpu_R[dc->r1], t0, MEM_INDEX);
target-lm32/translate.c:    LOG_DIS("lw r%d, (r%d+%d)\n", dc->r1, dc->r0, sign_extend(dc->imm16, 16));
target-lm32/translate.c:    tcg_gen_addi_tl(t0, cpu_R[dc->r0], sign_extend(dc->imm16, 16));
target-lm32/translate.c:    tcg_gen_qemu_ld32s(cpu_R[dc->r1], t0, MEM_INDEX);
target-lm32/translate.c:    LOG_DIS("modu r%d, r%d, %d\n", dc->r2, dc->r0, dc->r1);
target-lm32/translate.c:    if (!(dc->features & LM32_FEATURE_DIVIDE)) {
target-lm32/translate.c:    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[dc->r1], 0, l1);
target-lm32/translate.c:    tcg_gen_movi_tl(cpu_pc, dc->pc);
target-lm32/translate.c:    tcg_gen_remu_tl(cpu_R[dc->r2], cpu_R[dc->r0], cpu_R[dc->r1]);
target-lm32/translate.c:    if (dc->format == OP_FMT_RI) {
target-lm32/translate.c:        LOG_DIS("muli r%d, r%d, %d\n", dc->r0, dc->r1,
target-lm32/translate.c:                sign_extend(dc->imm16, 16));
target-lm32/translate.c:        LOG_DIS("mul r%d, r%d, r%d\n", dc->r2, dc->r0, dc->r1);
target-lm32/translate.c:    if (!(dc->features & LM32_FEATURE_MULTIPLY)) {
target-lm32/translate.c:    if (dc->format == OP_FMT_RI) {
target-lm32/translate.c:        tcg_gen_muli_tl(cpu_R[dc->r1], cpu_R[dc->r0],
target-lm32/translate.c:                sign_extend(dc->imm16, 16));
target-lm32/translate.c:        tcg_gen_mul_tl(cpu_R[dc->r2], cpu_R[dc->r0], cpu_R[dc->r1]);
target-lm32/translate.c:    if (dc->format == OP_FMT_RI) {
target-lm32/translate.c:        LOG_DIS("nori r%d, r%d, %d\n", dc->r0, dc->r1,
target-lm32/translate.c:                zero_extend(dc->imm16, 16));
target-lm32/translate.c:        LOG_DIS("nor r%d, r%d, r%d\n", dc->r2, dc->r0, dc->r1);
target-lm32/translate.c:    if (dc->format == OP_FMT_RI) {
target-lm32/translate.c:        tcg_gen_movi_tl(t0, zero_extend(dc->imm16, 16));
target-lm32/translate.c:        tcg_gen_nor_tl(cpu_R[dc->r1], cpu_R[dc->r0], t0);
target-lm32/translate.c:        tcg_gen_nor_tl(cpu_R[dc->r2], cpu_R[dc->r0], cpu_R[dc->r1]);
target-lm32/translate.c:    if (dc->format == OP_FMT_RI) {
target-lm32/translate.c:        LOG_DIS("ori r%d, r%d, %d\n", dc->r1, dc->r0,
target-lm32/translate.c:                zero_extend(dc->imm16, 16));
target-lm32/translate.c:        if (dc->r1 == R_R0) {
target-lm32/translate.c:            LOG_DIS("mv r%d, r%d\n", dc->r2, dc->r0);
target-lm32/translate.c:            LOG_DIS("or r%d, r%d, r%d\n", dc->r2, dc->r0, dc->r1);
target-lm32/translate.c:    if (dc->format == OP_FMT_RI) {
target-lm32/translate.c:        tcg_gen_ori_tl(cpu_R[dc->r1], cpu_R[dc->r0],
target-lm32/translate.c:                zero_extend(dc->imm16, 16));
target-lm32/translate.c:        tcg_gen_or_tl(cpu_R[dc->r2], cpu_R[dc->r0], cpu_R[dc->r1]);
target-lm32/translate.c:    if (dc->r0 == R_R0) {
target-lm32/translate.c:        LOG_DIS("mvhi r%d, %d\n", dc->r1, dc->imm16);
target-lm32/translate.c:        LOG_DIS("orhi r%d, r%d, %d\n", dc->r1, dc->r0, dc->imm16);
target-lm32/translate.c:    tcg_gen_ori_tl(cpu_R[dc->r1], cpu_R[dc->r0], (dc->imm16 << 16));
target-lm32/translate.c:    switch (dc->imm5) {
target-lm32/translate.c:        tcg_gen_movi_tl(cpu_pc, dc->pc);
target-lm32/translate.c:        tcg_gen_movi_tl(cpu_pc, dc->pc);
target-lm32/translate.c:        qemu_log_mask(LOG_GUEST_ERROR, "invalid opcode @0x%x", dc->pc);
target-lm32/translate.c:    LOG_DIS("rcsr r%d, %d\n", dc->r2, dc->csr);
target-lm32/translate.c:    switch (dc->csr) {
target-lm32/translate.c:        tcg_gen_mov_tl(cpu_R[dc->r2], cpu_ie);
target-lm32/translate.c:        gen_helper_rcsr_im(cpu_R[dc->r2], cpu_env);
target-lm32/translate.c:        gen_helper_rcsr_ip(cpu_R[dc->r2], cpu_env);
target-lm32/translate.c:        tcg_gen_mov_tl(cpu_R[dc->r2], cpu_cc);
target-lm32/translate.c:        tcg_gen_mov_tl(cpu_R[dc->r2], cpu_cfg);
target-lm32/translate.c:        tcg_gen_mov_tl(cpu_R[dc->r2], cpu_eba);
target-lm32/translate.c:        tcg_gen_mov_tl(cpu_R[dc->r2], cpu_dc);
target-lm32/translate.c:        tcg_gen_mov_tl(cpu_R[dc->r2], cpu_deba);
target-lm32/translate.c:        gen_helper_rcsr_jtx(cpu_R[dc->r2], cpu_env);
target-lm32/translate.c:        gen_helper_rcsr_jrx(cpu_R[dc->r2], cpu_env);
target-lm32/translate.c:        qemu_log_mask(LOG_GUEST_ERROR, "invalid read access csr=%x\n", dc->csr);
target-lm32/translate.c:        qemu_log_mask(LOG_GUEST_ERROR, "read_csr: unknown csr=%x\n", dc->csr);
target-lm32/translate.c:    LOG_DIS("sb (r%d+%d), r%d\n", dc->r0, dc->imm16, dc->r1);
target-lm32/translate.c:    tcg_gen_addi_tl(t0, cpu_R[dc->r0], sign_extend(dc->imm16, 16));
target-lm32/translate.c:    tcg_gen_qemu_st8(cpu_R[dc->r1], t0, MEM_INDEX);
target-lm32/translate.c:    LOG_DIS("sextb r%d, r%d\n", dc->r2, dc->r0);
target-lm32/translate.c:    if (!(dc->features & LM32_FEATURE_SIGN_EXTEND)) {
target-lm32/translate.c:    tcg_gen_ext8s_tl(cpu_R[dc->r2], cpu_R[dc->r0]);
target-lm32/translate.c:    LOG_DIS("sexth r%d, r%d\n", dc->r2, dc->r0);
target-lm32/translate.c:    if (!(dc->features & LM32_FEATURE_SIGN_EXTEND)) {
target-lm32/translate.c:    tcg_gen_ext16s_tl(cpu_R[dc->r2], cpu_R[dc->r0]);
target-lm32/translate.c:    LOG_DIS("sh (r%d+%d), r%d\n", dc->r0, dc->imm16, dc->r1);
target-lm32/translate.c:    tcg_gen_addi_tl(t0, cpu_R[dc->r0], sign_extend(dc->imm16, 16));
target-lm32/translate.c:    tcg_gen_qemu_st16(cpu_R[dc->r1], t0, MEM_INDEX);
target-lm32/translate.c:    if (dc->format == OP_FMT_RI) {
target-lm32/translate.c:        LOG_DIS("sli r%d, r%d, %d\n", dc->r1, dc->r0, dc->imm5);
target-lm32/translate.c:        LOG_DIS("sl r%d, r%d, r%d\n", dc->r2, dc->r0, dc->r1);
target-lm32/translate.c:    if (!(dc->features & LM32_FEATURE_SHIFT)) {
target-lm32/translate.c:    if (dc->format == OP_FMT_RI) {
target-lm32/translate.c:        tcg_gen_shli_tl(cpu_R[dc->r1], cpu_R[dc->r0], dc->imm5);
target-lm32/translate.c:        tcg_gen_andi_tl(t0, cpu_R[dc->r1], 0x1f);
target-lm32/translate.c:        tcg_gen_shl_tl(cpu_R[dc->r2], cpu_R[dc->r0], t0);
target-lm32/translate.c:    if (dc->format == OP_FMT_RI) {
target-lm32/translate.c:        LOG_DIS("sri r%d, r%d, %d\n", dc->r1, dc->r0, dc->imm5);
target-lm32/translate.c:        LOG_DIS("sr r%d, r%d, r%d\n", dc->r2, dc->r0, dc->r1);
target-lm32/translate.c:    if (dc->format == OP_FMT_RI) {
target-lm32/translate.c:        if (!(dc->features & LM32_FEATURE_SHIFT) && (dc->imm5 != 1)) {
target-lm32/translate.c:        tcg_gen_sari_tl(cpu_R[dc->r1], cpu_R[dc->r0], dc->imm5);
target-lm32/translate.c:        tcg_gen_andi_tl(t0, cpu_R[dc->r1], 0x1f);
target-lm32/translate.c:        if (!(dc->features & LM32_FEATURE_SHIFT)) {
target-lm32/translate.c:        tcg_gen_sar_tl(cpu_R[dc->r2], cpu_R[dc->r0], t0);
target-lm32/translate.c:    if (dc->format == OP_FMT_RI) {
target-lm32/translate.c:        LOG_DIS("srui r%d, r%d, %d\n", dc->r1, dc->r0, dc->imm5);
target-lm32/translate.c:        LOG_DIS("sru r%d, r%d, r%d\n", dc->r2, dc->r0, dc->r1);
target-lm32/translate.c:    if (dc->format == OP_FMT_RI) {
target-lm32/translate.c:        if (!(dc->features & LM32_FEATURE_SHIFT) && (dc->imm5 != 1)) {
target-lm32/translate.c:        tcg_gen_shri_tl(cpu_R[dc->r1], cpu_R[dc->r0], dc->imm5);
target-lm32/translate.c:        tcg_gen_andi_tl(t0, cpu_R[dc->r1], 0x1f);
target-lm32/translate.c:        if (!(dc->features & LM32_FEATURE_SHIFT)) {
target-lm32/translate.c:        tcg_gen_shr_tl(cpu_R[dc->r2], cpu_R[dc->r0], t0);
target-lm32/translate.c:    LOG_DIS("sub r%d, r%d, r%d\n", dc->r2, dc->r0, dc->r1);
target-lm32/translate.c:    tcg_gen_sub_tl(cpu_R[dc->r2], cpu_R[dc->r0], cpu_R[dc->r1]);
target-lm32/translate.c:    LOG_DIS("sw (r%d+%d), r%d\n", dc->r0, sign_extend(dc->imm16, 16), dc->r1);
target-lm32/translate.c:    tcg_gen_addi_tl(t0, cpu_R[dc->r0], sign_extend(dc->imm16, 16));
target-lm32/translate.c:    tcg_gen_qemu_st32(cpu_R[dc->r1], t0, MEM_INDEX);
target-lm32/translate.c:    LOG_DIS("wcsr r%d, %d\n", dc->r1, dc->csr);
target-lm32/translate.c:    switch (dc->csr) {
target-lm32/translate.c:        tcg_gen_mov_tl(cpu_ie, cpu_R[dc->r1]);
target-lm32/translate.c:        tcg_gen_movi_tl(cpu_pc, dc->pc + 4);
target-lm32/translate.c:        dc->is_jmp = DISAS_UPDATE;
target-lm32/translate.c:        gen_helper_wcsr_im(cpu_env, cpu_R[dc->r1]);
target-lm32/translate.c:        tcg_gen_movi_tl(cpu_pc, dc->pc + 4);
target-lm32/translate.c:        dc->is_jmp = DISAS_UPDATE;
target-lm32/translate.c:        gen_helper_wcsr_ip(cpu_env, cpu_R[dc->r1]);
target-lm32/translate.c:        tcg_gen_movi_tl(cpu_pc, dc->pc + 4);
target-lm32/translate.c:        dc->is_jmp = DISAS_UPDATE;
target-lm32/translate.c:        tcg_gen_mov_tl(cpu_eba, cpu_R[dc->r1]);
target-lm32/translate.c:        tcg_gen_mov_tl(cpu_deba, cpu_R[dc->r1]);
target-lm32/translate.c:        gen_helper_wcsr_jtx(cpu_env, cpu_R[dc->r1]);
target-lm32/translate.c:        gen_helper_wcsr_jrx(cpu_env, cpu_R[dc->r1]);
target-lm32/translate.c:        gen_helper_wcsr_dc(cpu_env, cpu_R[dc->r1]);
target-lm32/translate.c:        no = dc->csr - CSR_BP0;
target-lm32/translate.c:        if (dc->num_breakpoints <= no) {
target-lm32/translate.c:        gen_helper_wcsr_bp(cpu_env, cpu_R[dc->r1], tcg_const_i32(no));
target-lm32/translate.c:        no = dc->csr - CSR_WP0;
target-lm32/translate.c:        if (dc->num_watchpoints <= no) {
target-lm32/translate.c:        gen_helper_wcsr_wp(cpu_env, cpu_R[dc->r1], tcg_const_i32(no));
target-lm32/translate.c:                      dc->csr);
target-lm32/translate.c:                      dc->csr);
target-lm32/translate.c:    if (dc->format == OP_FMT_RI) {
target-lm32/translate.c:        LOG_DIS("xnori r%d, r%d, %d\n", dc->r0, dc->r1,
target-lm32/translate.c:                zero_extend(dc->imm16, 16));
target-lm32/translate.c:        if (dc->r1 == R_R0) {
target-lm32/translate.c:            LOG_DIS("not r%d, r%d\n", dc->r2, dc->r0);
target-lm32/translate.c:            LOG_DIS("xnor r%d, r%d, r%d\n", dc->r2, dc->r0, dc->r1);
target-lm32/translate.c:    if (dc->format == OP_FMT_RI) {
target-lm32/translate.c:        tcg_gen_xori_tl(cpu_R[dc->r1], cpu_R[dc->r0],
target-lm32/translate.c:                zero_extend(dc->imm16, 16));
target-lm32/translate.c:        tcg_gen_not_tl(cpu_R[dc->r1], cpu_R[dc->r1]);
target-lm32/translate.c:        tcg_gen_eqv_tl(cpu_R[dc->r2], cpu_R[dc->r0], cpu_R[dc->r1]);
target-lm32/translate.c:    if (dc->format == OP_FMT_RI) {
target-lm32/translate.c:        LOG_DIS("xori r%d, r%d, %d\n", dc->r0, dc->r1,
target-lm32/translate.c:                zero_extend(dc->imm16, 16));
target-lm32/translate.c:        LOG_DIS("xor r%d, r%d, r%d\n", dc->r2, dc->r0, dc->r1);
target-lm32/translate.c:    if (dc->format == OP_FMT_RI) {
target-lm32/translate.c:        tcg_gen_xori_tl(cpu_R[dc->r1], cpu_R[dc->r0],
target-lm32/translate.c:                zero_extend(dc->imm16, 16));
target-lm32/translate.c:        tcg_gen_xor_tl(cpu_R[dc->r2], cpu_R[dc->r0], cpu_R[dc->r1]);
target-lm32/translate.c:    qemu_log_mask(LOG_GUEST_ERROR, "invalid opcode 0x%02x\n", dc->opcode);
target-lm32/translate.c:        tcg_gen_debug_insn_start(dc->pc);
target-lm32/translate.c:    dc->ir = ir;
target-lm32/translate.c:    LOG_DIS("%8.8x\t", dc->ir);
target-lm32/translate.c:    dc->opcode = EXTRACT_FIELD(ir, 26, 31);
target-lm32/translate.c:    dc->imm5 = EXTRACT_FIELD(ir, 0, 4);
target-lm32/translate.c:    dc->imm16 = EXTRACT_FIELD(ir, 0, 15);
target-lm32/translate.c:    dc->imm26 = EXTRACT_FIELD(ir, 0, 25);
target-lm32/translate.c:    dc->csr = EXTRACT_FIELD(ir, 21, 25);
target-lm32/translate.c:    dc->r0 = EXTRACT_FIELD(ir, 21, 25);
target-lm32/translate.c:    dc->r1 = EXTRACT_FIELD(ir, 16, 20);
target-lm32/translate.c:    dc->r2 = EXTRACT_FIELD(ir, 11, 15);
target-lm32/translate.c:        dc->format = OP_FMT_RR;
target-lm32/translate.c:        dc->format = OP_FMT_RI;
target-lm32/translate.c:    assert(dc->opcode < 64);
target-lm32/translate.c:    decinfo[dc->opcode](dc);
target-lm32/translate.c:            if (bp->pc == dc->pc) {
target-lm32/translate.c:                tcg_gen_movi_tl(cpu_pc, dc->pc);
target-lm32/translate.c:                dc->is_jmp = DISAS_UPDATE;
target-lm32/translate.c:    dc->features = cpu->features;
target-lm32/translate.c:    dc->num_breakpoints = cpu->num_breakpoints;
target-lm32/translate.c:    dc->num_watchpoints = cpu->num_watchpoints;
target-lm32/translate.c:    dc->tb = tb;
target-lm32/translate.c:    dc->is_jmp = DISAS_NEXT;
target-lm32/translate.c:    dc->pc = pc_start;
target-lm32/translate.c:    dc->singlestep_enabled = cs->singlestep_enabled;
target-lm32/translate.c:            tcg_ctx.gen_opc_pc[lj] = dc->pc;
target-lm32/translate.c:        LOG_DIS("%8.8x:\t", dc->pc);
target-lm32/translate.c:        decode(dc, cpu_ldl_code(env, dc->pc));
target-lm32/translate.c:        dc->pc += 4;
target-lm32/translate.c:    } while (!dc->is_jmp
target-lm32/translate.c:         && (dc->pc < next_page_start)
target-lm32/translate.c:        if (dc->is_jmp == DISAS_NEXT) {
target-lm32/translate.c:            tcg_gen_movi_tl(cpu_pc, dc->pc);
target-lm32/translate.c:        switch (dc->is_jmp) {
target-lm32/translate.c:            gen_goto_tb(dc, 1, dc->pc);
target-lm32/translate.c:        tb->size = dc->pc - pc_start;
target-lm32/translate.c:        log_target_disas(env, pc_start, dc->pc - pc_start, 0);
target-lm32/translate.c:            dc->pc - pc_start, tcg_ctx.gen_opc_ptr -
target-lm32/cpu.c:    lcc->parent_realize = dc->realize;
target-lm32/cpu.c:    dc->realize = lm32_cpu_realizefn;
target-m68k/translate.c:    dc->tb = tb;
target-m68k/translate.c:    dc->env = env;
target-m68k/translate.c:    dc->is_jmp = DISAS_NEXT;
target-m68k/translate.c:    dc->pc = pc_start;
target-m68k/translate.c:    dc->cc_op = CC_OP_DYNAMIC;
target-m68k/translate.c:    dc->singlestep_enabled = cs->singlestep_enabled;
target-m68k/translate.c:    dc->fpcr = env->fpcr;
target-m68k/translate.c:    dc->user = (env->sr & SR_S) == 0;
target-m68k/translate.c:    dc->is_mem = 0;
target-m68k/translate.c:    dc->done_mac = 0;
target-m68k/translate.c:        pc_offset = dc->pc - pc_start;
target-m68k/translate.c:                if (bp->pc == dc->pc) {
target-m68k/translate.c:                    gen_exception(dc, dc->pc, EXCP_DEBUG);
target-m68k/translate.c:                    dc->is_jmp = DISAS_JUMP;
target-m68k/translate.c:            if (dc->is_jmp)
target-m68k/translate.c:            tcg_ctx.gen_opc_pc[lj] = dc->pc;
target-m68k/translate.c:        dc->insn_pc = dc->pc;
target-m68k/translate.c:    } while (!dc->is_jmp && tcg_ctx.gen_opc_ptr < gen_opc_end &&
target-m68k/translate.c:        if (!dc->is_jmp) {
target-m68k/translate.c:            tcg_gen_movi_i32(QREG_PC, dc->pc);
target-m68k/translate.c:        switch(dc->is_jmp) {
target-m68k/translate.c:            gen_jmp_tb(dc, 0, dc->pc);
target-m68k/translate.c:        log_target_disas(env, pc_start, dc->pc - pc_start, 0);
target-m68k/translate.c:        tb->size = dc->pc - pc_start;
target-m68k/cpu.c:    mcc->parent_realize = dc->realize;
target-m68k/cpu.c:    dc->realize = m68k_cpu_realizefn;
target-m68k/cpu.c:    dc->vmsd = &vmstate_m68k_cpu;
target-microblaze/translate.c:    if (dc->tb_flags != dc->synced_flags) {
target-microblaze/translate.c:        tcg_gen_movi_tl(env_iflags, dc->tb_flags);
target-microblaze/translate.c:        dc->synced_flags = dc->tb_flags;
target-microblaze/translate.c:    tcg_gen_movi_tl(cpu_SR[SR_PC], dc->pc);
target-microblaze/translate.c:    dc->is_jmp = DISAS_UPDATE;
target-microblaze/translate.c:    tb = dc->tb;
target-microblaze/translate.c:    return dc->type_b && !(dc->tb_flags & IMM_FLAG);
target-microblaze/translate.c:    if (dc->type_b) {
target-microblaze/translate.c:        if (dc->tb_flags & IMM_FLAG)
target-microblaze/translate.c:            tcg_gen_ori_tl(env_imm, env_imm, dc->imm);
target-microblaze/translate.c:            tcg_gen_movi_tl(env_imm, (int32_t)((int16_t)dc->imm));
target-microblaze/translate.c:        return &cpu_R[dc->rb];
target-microblaze/translate.c:    k = dc->opcode & 4;
target-microblaze/translate.c:    c = dc->opcode & 2;
target-microblaze/translate.c:            dc->type_b ? "i" : "", k ? "k" : "", c ? "c" : "",
target-microblaze/translate.c:            dc->rd, dc->ra, dc->rb);
target-microblaze/translate.c:        if (dc->rd) {
target-microblaze/translate.c:            tcg_gen_add_tl(cpu_R[dc->rd], cpu_R[dc->ra], *(dec_alu_op_b(dc)));
target-microblaze/translate.c:                tcg_gen_add_tl(cpu_R[dc->rd], cpu_R[dc->rd], cf);
target-microblaze/translate.c:    if (dc->rd) {
target-microblaze/translate.c:        gen_helper_carry(ncf, cpu_R[dc->ra], *(dec_alu_op_b(dc)), cf);
target-microblaze/translate.c:        tcg_gen_add_tl(cpu_R[dc->rd], cpu_R[dc->ra], *(dec_alu_op_b(dc)));
target-microblaze/translate.c:        tcg_gen_add_tl(cpu_R[dc->rd], cpu_R[dc->rd], cf);
target-microblaze/translate.c:        gen_helper_carry(cf, cpu_R[dc->ra], *(dec_alu_op_b(dc)), cf);
target-microblaze/translate.c:    u = dc->imm & 2;
target-microblaze/translate.c:    k = dc->opcode & 4;
target-microblaze/translate.c:    c = dc->opcode & 2;
target-microblaze/translate.c:    cmp = (dc->imm & 1) && (!dc->type_b) && k;
target-microblaze/translate.c:        LOG_DIS("cmp%s r%d, r%d ir=%x\n", u ? "u" : "", dc->rd, dc->ra, dc->ir);
target-microblaze/translate.c:        if (dc->rd) {
target-microblaze/translate.c:                gen_helper_cmpu(cpu_R[dc->rd], cpu_R[dc->ra], cpu_R[dc->rb]);
target-microblaze/translate.c:                gen_helper_cmp(cpu_R[dc->rd], cpu_R[dc->ra], cpu_R[dc->rb]);
target-microblaze/translate.c:             k ? "k" : "",  c ? "c" : "", dc->rd, dc->ra, dc->rb);
target-microblaze/translate.c:        if (dc->rd) {
target-microblaze/translate.c:            tcg_gen_sub_tl(cpu_R[dc->rd], *(dec_alu_op_b(dc)), cpu_R[dc->ra]);
target-microblaze/translate.c:                tcg_gen_add_tl(cpu_R[dc->rd], cpu_R[dc->rd], cf);
target-microblaze/translate.c:    tcg_gen_not_tl(na, cpu_R[dc->ra]);
target-microblaze/translate.c:    if (dc->rd) {
target-microblaze/translate.c:        tcg_gen_add_tl(cpu_R[dc->rd], na, *(dec_alu_op_b(dc)));
target-microblaze/translate.c:        tcg_gen_add_tl(cpu_R[dc->rd], cpu_R[dc->rd], cf);
target-microblaze/translate.c:    if ((dc->tb_flags & MSR_EE_FLAG)
target-microblaze/translate.c:          && (dc->cpu->env.pvr.regs[2] & PVR2_ILL_OPCODE_EXC_MASK)
target-microblaze/translate.c:          && !((dc->cpu->env.pvr.regs[2] & PVR2_USE_PCMP_INSTR))) {
target-microblaze/translate.c:    mode = dc->opcode & 3;
target-microblaze/translate.c:            LOG_DIS("pcmpbf r%d r%d r%d\n", dc->rd, dc->ra, dc->rb);
target-microblaze/translate.c:            if (dc->rd)
target-microblaze/translate.c:                gen_helper_pcmpbf(cpu_R[dc->rd], cpu_R[dc->ra], cpu_R[dc->rb]);
target-microblaze/translate.c:            LOG_DIS("pcmpeq r%d r%d r%d\n", dc->rd, dc->ra, dc->rb);
target-microblaze/translate.c:            if (dc->rd) {
target-microblaze/translate.c:                                  cpu_R[dc->ra], cpu_R[dc->rb], l1);
target-microblaze/translate.c:                tcg_gen_mov_tl(cpu_R[dc->rd], t0);
target-microblaze/translate.c:            LOG_DIS("pcmpne r%d r%d r%d\n", dc->rd, dc->ra, dc->rb);
target-microblaze/translate.c:            if (dc->rd) {
target-microblaze/translate.c:                                  cpu_R[dc->ra], cpu_R[dc->rb], l1);
target-microblaze/translate.c:                tcg_gen_mov_tl(cpu_R[dc->rd], t0);
target-microblaze/translate.c:            cpu_abort(CPU(dc->cpu),
target-microblaze/translate.c:                      "unsupported pattern insn opcode=%x\n", dc->opcode);
target-microblaze/translate.c:    if (!dc->type_b && (dc->imm & (1 << 10))) {
target-microblaze/translate.c:    not = dc->opcode & (1 << 1);
target-microblaze/translate.c:    if (!dc->rd)
target-microblaze/translate.c:        tcg_gen_andc_tl(cpu_R[dc->rd], cpu_R[dc->ra], *(dec_alu_op_b(dc)));
target-microblaze/translate.c:        tcg_gen_and_tl(cpu_R[dc->rd], cpu_R[dc->ra], *(dec_alu_op_b(dc)));
target-microblaze/translate.c:    if (!dc->type_b && (dc->imm & (1 << 10))) {
target-microblaze/translate.c:    LOG_DIS("or r%d r%d r%d imm=%x\n", dc->rd, dc->ra, dc->rb, dc->imm);
target-microblaze/translate.c:    if (dc->rd)
target-microblaze/translate.c:        tcg_gen_or_tl(cpu_R[dc->rd], cpu_R[dc->ra], *(dec_alu_op_b(dc)));
target-microblaze/translate.c:    if (!dc->type_b && (dc->imm & (1 << 10))) {
target-microblaze/translate.c:    LOG_DIS("xor r%d\n", dc->rd);
target-microblaze/translate.c:    if (dc->rd)
target-microblaze/translate.c:        tcg_gen_xor_tl(cpu_R[dc->rd], cpu_R[dc->ra], *(dec_alu_op_b(dc)));
target-microblaze/translate.c:    dc->cpustate_changed = 1;
target-microblaze/translate.c:    CPUState *cs = CPU(dc->cpu);
target-microblaze/translate.c:    int mem_index = cpu_mmu_index(&dc->cpu->env);
target-microblaze/translate.c:    sr = dc->imm & ((1 << 14) - 1);
target-microblaze/translate.c:    to = dc->imm & (1 << 14);
target-microblaze/translate.c:    dc->type_b = 1;
target-microblaze/translate.c:        dc->cpustate_changed = 1;
target-microblaze/translate.c:    if (!(dc->imm & (1 << 15))) {
target-microblaze/translate.c:        unsigned int clr = dc->ir & (1 << 16);
target-microblaze/translate.c:                dc->rd, dc->imm);
target-microblaze/translate.c:        if (!(dc->cpu->env.pvr.regs[2] & PVR2_USE_MSR_INSTR)) {
target-microblaze/translate.c:        if ((dc->tb_flags & MSR_EE_FLAG)
target-microblaze/translate.c:            && mem_index == MMU_USER_IDX && (dc->imm != 4 && dc->imm != 0)) {
target-microblaze/translate.c:        if (dc->rd)
target-microblaze/translate.c:            msr_read(dc, cpu_R[dc->rd]);
target-microblaze/translate.c:	tcg_gen_movi_tl(cpu_SR[SR_PC], dc->pc + 4);
target-microblaze/translate.c:        dc->is_jmp = DISAS_UPDATE;
target-microblaze/translate.c:        if ((dc->tb_flags & MSR_EE_FLAG)
target-microblaze/translate.c:        LOG_DIS("m%ss sr%d r%d imm=%x\n", to ? "t" : "f", sr, dc->ra, dc->imm);
target-microblaze/translate.c:            gen_helper_mmu_write(cpu_env, tcg_const_tl(sr), cpu_R[dc->ra]);
target-microblaze/translate.c:            gen_helper_mmu_read(cpu_R[dc->rd], cpu_env, tcg_const_tl(sr));
target-microblaze/translate.c:        LOG_DIS("m%ss sr%x r%d imm=%x\n", to ? "t" : "f", sr, dc->ra, dc->imm);
target-microblaze/translate.c:                msr_write(dc, cpu_R[dc->ra]);
target-microblaze/translate.c:                tcg_gen_mov_tl(cpu_SR[SR_EAR], cpu_R[dc->ra]);
target-microblaze/translate.c:                tcg_gen_mov_tl(cpu_SR[SR_ESR], cpu_R[dc->ra]);
target-microblaze/translate.c:                tcg_gen_andi_tl(cpu_SR[SR_FSR], cpu_R[dc->ra], 31);
target-microblaze/translate.c:                tcg_gen_st_tl(cpu_R[dc->ra], cpu_env, offsetof(CPUMBState, slr));
target-microblaze/translate.c:                tcg_gen_st_tl(cpu_R[dc->ra], cpu_env, offsetof(CPUMBState, shr));
target-microblaze/translate.c:                cpu_abort(CPU(dc->cpu), "unknown mts reg %x\n", sr);
target-microblaze/translate.c:        LOG_DIS("m%ss r%d sr%x imm=%x\n", to ? "t" : "f", dc->rd, sr, dc->imm);
target-microblaze/translate.c:                tcg_gen_movi_tl(cpu_R[dc->rd], dc->pc);
target-microblaze/translate.c:                msr_read(dc, cpu_R[dc->rd]);
target-microblaze/translate.c:                tcg_gen_mov_tl(cpu_R[dc->rd], cpu_SR[SR_EAR]);
target-microblaze/translate.c:                tcg_gen_mov_tl(cpu_R[dc->rd], cpu_SR[SR_ESR]);
target-microblaze/translate.c:                tcg_gen_mov_tl(cpu_R[dc->rd], cpu_SR[SR_FSR]);
target-microblaze/translate.c:                tcg_gen_mov_tl(cpu_R[dc->rd], cpu_SR[SR_BTR]);
target-microblaze/translate.c:                tcg_gen_ld_tl(cpu_R[dc->rd], cpu_env, offsetof(CPUMBState, slr));
target-microblaze/translate.c:                tcg_gen_ld_tl(cpu_R[dc->rd], cpu_env, offsetof(CPUMBState, shr));
target-microblaze/translate.c:                tcg_gen_ld_tl(cpu_R[dc->rd],
target-microblaze/translate.c:    if (dc->rd == 0) {
target-microblaze/translate.c:    if ((dc->tb_flags & MSR_EE_FLAG)
target-microblaze/translate.c:         && (dc->cpu->env.pvr.regs[2] & PVR2_ILL_OPCODE_EXC_MASK)
target-microblaze/translate.c:         && !(dc->cpu->env.pvr.regs[0] & PVR0_USE_HW_MUL_MASK)) {
target-microblaze/translate.c:    subcode = dc->imm & 3;
target-microblaze/translate.c:    if (dc->type_b) {
target-microblaze/translate.c:        LOG_DIS("muli r%d r%d %x\n", dc->rd, dc->ra, dc->imm);
target-microblaze/translate.c:        t_gen_mulu(cpu_R[dc->rd], d[1], cpu_R[dc->ra], *(dec_alu_op_b(dc)));
target-microblaze/translate.c:        && !((dc->cpu->env.pvr.regs[2] & PVR2_USE_MUL64_MASK))) {
target-microblaze/translate.c:            LOG_DIS("mul r%d r%d r%d\n", dc->rd, dc->ra, dc->rb);
target-microblaze/translate.c:            t_gen_mulu(cpu_R[dc->rd], d[1], cpu_R[dc->ra], cpu_R[dc->rb]);
target-microblaze/translate.c:            LOG_DIS("mulh r%d r%d r%d\n", dc->rd, dc->ra, dc->rb);
target-microblaze/translate.c:            t_gen_muls(d[0], cpu_R[dc->rd], cpu_R[dc->ra], cpu_R[dc->rb]);
target-microblaze/translate.c:            LOG_DIS("mulhsu r%d r%d r%d\n", dc->rd, dc->ra, dc->rb);
target-microblaze/translate.c:            t_gen_muls(d[0], cpu_R[dc->rd], cpu_R[dc->ra], cpu_R[dc->rb]);
target-microblaze/translate.c:            LOG_DIS("mulhu r%d r%d r%d\n", dc->rd, dc->ra, dc->rb);
target-microblaze/translate.c:            t_gen_mulu(d[0], cpu_R[dc->rd], cpu_R[dc->ra], cpu_R[dc->rb]);
target-microblaze/translate.c:            cpu_abort(CPU(dc->cpu), "unknown MUL insn %x\n", subcode);
target-microblaze/translate.c:    u = dc->imm & 2; 
target-microblaze/translate.c:    if ((dc->cpu->env.pvr.regs[2] & PVR2_ILL_OPCODE_EXC_MASK)
target-microblaze/translate.c:          && !((dc->cpu->env.pvr.regs[0] & PVR0_USE_DIV_MASK))) {
target-microblaze/translate.c:        gen_helper_divu(cpu_R[dc->rd], cpu_env, *(dec_alu_op_b(dc)),
target-microblaze/translate.c:                        cpu_R[dc->ra]);
target-microblaze/translate.c:        gen_helper_divs(cpu_R[dc->rd], cpu_env, *(dec_alu_op_b(dc)),
target-microblaze/translate.c:                        cpu_R[dc->ra]);
target-microblaze/translate.c:    if (!dc->rd)
target-microblaze/translate.c:        tcg_gen_movi_tl(cpu_R[dc->rd], 0);
target-microblaze/translate.c:    if ((dc->tb_flags & MSR_EE_FLAG)
target-microblaze/translate.c:          && (dc->cpu->env.pvr.regs[2] & PVR2_ILL_OPCODE_EXC_MASK)
target-microblaze/translate.c:          && !(dc->cpu->env.pvr.regs[0] & PVR0_USE_BARREL_MASK)) {
target-microblaze/translate.c:    s = dc->imm & (1 << 10);
target-microblaze/translate.c:    t = dc->imm & (1 << 9);
target-microblaze/translate.c:            s ? "l" : "r", t ? "a" : "l", dc->rd, dc->ra, dc->rb);
target-microblaze/translate.c:        tcg_gen_shl_tl(cpu_R[dc->rd], cpu_R[dc->ra], t0);
target-microblaze/translate.c:            tcg_gen_sar_tl(cpu_R[dc->rd], cpu_R[dc->ra], t0);
target-microblaze/translate.c:            tcg_gen_shr_tl(cpu_R[dc->rd], cpu_R[dc->ra], t0);
target-microblaze/translate.c:    CPUState *cs = CPU(dc->cpu);
target-microblaze/translate.c:    int mem_index = cpu_mmu_index(&dc->cpu->env);
target-microblaze/translate.c:    op = dc->ir & ((1 << 9) - 1);
target-microblaze/translate.c:            LOG_DIS("src r%d r%d\n", dc->rd, dc->ra);
target-microblaze/translate.c:            write_carry(dc, cpu_R[dc->ra]);
target-microblaze/translate.c:            if (dc->rd) {
target-microblaze/translate.c:                tcg_gen_shri_tl(cpu_R[dc->rd], cpu_R[dc->ra], 1);
target-microblaze/translate.c:                tcg_gen_or_tl(cpu_R[dc->rd], cpu_R[dc->rd], t0);
target-microblaze/translate.c:            LOG_DIS("srl r%d r%d\n", dc->rd, dc->ra);
target-microblaze/translate.c:            write_carry(dc, cpu_R[dc->ra]);
target-microblaze/translate.c:            if (dc->rd) {
target-microblaze/translate.c:                    tcg_gen_shri_tl(cpu_R[dc->rd], cpu_R[dc->ra], 1);
target-microblaze/translate.c:                    tcg_gen_sari_tl(cpu_R[dc->rd], cpu_R[dc->ra], 1);
target-microblaze/translate.c:            LOG_DIS("ext8s r%d r%d\n", dc->rd, dc->ra);
target-microblaze/translate.c:            tcg_gen_ext8s_i32(cpu_R[dc->rd], cpu_R[dc->ra]);
target-microblaze/translate.c:            LOG_DIS("ext16s r%d r%d\n", dc->rd, dc->ra);
target-microblaze/translate.c:            tcg_gen_ext16s_i32(cpu_R[dc->rd], cpu_R[dc->ra]);
target-microblaze/translate.c:            LOG_DIS("wdc r%d\n", dc->ra);
target-microblaze/translate.c:            if ((dc->tb_flags & MSR_EE_FLAG)
target-microblaze/translate.c:            LOG_DIS("wic r%d\n", dc->ra);
target-microblaze/translate.c:            if ((dc->tb_flags & MSR_EE_FLAG)
target-microblaze/translate.c:            if ((dc->tb_flags & MSR_EE_FLAG)
target-microblaze/translate.c:                && (dc->cpu->env.pvr.regs[2] & PVR2_ILL_OPCODE_EXC_MASK)
target-microblaze/translate.c:                && !((dc->cpu->env.pvr.regs[2] & PVR2_USE_PCMP_INSTR))) {
target-microblaze/translate.c:            if (dc->cpu->env.pvr.regs[2] & PVR2_USE_PCMP_INSTR) {
target-microblaze/translate.c:                gen_helper_clz(cpu_R[dc->rd], cpu_R[dc->ra]);
target-microblaze/translate.c:            LOG_DIS("swapb r%d r%d\n", dc->rd, dc->ra);
target-microblaze/translate.c:            tcg_gen_bswap32_i32(cpu_R[dc->rd], cpu_R[dc->ra]);
target-microblaze/translate.c:            LOG_DIS("swaph r%d r%d\n", dc->rd, dc->ra);
target-microblaze/translate.c:            tcg_gen_rotri_i32(cpu_R[dc->rd], cpu_R[dc->ra], 16);
target-microblaze/translate.c:                      dc->pc, op, dc->rd, dc->ra, dc->rb);
target-microblaze/translate.c:    if (dc->jmp == JMP_DIRECT || dc->jmp == JMP_DIRECT_CC) {
target-microblaze/translate.c:        if (dc->jmp == JMP_DIRECT) {
target-microblaze/translate.c:        dc->jmp = JMP_INDIRECT;
target-microblaze/translate.c:        tcg_gen_movi_tl(env_btarget, dc->jmp_pc);
target-microblaze/translate.c:    LOG_DIS("imm %x\n", dc->imm << 16);
target-microblaze/translate.c:    tcg_gen_movi_tl(env_imm, (dc->imm << 16));
target-microblaze/translate.c:    dc->tb_flags |= IMM_FLAG;
target-microblaze/translate.c:    dc->clear_imm = 0;
target-microblaze/translate.c:    unsigned int extimm = dc->tb_flags & IMM_FLAG;
target-microblaze/translate.c:    if (dc->ra == 1) {
target-microblaze/translate.c:    if (!dc->type_b) {
target-microblaze/translate.c:        if (dc->ra == 0) {
target-microblaze/translate.c:            return &cpu_R[dc->rb];
target-microblaze/translate.c:        } else if (dc->rb == 0) {
target-microblaze/translate.c:            return &cpu_R[dc->ra];
target-microblaze/translate.c:        if (dc->rb == 1) {
target-microblaze/translate.c:        tcg_gen_add_tl(*t, cpu_R[dc->ra], cpu_R[dc->rb]);
target-microblaze/translate.c:        if (dc->imm == 0) {
target-microblaze/translate.c:            return &cpu_R[dc->ra];
target-microblaze/translate.c:        tcg_gen_movi_tl(*t, (int32_t)((int16_t)dc->imm));
target-microblaze/translate.c:        tcg_gen_add_tl(*t, cpu_R[dc->ra], *t);
target-microblaze/translate.c:        tcg_gen_add_tl(*t, cpu_R[dc->ra], *(dec_alu_op_b(dc)));
target-microblaze/translate.c:    mop = dc->opcode & 3;
target-microblaze/translate.c:    if (!dc->type_b) {
target-microblaze/translate.c:        rev = (dc->ir >> 9) & 1;
target-microblaze/translate.c:        ex = (dc->ir >> 10) & 1;
target-microblaze/translate.c:    if (size > 4 && (dc->tb_flags & MSR_EE_FLAG)
target-microblaze/translate.c:          && (dc->cpu->env.pvr.regs[2] & PVR2_ILL_OPCODE_EXC_MASK)) {
target-microblaze/translate.c:    LOG_DIS("l%d%s%s%s\n", size, dc->type_b ? "i" : "", rev ? "r" : "",
target-microblaze/translate.c:                cpu_abort(CPU(dc->cpu), "Invalid reverse size\n");
target-microblaze/translate.c:    tcg_gen_qemu_ld_tl(v, *addr, cpu_mmu_index(&dc->cpu->env), mop);
target-microblaze/translate.c:    if ((dc->cpu->env.pvr.regs[2] & PVR2_UNALIGNED_EXC_MASK) && size > 1) {
target-microblaze/translate.c:        tcg_gen_movi_tl(cpu_SR[SR_PC], dc->pc);
target-microblaze/translate.c:        gen_helper_memalign(cpu_env, *addr, tcg_const_tl(dc->rd),
target-microblaze/translate.c:    if (dc->rd) {
target-microblaze/translate.c:        tcg_gen_mov_tl(cpu_R[dc->rd], v);
target-microblaze/translate.c:    mop = dc->opcode & 3;
target-microblaze/translate.c:    if (!dc->type_b) {
target-microblaze/translate.c:        rev = (dc->ir >> 9) & 1;
target-microblaze/translate.c:        ex = (dc->ir >> 10) & 1;
target-microblaze/translate.c:    if (size > 4 && (dc->tb_flags & MSR_EE_FLAG)
target-microblaze/translate.c:          && (dc->cpu->env.pvr.regs[2] & PVR2_ILL_OPCODE_EXC_MASK)) {
target-microblaze/translate.c:    LOG_DIS("s%d%s%s%s\n", size, dc->type_b ? "i" : "", rev ? "r" : "",
target-microblaze/translate.c:        tcg_gen_qemu_ld_tl(tval, swx_addr, cpu_mmu_index(&dc->cpu->env),
target-microblaze/translate.c:                cpu_abort(CPU(dc->cpu), "Invalid reverse size\n");
target-microblaze/translate.c:    tcg_gen_qemu_st_tl(cpu_R[dc->rd], *addr, cpu_mmu_index(&dc->cpu->env), mop);
target-microblaze/translate.c:    if ((dc->cpu->env.pvr.regs[2] & PVR2_UNALIGNED_EXC_MASK) && size > 1) {
target-microblaze/translate.c:        tcg_gen_movi_tl(cpu_SR[SR_PC], dc->pc);
target-microblaze/translate.c:        gen_helper_memalign(cpu_env, *addr, tcg_const_tl(dc->rd),
target-microblaze/translate.c:            cpu_abort(CPU(dc->cpu), "Unknown condition code %x.\n", cc);
target-microblaze/translate.c:    cc = EXTRACT_FIELD(dc->ir, 21, 23);
target-microblaze/translate.c:    dslot = dc->ir & (1 << 25);
target-microblaze/translate.c:    LOG_DIS("bcc%s r%d %x\n", dslot ? "d" : "", dc->ra, dc->imm);
target-microblaze/translate.c:    dc->delayed_branch = 1;
target-microblaze/translate.c:        dc->delayed_branch = 2;
target-microblaze/translate.c:        dc->tb_flags |= D_FLAG;
target-microblaze/translate.c:        tcg_gen_st_tl(tcg_const_tl(dc->type_b && (dc->tb_flags & IMM_FLAG)),
target-microblaze/translate.c:        int32_t offset = (int32_t)((int16_t)dc->imm); /* sign-extend.  */
target-microblaze/translate.c:        tcg_gen_movi_tl(env_btarget, dc->pc + offset);
target-microblaze/translate.c:        dc->jmp = JMP_DIRECT_CC;
target-microblaze/translate.c:        dc->jmp_pc = dc->pc + offset;
target-microblaze/translate.c:        dc->jmp = JMP_INDIRECT;
target-microblaze/translate.c:        tcg_gen_movi_tl(env_btarget, dc->pc);
target-microblaze/translate.c:    eval_cc(dc, cc, env_btaken, cpu_R[dc->ra], tcg_const_tl(0));
target-microblaze/translate.c:    int mem_index = cpu_mmu_index(&dc->cpu->env);
target-microblaze/translate.c:    dslot = dc->ir & (1 << 20);
target-microblaze/translate.c:    abs = dc->ir & (1 << 19);
target-microblaze/translate.c:    link = dc->ir & (1 << 18);
target-microblaze/translate.c:    mbar = (dc->ir >> 16) & 31;
target-microblaze/translate.c:    if (mbar == 2 && dc->imm == 4) {
target-microblaze/translate.c:        if (dc->rd & 16) {
target-microblaze/translate.c:            tcg_gen_movi_tl(cpu_SR[SR_PC], dc->pc + 4);
target-microblaze/translate.c:        LOG_DIS("mbar %d\n", dc->rd);
target-microblaze/translate.c:        dc->cpustate_changed = 1;
target-microblaze/translate.c:             dc->type_b ? "i" : "", dslot ? "d" : "",
target-microblaze/translate.c:             dc->imm);
target-microblaze/translate.c:    dc->delayed_branch = 1;
target-microblaze/translate.c:        dc->delayed_branch = 2;
target-microblaze/translate.c:        dc->tb_flags |= D_FLAG;
target-microblaze/translate.c:        tcg_gen_st_tl(tcg_const_tl(dc->type_b && (dc->tb_flags & IMM_FLAG)),
target-microblaze/translate.c:    if (link && dc->rd)
target-microblaze/translate.c:        tcg_gen_movi_tl(cpu_R[dc->rd], dc->pc);
target-microblaze/translate.c:    dc->jmp = JMP_INDIRECT;
target-microblaze/translate.c:            if (!(dc->tb_flags & IMM_FLAG) && (dc->imm == 8 || dc->imm == 0x18))
target-microblaze/translate.c:            if (dc->imm == 0) {
target-microblaze/translate.c:                if ((dc->tb_flags & MSR_EE_FLAG) && mem_index == MMU_USER_IDX) {
target-microblaze/translate.c:            dc->jmp = JMP_DIRECT;
target-microblaze/translate.c:            dc->jmp_pc = dc->pc + (int32_t)((int16_t)dc->imm);
target-microblaze/translate.c:            tcg_gen_movi_tl(env_btarget, dc->pc);
target-microblaze/translate.c:    dc->tb_flags &= ~DRTI_FLAG;
target-microblaze/translate.c:    dc->tb_flags &= ~DRTB_FLAG;
target-microblaze/translate.c:    dc->tb_flags &= ~DRTE_FLAG;
target-microblaze/translate.c:    int mem_index = cpu_mmu_index(&dc->cpu->env);
target-microblaze/translate.c:    i_bit = dc->ir & (1 << 21);
target-microblaze/translate.c:    b_bit = dc->ir & (1 << 22);
target-microblaze/translate.c:    e_bit = dc->ir & (1 << 23);
target-microblaze/translate.c:    dc->delayed_branch = 2;
target-microblaze/translate.c:    dc->tb_flags |= D_FLAG;
target-microblaze/translate.c:    tcg_gen_st_tl(tcg_const_tl(dc->type_b && (dc->tb_flags & IMM_FLAG)),
target-microblaze/translate.c:        LOG_DIS("rtid ir=%x\n", dc->ir);
target-microblaze/translate.c:        if ((dc->tb_flags & MSR_EE_FLAG)
target-microblaze/translate.c:        dc->tb_flags |= DRTI_FLAG;
target-microblaze/translate.c:        LOG_DIS("rtbd ir=%x\n", dc->ir);
target-microblaze/translate.c:        if ((dc->tb_flags & MSR_EE_FLAG)
target-microblaze/translate.c:        dc->tb_flags |= DRTB_FLAG;
target-microblaze/translate.c:        LOG_DIS("rted ir=%x\n", dc->ir);
target-microblaze/translate.c:        if ((dc->tb_flags & MSR_EE_FLAG)
target-microblaze/translate.c:        dc->tb_flags |= DRTE_FLAG;
target-microblaze/translate.c:        LOG_DIS("rts ir=%x\n", dc->ir);
target-microblaze/translate.c:    dc->jmp = JMP_INDIRECT;
target-microblaze/translate.c:    tcg_gen_add_tl(env_btarget, cpu_R[dc->ra], *(dec_alu_op_b(dc)));
target-microblaze/translate.c:    r = dc->cpu->env.pvr.regs[2] & PVR2_USE_FPU2_MASK;
target-microblaze/translate.c:    if (!r && (dc->tb_flags & MSR_EE_FLAG)) {
target-microblaze/translate.c:    if ((dc->tb_flags & MSR_EE_FLAG)
target-microblaze/translate.c:          && (dc->cpu->env.pvr.regs[2] & PVR2_ILL_OPCODE_EXC_MASK)
target-microblaze/translate.c:          && !((dc->cpu->env.pvr.regs[2] & PVR2_USE_FPU_MASK))) {
target-microblaze/translate.c:    fpu_insn = (dc->ir >> 7) & 7;
target-microblaze/translate.c:            gen_helper_fadd(cpu_R[dc->rd], cpu_env, cpu_R[dc->ra],
target-microblaze/translate.c:                            cpu_R[dc->rb]);
target-microblaze/translate.c:            gen_helper_frsub(cpu_R[dc->rd], cpu_env, cpu_R[dc->ra],
target-microblaze/translate.c:                             cpu_R[dc->rb]);
target-microblaze/translate.c:            gen_helper_fmul(cpu_R[dc->rd], cpu_env, cpu_R[dc->ra],
target-microblaze/translate.c:                            cpu_R[dc->rb]);
target-microblaze/translate.c:            gen_helper_fdiv(cpu_R[dc->rd], cpu_env, cpu_R[dc->ra],
target-microblaze/translate.c:                            cpu_R[dc->rb]);
target-microblaze/translate.c:            switch ((dc->ir >> 4) & 7) {
target-microblaze/translate.c:                    gen_helper_fcmp_un(cpu_R[dc->rd], cpu_env,
target-microblaze/translate.c:                                       cpu_R[dc->ra], cpu_R[dc->rb]);
target-microblaze/translate.c:                    gen_helper_fcmp_lt(cpu_R[dc->rd], cpu_env,
target-microblaze/translate.c:                                       cpu_R[dc->ra], cpu_R[dc->rb]);
target-microblaze/translate.c:                    gen_helper_fcmp_eq(cpu_R[dc->rd], cpu_env,
target-microblaze/translate.c:                                       cpu_R[dc->ra], cpu_R[dc->rb]);
target-microblaze/translate.c:                    gen_helper_fcmp_le(cpu_R[dc->rd], cpu_env,
target-microblaze/translate.c:                                       cpu_R[dc->ra], cpu_R[dc->rb]);
target-microblaze/translate.c:                    gen_helper_fcmp_gt(cpu_R[dc->rd], cpu_env,
target-microblaze/translate.c:                                       cpu_R[dc->ra], cpu_R[dc->rb]);
target-microblaze/translate.c:                    gen_helper_fcmp_ne(cpu_R[dc->rd], cpu_env,
target-microblaze/translate.c:                                       cpu_R[dc->ra], cpu_R[dc->rb]);
target-microblaze/translate.c:                    gen_helper_fcmp_ge(cpu_R[dc->rd], cpu_env,
target-microblaze/translate.c:                                       cpu_R[dc->ra], cpu_R[dc->rb]);
target-microblaze/translate.c:                                  fpu_insn, dc->pc, dc->opcode);
target-microblaze/translate.c:                    dc->abort_at_next_insn = 1;
target-microblaze/translate.c:            gen_helper_flt(cpu_R[dc->rd], cpu_env, cpu_R[dc->ra]);
target-microblaze/translate.c:            gen_helper_fint(cpu_R[dc->rd], cpu_env, cpu_R[dc->ra]);
target-microblaze/translate.c:            gen_helper_fsqrt(cpu_R[dc->rd], cpu_env, cpu_R[dc->ra]);
target-microblaze/translate.c:                          fpu_insn, dc->pc, dc->opcode);
target-microblaze/translate.c:            dc->abort_at_next_insn = 1;
target-microblaze/translate.c:    if ((dc->tb_flags & MSR_EE_FLAG)
target-microblaze/translate.c:          && (dc->cpu->env.pvr.regs[2] & PVR2_ILL_OPCODE_EXC_MASK)) {
target-microblaze/translate.c:    qemu_log ("unknown insn pc=%x opc=%x\n", dc->pc, dc->opcode);
target-microblaze/translate.c:    dc->abort_at_next_insn = 1;
target-microblaze/translate.c:    int mem_index = cpu_mmu_index(&dc->cpu->env);
target-microblaze/translate.c:    LOG_DIS("%s%s imm=%x\n", dc->rd ? "get" : "put",
target-microblaze/translate.c:            dc->type_b ? "" : "d", dc->imm);
target-microblaze/translate.c:    if ((dc->tb_flags & MSR_EE_FLAG) && (mem_index == MMU_USER_IDX)) {
target-microblaze/translate.c:    if (dc->type_b) {
target-microblaze/translate.c:        tcg_gen_movi_tl(t_id, dc->imm & 0xf);
target-microblaze/translate.c:        ctrl = dc->imm >> 10;
target-microblaze/translate.c:        tcg_gen_andi_tl(t_id, cpu_R[dc->rb], 0xf);
target-microblaze/translate.c:        ctrl = dc->imm >> 5;
target-microblaze/translate.c:    if (dc->rd == 0) {
target-microblaze/translate.c:        gen_helper_put(t_id, t_ctrl, cpu_R[dc->ra]);
target-microblaze/translate.c:        gen_helper_get(cpu_R[dc->rd], t_id, t_ctrl);
target-microblaze/translate.c:        tcg_gen_debug_insn_start(dc->pc);
target-microblaze/translate.c:    dc->ir = ir;
target-microblaze/translate.c:    LOG_DIS("%8.8x\t", dc->ir);
target-microblaze/translate.c:    if (dc->ir)
target-microblaze/translate.c:        dc->nr_nops = 0;
target-microblaze/translate.c:        if ((dc->tb_flags & MSR_EE_FLAG)
target-microblaze/translate.c:              && (dc->cpu->env.pvr.regs[2] & PVR2_ILL_OPCODE_EXC_MASK)
target-microblaze/translate.c:              && (dc->cpu->env.pvr.regs[2] & PVR2_OPCODE_0x0_ILL_MASK)) {
target-microblaze/translate.c:        LOG_DIS("nr_nops=%d\t", dc->nr_nops);
target-microblaze/translate.c:        dc->nr_nops++;
target-microblaze/translate.c:        if (dc->nr_nops > 4) {
target-microblaze/translate.c:            cpu_abort(CPU(dc->cpu), "fetching nop sequence\n");
target-microblaze/translate.c:    dc->type_b = ir & (1 << 29);
target-microblaze/translate.c:    dc->opcode = EXTRACT_FIELD(ir, 26, 31);
target-microblaze/translate.c:    dc->rd = EXTRACT_FIELD(ir, 21, 25);
target-microblaze/translate.c:    dc->ra = EXTRACT_FIELD(ir, 16, 20);
target-microblaze/translate.c:    dc->rb = EXTRACT_FIELD(ir, 11, 15);
target-microblaze/translate.c:    dc->imm = EXTRACT_FIELD(ir, 0, 15);
target-microblaze/translate.c:        if ((dc->opcode & decinfo[i].mask) == decinfo[i].bits) {
target-microblaze/translate.c:            if (bp->pc == dc->pc) {
target-microblaze/translate.c:                dc->is_jmp = DISAS_UPDATE;
target-microblaze/translate.c:    dc->cpu = cpu;
target-microblaze/translate.c:    dc->tb = tb;
target-microblaze/translate.c:    org_flags = dc->synced_flags = dc->tb_flags = tb->flags;
target-microblaze/translate.c:    dc->is_jmp = DISAS_NEXT;
target-microblaze/translate.c:    dc->jmp = 0;
target-microblaze/translate.c:    dc->delayed_branch = !!(dc->tb_flags & D_FLAG);
target-microblaze/translate.c:    if (dc->delayed_branch) {
target-microblaze/translate.c:        dc->jmp = JMP_INDIRECT;
target-microblaze/translate.c:    dc->pc = pc_start;
target-microblaze/translate.c:    dc->singlestep_enabled = cs->singlestep_enabled;
target-microblaze/translate.c:    dc->cpustate_changed = 0;
target-microblaze/translate.c:    dc->abort_at_next_insn = 0;
target-microblaze/translate.c:    dc->nr_nops = 0;
target-microblaze/translate.c:            tcg_gen_movi_tl(cpu_SR[SR_PC], dc->pc);
target-microblaze/translate.c:            tcg_ctx.gen_opc_pc[lj] = dc->pc;
target-microblaze/translate.c:        LOG_DIS("%8.8x:\t", dc->pc);
target-microblaze/translate.c:        dc->clear_imm = 1;
target-microblaze/translate.c:        decode(dc, cpu_ldl_code(env, dc->pc));
target-microblaze/translate.c:        if (dc->clear_imm)
target-microblaze/translate.c:            dc->tb_flags &= ~IMM_FLAG;
target-microblaze/translate.c:        dc->pc += 4;
target-microblaze/translate.c:        if (dc->delayed_branch) {
target-microblaze/translate.c:            dc->delayed_branch--;
target-microblaze/translate.c:            if (!dc->delayed_branch) {
target-microblaze/translate.c:                if (dc->tb_flags & DRTI_FLAG)
target-microblaze/translate.c:                 if (dc->tb_flags & DRTB_FLAG)
target-microblaze/translate.c:                if (dc->tb_flags & DRTE_FLAG)
target-microblaze/translate.c:                dc->tb_flags &= ~D_FLAG;
target-microblaze/translate.c:                if (dc->jmp == JMP_INDIRECT) {
target-microblaze/translate.c:                    eval_cond_jmp(dc, env_btarget, tcg_const_tl(dc->pc));
target-microblaze/translate.c:                    dc->is_jmp = DISAS_JUMP;
target-microblaze/translate.c:                } else if (dc->jmp == JMP_DIRECT) {
target-microblaze/translate.c:                    gen_goto_tb(dc, 0, dc->jmp_pc);
target-microblaze/translate.c:                    dc->is_jmp = DISAS_TB_JUMP;
target-microblaze/translate.c:                } else if (dc->jmp == JMP_DIRECT_CC) {
target-microblaze/translate.c:                    gen_goto_tb(dc, 1, dc->pc);
target-microblaze/translate.c:                    gen_goto_tb(dc, 0, dc->jmp_pc);
target-microblaze/translate.c:                    dc->is_jmp = DISAS_TB_JUMP;
target-microblaze/translate.c:    } while (!dc->is_jmp && !dc->cpustate_changed
target-microblaze/translate.c:         && (dc->pc < next_page_start)
target-microblaze/translate.c:    npc = dc->pc;
target-microblaze/translate.c:    if (dc->jmp == JMP_DIRECT || dc->jmp == JMP_DIRECT_CC) {
target-microblaze/translate.c:        if (dc->tb_flags & D_FLAG) {
target-microblaze/translate.c:            dc->is_jmp = DISAS_UPDATE;
target-microblaze/translate.c:            npc = dc->jmp_pc;
target-microblaze/translate.c:    if (dc->is_jmp == DISAS_NEXT
target-microblaze/translate.c:        && (dc->cpustate_changed || org_flags != dc->tb_flags)) {
target-microblaze/translate.c:        dc->is_jmp = DISAS_UPDATE;
target-microblaze/translate.c:        if (dc->is_jmp != DISAS_JUMP) {
target-microblaze/translate.c:        switch(dc->is_jmp) {
target-microblaze/translate.c:        tb->size = dc->pc - pc_start;
target-microblaze/translate.c:        log_target_disas(env, pc_start, dc->pc - pc_start, 0);
target-microblaze/translate.c:            dc->pc - pc_start, tcg_ctx.gen_opc_ptr -
target-microblaze/translate.c:    assert(!dc->abort_at_next_insn);
target-microblaze/cpu.c:    mcc->parent_realize = dc->realize;
target-microblaze/cpu.c:    dc->realize = mb_cpu_realizefn;
target-microblaze/cpu.c:    dc->vmsd = &vmstate_mb_cpu;
target-microblaze/cpu.c:    dc->props = mb_properties;
target-mips/cpu.c:    mcc->parent_realize = dc->realize;
target-mips/cpu.c:    dc->realize = mips_cpu_realizefn;
target-moxie/cpu.c:    mcc->parent_realize = dc->realize;
target-moxie/cpu.c:    dc->realize = moxie_cpu_realizefn;
target-openrisc/translate.c:    if (dc->tb_flags != dc->synced_flags) {
target-openrisc/translate.c:        tcg_gen_movi_tl(env_flags, dc->tb_flags);
target-openrisc/translate.c:        dc->synced_flags = dc->tb_flags;
target-openrisc/translate.c:    tcg_gen_movi_tl(cpu_pc, dc->pc);
target-openrisc/translate.c:    dc->is_jmp = DISAS_UPDATE;
target-openrisc/translate.c:    if (!(dc->flags & CPUCFGR_OB64S)) {
target-openrisc/translate.c:    if (!(dc->flags & CPUCFGR_OF64S)) {
target-openrisc/translate.c:    if (!(dc->flags & CPUCFGR_OV64S)) {
target-openrisc/translate.c:    tb = dc->tb;
target-openrisc/translate.c:                                       likely(!dc->singlestep_enabled)) {
target-openrisc/translate.c:        if (dc->singlestep_enabled) {
target-openrisc/translate.c:    tmp_pc = sign_extend((imm<<2), 26) + dc->pc;
target-openrisc/translate.c:        tcg_gen_movi_tl(cpu_R[9], (dc->pc + 8));
target-openrisc/translate.c:            tcg_gen_movi_tl(jmp_pc, dc->pc+8);
target-openrisc/translate.c:        tcg_gen_movi_tl(cpu_R[9], (dc->pc + 8));
target-openrisc/translate.c:    dc->delayed_branch = 2;
target-openrisc/translate.c:    dc->tb_flags |= D_FLAG;
target-openrisc/translate.c:            if (dc->mem_idx == MMU_USER_IDX) {
target-openrisc/translate.c:            dc->is_jmp = DISAS_UPDATE;
target-openrisc/translate.c:            tcg_gen_qemu_ld_tl(cpu_R[rd], t0, dc->mem_idx, mop);
target-openrisc/translate.c:            if (dc->mem_idx == MMU_USER_IDX) {
target-openrisc/translate.c:            if (dc->mem_idx == MMU_USER_IDX) {
target-openrisc/translate.c:            tcg_gen_qemu_st_tl(cpu_R[rb], t0, dc->mem_idx, mop);
target-openrisc/translate.c:        tcg_gen_movi_tl(cpu_pc, dc->pc);
target-openrisc/translate.c:        dc->is_jmp = DISAS_UPDATE;
target-openrisc/translate.c:        if (dc->mem_idx == MMU_USER_IDX) {
target-openrisc/translate.c:        tcg_gen_movi_tl(cpu_pc, dc->pc);
target-openrisc/translate.c:        if (dc->mem_idx == MMU_USER_IDX) {
target-openrisc/translate.c:        if (dc->mem_idx == MMU_USER_IDX) {
target-openrisc/translate.c:        if (dc->mem_idx == MMU_USER_IDX) {
target-openrisc/translate.c:    insn = cpu_ldl_code(&cpu->env, dc->pc);
target-openrisc/translate.c:            if (bp->pc == dc->pc) {
target-openrisc/translate.c:                tcg_gen_movi_tl(cpu_pc, dc->pc);
target-openrisc/translate.c:                dc->is_jmp = DISAS_UPDATE;
target-openrisc/translate.c:    dc->tb = tb;
target-openrisc/translate.c:    dc->is_jmp = DISAS_NEXT;
target-openrisc/translate.c:    dc->ppc = pc_start;
target-openrisc/translate.c:    dc->pc = pc_start;
target-openrisc/translate.c:    dc->flags = cpu->env.cpucfgr;
target-openrisc/translate.c:    dc->mem_idx = cpu_mmu_index(&cpu->env);
target-openrisc/translate.c:    dc->synced_flags = dc->tb_flags = tb->flags;
target-openrisc/translate.c:    dc->delayed_branch = !!(dc->tb_flags & D_FLAG);
target-openrisc/translate.c:    dc->singlestep_enabled = cs->singlestep_enabled;
target-openrisc/translate.c:            tcg_ctx.gen_opc_pc[k] = dc->pc;
target-openrisc/translate.c:            tcg_gen_debug_insn_start(dc->pc);
target-openrisc/translate.c:        dc->ppc = dc->pc - 4;
target-openrisc/translate.c:        dc->npc = dc->pc + 4;
target-openrisc/translate.c:        tcg_gen_movi_tl(cpu_ppc, dc->ppc);
target-openrisc/translate.c:        tcg_gen_movi_tl(cpu_npc, dc->npc);
target-openrisc/translate.c:        dc->pc = dc->npc;
target-openrisc/translate.c:        if (dc->delayed_branch) {
target-openrisc/translate.c:            dc->delayed_branch--;
target-openrisc/translate.c:            if (!dc->delayed_branch) {
target-openrisc/translate.c:                dc->tb_flags &= ~D_FLAG;
target-openrisc/translate.c:                dc->is_jmp = DISAS_JUMP;
target-openrisc/translate.c:    } while (!dc->is_jmp
target-openrisc/translate.c:             && (dc->pc < next_page_start)
target-openrisc/translate.c:    if (dc->is_jmp == DISAS_NEXT) {
target-openrisc/translate.c:        dc->is_jmp = DISAS_UPDATE;
target-openrisc/translate.c:        tcg_gen_movi_tl(cpu_pc, dc->pc);
target-openrisc/translate.c:        if (dc->is_jmp == DISAS_NEXT) {
target-openrisc/translate.c:            tcg_gen_movi_tl(cpu_pc, dc->pc);
target-openrisc/translate.c:        switch (dc->is_jmp) {
target-openrisc/translate.c:            gen_goto_tb(dc, 0, dc->pc);
target-openrisc/translate.c:        tb->size = dc->pc - pc_start;
target-openrisc/translate.c:        log_target_disas(&cpu->env, pc_start, dc->pc - pc_start, 0);
target-openrisc/translate.c:            dc->pc - pc_start, tcg_ctx.gen_opc_ptr -
target-openrisc/cpu.c:    occ->parent_realize = dc->realize;
target-openrisc/cpu.c:    dc->realize = openrisc_cpu_realizefn;
target-openrisc/cpu.c:    dc->vmsd = &vmstate_openrisc_cpu;
target-ppc/translate_init.c:    dc->desc = "PowerPC 401";
target-ppc/translate_init.c:    dc->desc = "PowerPC 401x2";
target-ppc/translate_init.c:    dc->desc = "PowerPC 401x3";
target-ppc/translate_init.c:    dc->desc = "IOP480";
target-ppc/translate_init.c:    dc->desc = "PowerPC 403";
target-ppc/translate_init.c:    dc->desc = "PowerPC 403 GCX";
target-ppc/translate_init.c:    dc->desc = "PowerPC 405";
target-ppc/translate_init.c:    dc->desc = "PowerPC 440 EP";
target-ppc/translate_init.c:    dc->desc = "PowerPC 440 GP";
target-ppc/translate_init.c:    dc->desc = "PowerPC 440x4";
target-ppc/translate_init.c:    dc->desc = "PowerPC 440x5";
target-ppc/translate_init.c:    dc->desc = "PowerPC 460 (guessed)";
target-ppc/translate_init.c:    dc->desc = "PowerPC 460F (guessed)";
target-ppc/translate_init.c:    dc->desc = "Freescale 5xx cores (aka RCPU)";
target-ppc/translate_init.c:    dc->desc = "Freescale 8xx cores (aka PowerQUICC)";
target-ppc/translate_init.c:    dc->desc = "PowerPC G2";
target-ppc/translate_init.c:    dc->desc = "PowerPC G2LE";
target-ppc/translate_init.c:    dc->desc = "e200 core";
target-ppc/translate_init.c:    dc->desc = "e300 core";
target-ppc/translate_init.c:    dc->desc = "e500v1 core";
target-ppc/translate_init.c:    dc->desc = "e500v2 core";
target-ppc/translate_init.c:    dc->desc = "e500mc core";
target-ppc/translate_init.c:    dc->desc = "e5500 core";
target-ppc/translate_init.c:    dc->desc = "POWER";
target-ppc/translate_init.c:    dc->desc = "PowerPC 601";
target-ppc/translate_init.c:    dc->desc = "PowerPC 601v";
target-ppc/translate_init.c:    dc->desc = "PowerPC 602";
target-ppc/translate_init.c:    dc->desc = "PowerPC 603";
target-ppc/translate_init.c:    dc->desc = "PowerPC 603e";
target-ppc/translate_init.c:    dc->desc = "PowerPC 604";
target-ppc/translate_init.c:    dc->desc = "PowerPC 604E";
target-ppc/translate_init.c:    dc->desc = "PowerPC 740";
target-ppc/translate_init.c:    dc->desc = "PowerPC 750";
target-ppc/translate_init.c:    dc->desc = "PowerPC 750 CL";
target-ppc/translate_init.c:    dc->desc = "PowerPC 750CX";
target-ppc/translate_init.c:    dc->desc = "PowerPC 750FX";
target-ppc/translate_init.c:    dc->desc = "PowerPC 750GX";
target-ppc/translate_init.c:    dc->desc = "PowerPC 745";
target-ppc/translate_init.c:    dc->desc = "PowerPC 755";
target-ppc/translate_init.c:    dc->desc = "PowerPC 7400 (aka G4)";
target-ppc/translate_init.c:    dc->desc = "PowerPC 7410 (aka G4)";
target-ppc/translate_init.c:    dc->desc = "PowerPC 7440 (aka G4)";
target-ppc/translate_init.c:    dc->desc = "PowerPC 7450 (aka G4)";
target-ppc/translate_init.c:    dc->desc = "PowerPC 7445 (aka G4)";
target-ppc/translate_init.c:    dc->desc = "PowerPC 7455 (aka G4)";
target-ppc/translate_init.c:    dc->desc = "PowerPC 7457 (aka G4)";
target-ppc/translate_init.c:    dc->desc = "PowerPC e600";
target-ppc/translate_init.c:    dc->desc = "PowerPC 970";
target-ppc/translate_init.c:    dc->desc = "PowerPC 970FX (aka G5)";
target-ppc/translate_init.c:    dc->desc = "PowerPC 970 MP";
target-ppc/translate_init.c:    dc->fw_name = "PowerPC,POWER5";
target-ppc/translate_init.c:    dc->desc = "POWER5+";
target-ppc/translate_init.c:    dc->fw_name = "PowerPC,POWER7";
target-ppc/translate_init.c:    dc->desc = "POWER7";
target-ppc/translate_init.c:    dc->fw_name = "PowerPC,POWER7+";
target-ppc/translate_init.c:    dc->desc = "POWER7+";
target-ppc/translate_init.c:    dc->fw_name = "PowerPC,POWER8";
target-ppc/translate_init.c:    dc->desc = "POWER8";
target-ppc/translate_init.c:    pcc->parent_realize = dc->realize;
target-ppc/translate_init.c:    dc->realize = ppc_cpu_realizefn;
target-ppc/translate_init.c:    dc->unrealize = ppc_cpu_unrealizefn;
target-ppc/translate_init.c:    dc->fw_name = "PowerPC,UNKNOWN";
target-ppc/cpu-models.c:        dc->desc          = _desc;                                          \
target-s390x/cpu.c:    scc->parent_realize = dc->realize;
target-s390x/cpu.c:    dc->realize = s390_cpu_realizefn;
target-s390x/cpu.c:    dc->vmsd = &vmstate_s390_cpu;
target-sh4/cpu.c:    scc->parent_realize = dc->realize;
target-sh4/cpu.c:    dc->realize = superh_cpu_realizefn;
target-sh4/cpu.c:    dc->vmsd = &vmstate_sh_cpu;
target-sparc/translate.c:    assert(dc->n_t32 < ARRAY_SIZE(dc->t32));
target-sparc/translate.c:    dc->t32[dc->n_t32++] = t = tcg_temp_new_i32();
target-sparc/translate.c:    assert(dc->n_ttl < ARRAY_SIZE(dc->ttl));
target-sparc/translate.c:    dc->ttl[dc->n_ttl++] = t = tcg_temp_new();
target-sparc/translate.c:#define supervisor(dc) (dc->mem_idx >= MMU_KERNEL_IDX)
target-sparc/translate.c:#define hypervisor(dc) (dc->mem_idx == MMU_HYPV_IDX)
target-sparc/translate.c:    switch (dc->cc_op) {
target-sparc/translate.c:        dc->cc_op = CC_OP_ADDX;
target-sparc/translate.c:        dc->cc_op = CC_OP_LOGIC;
target-sparc/translate.c:        dc->cc_op = CC_OP_SUB;
target-sparc/translate.c:    switch (dc->cc_op) {
target-sparc/translate.c:        dc->cc_op = CC_OP_SUBX;
target-sparc/translate.c:    TCGv npc0 = tcg_const_tl(dc->jump_pc[0]);
target-sparc/translate.c:    TCGv npc1 = tcg_const_tl(dc->jump_pc[1]);
target-sparc/translate.c:    if (dc->npc == JUMP_PC) {
target-sparc/translate.c:        dc->npc = DYNAMIC_PC;
target-sparc/translate.c:    if (dc->npc == JUMP_PC) {
target-sparc/translate.c:        dc->npc = DYNAMIC_PC;
target-sparc/translate.c:    } else if (dc->npc != DYNAMIC_PC) {
target-sparc/translate.c:        tcg_gen_movi_tl(cpu_npc, dc->npc);
target-sparc/translate.c:    if (dc->cc_op != CC_OP_FLAGS) {
target-sparc/translate.c:        dc->cc_op = CC_OP_FLAGS;
target-sparc/translate.c:    tcg_gen_movi_tl(cpu_pc, dc->pc);
target-sparc/translate.c:    if (dc->npc == JUMP_PC) {
target-sparc/translate.c:        dc->pc = DYNAMIC_PC;
target-sparc/translate.c:    } else if (dc->npc == DYNAMIC_PC) {
target-sparc/translate.c:        dc->pc = DYNAMIC_PC;
target-sparc/translate.c:        dc->pc = dc->npc;
target-sparc/translate.c:    switch (dc->cc_op) {
target-sparc/translate.c:        dc->cc_op = CC_OP_FLAGS;
target-sparc/translate.c:    target_ulong target = dc->pc + offset;
target-sparc/translate.c:            dc->pc = dc->npc + 4;
target-sparc/translate.c:            dc->npc = dc->pc + 4;
target-sparc/translate.c:            dc->pc = dc->npc;
target-sparc/translate.c:            dc->npc = dc->pc + 4;
target-sparc/translate.c:            dc->pc = target;
target-sparc/translate.c:            dc->npc = dc->pc + 4;
target-sparc/translate.c:            dc->pc = dc->npc;
target-sparc/translate.c:            dc->npc = target;
target-sparc/translate.c:            gen_branch_a(dc, target, dc->npc, cpu_cond);
target-sparc/translate.c:            dc->is_br = 1;
target-sparc/translate.c:            dc->pc = dc->npc;
target-sparc/translate.c:            dc->jump_pc[0] = target;
target-sparc/translate.c:            if (unlikely(dc->npc == DYNAMIC_PC)) {
target-sparc/translate.c:                dc->jump_pc[1] = DYNAMIC_PC;
target-sparc/translate.c:                dc->jump_pc[1] = dc->npc + 4;
target-sparc/translate.c:                dc->npc = JUMP_PC;
target-sparc/translate.c:    target_ulong target = dc->pc + offset;
target-sparc/translate.c:            dc->pc = dc->npc + 4;
target-sparc/translate.c:            dc->npc = dc->pc + 4;
target-sparc/translate.c:            dc->pc = dc->npc;
target-sparc/translate.c:            dc->npc = dc->pc + 4;
target-sparc/translate.c:            dc->pc = target;
target-sparc/translate.c:            dc->npc = dc->pc + 4;
target-sparc/translate.c:            dc->pc = dc->npc;
target-sparc/translate.c:            dc->npc = target;
target-sparc/translate.c:            gen_branch_a(dc, target, dc->npc, cpu_cond);
target-sparc/translate.c:            dc->is_br = 1;
target-sparc/translate.c:            dc->pc = dc->npc;
target-sparc/translate.c:            dc->jump_pc[0] = target;
target-sparc/translate.c:            if (unlikely(dc->npc == DYNAMIC_PC)) {
target-sparc/translate.c:                dc->jump_pc[1] = DYNAMIC_PC;
target-sparc/translate.c:                dc->jump_pc[1] = dc->npc + 4;
target-sparc/translate.c:                dc->npc = JUMP_PC;
target-sparc/translate.c:    target_ulong target = dc->pc + offset;
target-sparc/translate.c:        gen_branch_a(dc, target, dc->npc, cpu_cond);
target-sparc/translate.c:        dc->is_br = 1;
target-sparc/translate.c:        dc->pc = dc->npc;
target-sparc/translate.c:        dc->jump_pc[0] = target;
target-sparc/translate.c:        if (unlikely(dc->npc == DYNAMIC_PC)) {
target-sparc/translate.c:            dc->jump_pc[1] = DYNAMIC_PC;
target-sparc/translate.c:            dc->jump_pc[1] = dc->npc + 4;
target-sparc/translate.c:            dc->npc = JUMP_PC;
target-sparc/translate.c:    if (!dc->fpu_enabled) {
target-sparc/translate.c:        dc->is_br = 1;
target-sparc/translate.c:        dc->cc_op = CC_OP_SUB;
target-sparc/translate.c:/* before an instruction, dc->pc must be static */
target-sparc/translate.c:        tcg_gen_debug_insn_start(dc->pc);
target-sparc/translate.c:            tcg_gen_movi_tl(o7, dc->pc);
target-sparc/translate.c:            target += dc->pc;
target-sparc/translate.c:            dc->npc = target;
target-sparc/translate.c:                mask = ((dc->def->features & CPU_FEATURE_HYPV) && supervisor(dc)
target-sparc/translate.c:                    dc->is_br = 1;
target-sparc/translate.c:                    if (rs1 == 0x11 && dc->def->features & CPU_FEATURE_ASR17) {
target-sparc/translate.c:                        tcg_gen_movi_tl(t, (1 << 8) | (dc->def->nwindows - 1));
target-sparc/translate.c:                            tcg_gen_movi_tl(t, dc->pc & 0xffffffffULL);
target-sparc/translate.c:                            tcg_gen_movi_tl(t, dc->pc);
target-sparc/translate.c:                            dc->cc_op = CC_OP_ADD;
target-sparc/translate.c:                            dc->cc_op = CC_OP_LOGIC;
target-sparc/translate.c:                            dc->cc_op = CC_OP_LOGIC;
target-sparc/translate.c:                            dc->cc_op = CC_OP_LOGIC;
target-sparc/translate.c:                            dc->cc_op = CC_OP_SUB;
target-sparc/translate.c:                            dc->cc_op = CC_OP_LOGIC;
target-sparc/translate.c:                            dc->cc_op = CC_OP_LOGIC;
target-sparc/translate.c:                            dc->cc_op = CC_OP_LOGIC;
target-sparc/translate.c:                            dc->cc_op = CC_OP_LOGIC;
target-sparc/translate.c:                            dc->cc_op = CC_OP_LOGIC;
target-sparc/translate.c:                            dc->cc_op = CC_OP_DIV;
target-sparc/translate.c:                            dc->cc_op = CC_OP_DIV;
target-sparc/translate.c:                        dc->cc_op = CC_OP_TADD;
target-sparc/translate.c:                        dc->cc_op = CC_OP_TSUB;
target-sparc/translate.c:                        dc->cc_op = CC_OP_TADDTV;
target-sparc/translate.c:                        dc->cc_op = CC_OP_TSUBTV;
target-sparc/translate.c:                        dc->cc_op = CC_OP_ADD;
target-sparc/translate.c:                                if ((rd == 0x13) && (dc->def->features &
target-sparc/translate.c:                                dc->cc_op = CC_OP_FLAGS;
target-sparc/translate.c:                                dc->is_br = 1;
target-sparc/translate.c:                            dc->cc_op = CC_OP_FLAGS;
target-sparc/translate.c:                            dc->is_br = 1;
target-sparc/translate.c:                                dc->npc = DYNAMIC_PC;
target-sparc/translate.c:                                dc->npc = DYNAMIC_PC;
target-sparc/translate.c:                            if (dc->def->nwindows != 32) {
target-sparc/translate.c:                                                (1 << dc->def->nwindows) - 1);
target-sparc/translate.c:                                dc->is_br = 1;
target-sparc/translate.c:                dc->npc = DYNAMIC_PC;
target-sparc/translate.c:                        tcg_gen_movi_tl(t, dc->pc);
target-sparc/translate.c:                        dc->npc = DYNAMIC_PC;
target-sparc/translate.c:                        dc->npc = DYNAMIC_PC;
target-sparc/translate.c:                            dc->npc = DYNAMIC_PC;
target-sparc/translate.c:                            dc->pc = DYNAMIC_PC;
target-sparc/translate.c:                            dc->npc = DYNAMIC_PC;
target-sparc/translate.c:                            dc->pc = DYNAMIC_PC;
target-sparc/translate.c:                    tcg_gen_qemu_ld32u(cpu_val, cpu_addr, dc->mem_idx);
target-sparc/translate.c:                    tcg_gen_qemu_ld8u(cpu_val, cpu_addr, dc->mem_idx);
target-sparc/translate.c:                    tcg_gen_qemu_ld16u(cpu_val, cpu_addr, dc->mem_idx);
target-sparc/translate.c:                        tcg_gen_qemu_ld64(t64, cpu_addr, dc->mem_idx);
target-sparc/translate.c:                    tcg_gen_qemu_ld8s(cpu_val, cpu_addr, dc->mem_idx);
target-sparc/translate.c:                    tcg_gen_qemu_ld16s(cpu_val, cpu_addr, dc->mem_idx);
target-sparc/translate.c:                        tcg_gen_qemu_ld8s(cpu_val, cpu_addr, dc->mem_idx);
target-sparc/translate.c:                        tcg_gen_qemu_st8(r_const, cpu_addr, dc->mem_idx);
target-sparc/translate.c:                        tcg_gen_qemu_ld32u(t0, cpu_addr, dc->mem_idx);
target-sparc/translate.c:                        tcg_gen_qemu_st32(cpu_src1, cpu_addr, dc->mem_idx);
target-sparc/translate.c:                    tcg_gen_qemu_ld32s(cpu_val, cpu_addr, dc->mem_idx);
target-sparc/translate.c:                    tcg_gen_qemu_ld64(cpu_val, cpu_addr, dc->mem_idx);
target-sparc/translate.c:                    tcg_gen_qemu_ld32u(t0, cpu_addr, dc->mem_idx);
target-sparc/translate.c:                        tcg_gen_qemu_ld64(t64, cpu_addr, dc->mem_idx);
target-sparc/translate.c:                    tcg_gen_qemu_ld32u(t0, cpu_addr, dc->mem_idx);
target-sparc/translate.c:                        r_const = tcg_const_i32(dc->mem_idx);
target-sparc/translate.c:                    tcg_gen_qemu_ld64(cpu_dst_64, cpu_addr, dc->mem_idx);
target-sparc/translate.c:                    tcg_gen_qemu_st32(cpu_val, cpu_addr, dc->mem_idx);
target-sparc/translate.c:                    tcg_gen_qemu_st8(cpu_val, cpu_addr, dc->mem_idx);
target-sparc/translate.c:                    tcg_gen_qemu_st16(cpu_val, cpu_addr, dc->mem_idx);
target-sparc/translate.c:                        tcg_gen_qemu_st64(t64, cpu_addr, dc->mem_idx);
target-sparc/translate.c:                    dc->npc = DYNAMIC_PC;
target-sparc/translate.c:                    dc->npc = DYNAMIC_PC;
target-sparc/translate.c:                    dc->npc = DYNAMIC_PC;
target-sparc/translate.c:                    tcg_gen_qemu_st64(cpu_val, cpu_addr, dc->mem_idx);
target-sparc/translate.c:                    dc->npc = DYNAMIC_PC;
target-sparc/translate.c:                        tcg_gen_qemu_st32(t, cpu_addr, dc->mem_idx);
target-sparc/translate.c:                            tcg_gen_qemu_st64(t, cpu_addr, dc->mem_idx);
target-sparc/translate.c:                        tcg_gen_qemu_st32(t, cpu_addr, dc->mem_idx);
target-sparc/translate.c:                        r_const = tcg_const_i32(dc->mem_idx);
target-sparc/translate.c:                    tcg_gen_qemu_st64(cpu_src1_64, cpu_addr, dc->mem_idx);
target-sparc/translate.c:    if (dc->npc == DYNAMIC_PC) {
target-sparc/translate.c:        dc->pc = DYNAMIC_PC;
target-sparc/translate.c:    } else if (dc->npc == JUMP_PC) {
target-sparc/translate.c:        gen_branch2(dc, dc->jump_pc[0], dc->jump_pc[1], cpu_cond);
target-sparc/translate.c:        dc->is_br = 1;
target-sparc/translate.c:        dc->pc = dc->npc;
target-sparc/translate.c:        dc->npc = dc->npc + 4;
target-sparc/translate.c:        dc->is_br = 1;
target-sparc/translate.c:        dc->is_br = 1;
target-sparc/translate.c:        dc->is_br = 1;
target-sparc/translate.c:    dc->is_br = 1;
target-sparc/translate.c:    dc->is_br = 1;
target-sparc/translate.c:        dc->is_br = 1;
target-sparc/translate.c:    if (dc->n_t32 != 0) {
target-sparc/translate.c:        for (i = dc->n_t32 - 1; i >= 0; --i) {
target-sparc/translate.c:            tcg_temp_free_i32(dc->t32[i]);
target-sparc/translate.c:        dc->n_t32 = 0;
target-sparc/translate.c:    if (dc->n_ttl != 0) {
target-sparc/translate.c:        for (i = dc->n_ttl - 1; i >= 0; --i) {
target-sparc/translate.c:            tcg_temp_free(dc->ttl[i]);
target-sparc/translate.c:        dc->n_ttl = 0;
target-sparc/translate.c:    dc->tb = tb;
target-sparc/translate.c:    dc->pc = pc_start;
target-sparc/translate.c:    last_pc = dc->pc;
target-sparc/translate.c:    dc->npc = (target_ulong) tb->cs_base;
target-sparc/translate.c:    dc->cc_op = CC_OP_DYNAMIC;
target-sparc/translate.c:    dc->mem_idx = cpu_mmu_index(env);
target-sparc/translate.c:    dc->def = env->def;
target-sparc/translate.c:    dc->fpu_enabled = tb_fpu_enabled(tb->flags);
target-sparc/translate.c:    dc->address_mask_32bit = tb_am_enabled(tb->flags);
target-sparc/translate.c:    dc->singlestep = (cs->singlestep_enabled || singlestep);
target-sparc/translate.c:                if (bp->pc == dc->pc) {
target-sparc/translate.c:                    if (dc->pc != pc_start)
target-sparc/translate.c:                    dc->is_br = 1;
target-sparc/translate.c:                tcg_ctx.gen_opc_pc[lj] = dc->pc;
target-sparc/translate.c:                gen_opc_npc[lj] = dc->npc;
target-sparc/translate.c:        last_pc = dc->pc;
target-sparc/translate.c:        insn = cpu_ldl_code(env, dc->pc);
target-sparc/translate.c:        if (dc->is_br)
target-sparc/translate.c:        if (dc->pc != (last_pc + 4))
target-sparc/translate.c:        if ((dc->pc & (TARGET_PAGE_SIZE - 1)) == 0)
target-sparc/translate.c:        if (dc->singlestep) {
target-sparc/translate.c:             (dc->pc - pc_start) < (TARGET_PAGE_SIZE - 32) &&
target-sparc/translate.c:    if (!dc->is_br) {
target-sparc/translate.c:        if (dc->pc != DYNAMIC_PC &&
target-sparc/translate.c:            (dc->npc != DYNAMIC_PC && dc->npc != JUMP_PC)) {
target-sparc/translate.c:            gen_goto_tb(dc, 0, dc->pc, dc->npc);
target-sparc/translate.c:            if (dc->pc != DYNAMIC_PC) {
target-sparc/translate.c:                tcg_gen_movi_tl(cpu_pc, dc->pc);
target-sparc/translate.c:        gen_opc_jump_pc[0] = dc->jump_pc[0];
target-sparc/translate.c:        gen_opc_jump_pc[1] = dc->jump_pc[1];
target-sparc/cpu.c:    scc->parent_realize = dc->realize;
target-sparc/cpu.c:    dc->realize = sparc_cpu_realizefn;
target-unicore32/translate.c:    dc->tb = tb;
target-unicore32/translate.c:    dc->is_jmp = DISAS_NEXT;
target-unicore32/translate.c:    dc->pc = pc_start;
target-unicore32/translate.c:    dc->singlestep_enabled = cs->singlestep_enabled;
target-unicore32/translate.c:    dc->condjmp = 0;
target-unicore32/translate.c:        dc->user = 1;
target-unicore32/translate.c:        dc->user = 0;
target-unicore32/translate.c:                if (bp->pc == dc->pc) {
target-unicore32/translate.c:                    gen_set_pc_im(dc->pc);
target-unicore32/translate.c:                    dc->is_jmp = DISAS_JUMP;
target-unicore32/translate.c:                    dc->pc += 2; /* FIXME */
target-unicore32/translate.c:            tcg_ctx.gen_opc_pc[lj] = dc->pc;
target-unicore32/translate.c:            fprintf(stderr, "Internal resource leak before %08x\n", dc->pc);
target-unicore32/translate.c:        if (dc->condjmp && !dc->is_jmp) {
target-unicore32/translate.c:            gen_set_label(dc->condlabel);
target-unicore32/translate.c:            dc->condjmp = 0;
target-unicore32/translate.c:    } while (!dc->is_jmp && tcg_ctx.gen_opc_ptr < gen_opc_end &&
target-unicore32/translate.c:             dc->pc < next_page_start &&
target-unicore32/translate.c:        if (dc->condjmp) {
target-unicore32/translate.c:    /* At this stage dc->condjmp will only be set when the skipped
target-unicore32/translate.c:        if (dc->condjmp) {
target-unicore32/translate.c:            if (dc->is_jmp == DISAS_SYSCALL) {
target-unicore32/translate.c:            gen_set_label(dc->condlabel);
target-unicore32/translate.c:        if (dc->condjmp || !dc->is_jmp) {
target-unicore32/translate.c:            gen_set_pc_im(dc->pc);
target-unicore32/translate.c:            dc->condjmp = 0;
target-unicore32/translate.c:        if (dc->is_jmp == DISAS_SYSCALL && !dc->condjmp) {
target-unicore32/translate.c:        switch (dc->is_jmp) {
target-unicore32/translate.c:            gen_goto_tb(dc, 1, dc->pc);
target-unicore32/translate.c:        if (dc->condjmp) {
target-unicore32/translate.c:            gen_set_label(dc->condlabel);
target-unicore32/translate.c:            gen_goto_tb(dc, 1, dc->pc);
target-unicore32/translate.c:            dc->condjmp = 0;
target-unicore32/translate.c:        log_target_disas(env, pc_start, dc->pc - pc_start, 0);
target-unicore32/translate.c:        tb->size = dc->pc - pc_start;
target-unicore32/cpu.c:    ucc->parent_realize = dc->realize;
target-unicore32/cpu.c:    dc->realize = uc32_cpu_realizefn;
target-unicore32/cpu.c:    dc->vmsd = &vmstate_uc32_cpu;
target-xtensa/translate.c:    return xtensa_option_bits_enabled(dc->config, opt);
target-xtensa/translate.c:    return xtensa_option_enabled(dc->config, opt);
target-xtensa/translate.c:    if (dc->tb->flags & XTENSA_TBFLAG_LITBASE) {
target-xtensa/translate.c:        dc->litbase = tcg_temp_local_new_i32();
target-xtensa/translate.c:        tcg_gen_andi_i32(dc->litbase, cpu_SR[LITBASE], 0xfffff000);
target-xtensa/translate.c:    if (dc->tb->flags & XTENSA_TBFLAG_LITBASE) {
target-xtensa/translate.c:        tcg_temp_free(dc->litbase);
target-xtensa/translate.c:    dc->sar_5bit = false;
target-xtensa/translate.c:    dc->sar_m32_5bit = false;
target-xtensa/translate.c:    dc->sar_m32_allocated = false;
target-xtensa/translate.c:    if (dc->sar_m32_allocated) {
target-xtensa/translate.c:        tcg_temp_free(dc->sar_m32);
target-xtensa/translate.c:    if (dc->sar_m32_5bit) {
target-xtensa/translate.c:        tcg_gen_discard_i32(dc->sar_m32);
target-xtensa/translate.c:    dc->sar_5bit = true;
target-xtensa/translate.c:    dc->sar_m32_5bit = false;
target-xtensa/translate.c:    if (!dc->sar_m32_allocated) {
target-xtensa/translate.c:        dc->sar_m32 = tcg_temp_local_new_i32();
target-xtensa/translate.c:        dc->sar_m32_allocated = true;
target-xtensa/translate.c:    tcg_gen_andi_i32(dc->sar_m32, sa, 0x1f);
target-xtensa/translate.c:    tcg_gen_sub_i32(cpu_SR[SAR], tmp, dc->sar_m32);
target-xtensa/translate.c:    dc->sar_5bit = false;
target-xtensa/translate.c:    dc->sar_m32_5bit = true;
target-xtensa/translate.c:    if (dc->ccount_delta > 0) {
target-xtensa/translate.c:        TCGv_i32 tmp = tcg_const_i32(dc->ccount_delta);
target-xtensa/translate.c:    dc->ccount_delta = 0;
target-xtensa/translate.c:    dc->used_window = 0;
target-xtensa/translate.c:    TCGv_i32 tpc = tcg_const_i32(dc->pc);
target-xtensa/translate.c:        dc->is_jmp = DISAS_UPDATE;
target-xtensa/translate.c:    TCGv_i32 tpc = tcg_const_i32(dc->pc);
target-xtensa/translate.c:    TCGv_i32 tpc = tcg_const_i32(dc->pc);
target-xtensa/translate.c:        dc->is_jmp = DISAS_UPDATE;
target-xtensa/translate.c:    if (dc->cring) {
target-xtensa/translate.c:        dc->is_jmp = DISAS_UPDATE;
target-xtensa/translate.c:            !(dc->cpenable & (1 << cp))) {
target-xtensa/translate.c:        dc->is_jmp = DISAS_UPDATE;
target-xtensa/translate.c:    if (dc->icount) {
target-xtensa/translate.c:        tcg_gen_mov_i32(cpu_SR[ICOUNT], dc->next_icount);
target-xtensa/translate.c:    if (dc->singlestep_enabled) {
target-xtensa/translate.c:            tcg_gen_exit_tb((uintptr_t)dc->tb + slot);
target-xtensa/translate.c:    dc->is_jmp = DISAS_UPDATE;
target-xtensa/translate.c:    if (((dc->pc ^ dest) & TARGET_PAGE_MASK) != 0) {
target-xtensa/translate.c:            (callinc << 30) | (dc->next_pc & 0x3fffffff));
target-xtensa/translate.c:    if (((dc->pc ^ dest) & TARGET_PAGE_MASK) != 0) {
target-xtensa/translate.c:            !(dc->tb->flags & XTENSA_TBFLAG_EXCM) &&
target-xtensa/translate.c:            dc->next_pc == dc->lend) {
target-xtensa/translate.c:        gen_jumpi(dc, dc->lbeg, slot);
target-xtensa/translate.c:        gen_jumpi(dc, dc->next_pc, -1);
target-xtensa/translate.c:        gen_jumpi(dc, dc->next_pc, slot);
target-xtensa/translate.c:    gen_jumpi(dc, dc->pc + offset, 1);
target-xtensa/translate.c:    if (!xtensa_option_bits_enabled(dc->config, sregnames[sr].opt_bits)) {
target-xtensa/translate.c:    if (dc->sar_m32_5bit) {
target-xtensa/translate.c:        tcg_gen_discard_i32(dc->sar_m32);
target-xtensa/translate.c:    dc->sar_5bit = false;
target-xtensa/translate.c:    dc->sar_m32_5bit = false;
target-xtensa/translate.c:    tcg_gen_andi_i32(cpu_SR[sr], v, (1 << dc->config->nareg / 4) - 1);
target-xtensa/translate.c:    if (id < dc->config->nibreak) {
target-xtensa/translate.c:    if (id < dc->config->ndbreak) {
target-xtensa/translate.c:    if (id < dc->config->ndbreak) {
target-xtensa/translate.c:            dc->config->inttype_mask[INTTYPE_SOFTWARE]);
target-xtensa/translate.c:            dc->config->inttype_mask[INTTYPE_EDGE] |
target-xtensa/translate.c:            dc->config->inttype_mask[INTTYPE_NMI] |
target-xtensa/translate.c:            dc->config->inttype_mask[INTTYPE_SOFTWARE]);
target-xtensa/translate.c:    if (dc->icount) {
target-xtensa/translate.c:        tcg_gen_mov_i32(dc->next_icount, v);
target-xtensa/translate.c:    if (id < dc->config->nccompare) {
target-xtensa/translate.c:        uint32_t int_bit = 1 << dc->config->timerint[id];
target-xtensa/translate.c:    TCGv_i32 pc = tcg_const_i32(dc->next_pc);
target-xtensa/translate.c:    if (dc->tb->flags & XTENSA_TBFLAG_EXCM) {
target-xtensa/translate.c:            r1 / 4 > dc->used_window) {
target-xtensa/translate.c:        dc->used_window = r1 / 4;
target-xtensa/translate.c:                dc->config->nareg / 4, dc->config->nareg / 4);
target-xtensa/translate.c:            TCGv_i32 pc = tcg_const_i32(dc->pc);
target-xtensa/translate.c:#define TBD() qemu_log("TBD(pc = %08x): %s:%d\n", dc->pc, __FILE__, __LINE__)
target-xtensa/translate.c:                dc->pc, b0, b1, b2, __FILE__, __LINE__); \
target-xtensa/translate.c:    uint8_t b0 = cpu_ldub_code(env, dc->pc);
target-xtensa/translate.c:    uint8_t b1 = cpu_ldub_code(env, dc->pc + 1);
target-xtensa/translate.c:        dc->next_pc = dc->pc + 2;
target-xtensa/translate.c:        dc->next_pc = dc->pc + 3;
target-xtensa/translate.c:        b2 = cpu_ldub_code(env, dc->pc + 2);
target-xtensa/translate.c:                                TCGv_i32 tmp = tcg_const_i32(dc->pc);
target-xtensa/translate.c:                                tcg_gen_movi_i32(cpu_R[0], dc->next_pc);
target-xtensa/translate.c:                        TCGv_i32 pc = tcg_const_i32(dc->pc);
target-xtensa/translate.c:                                    dc->config->ndepc ? DEPC : EPC1]);
target-xtensa/translate.c:                        if (RRR_S >= 2 && RRR_S <= dc->config->nlevel) {
target-xtensa/translate.c:                    if (dc->debug) {
target-xtensa/translate.c:                        tcg_gen_movi_i32(cpu_pc, dc->pc);
target-xtensa/translate.c:                if (dc->sar_5bit) {
target-xtensa/translate.c:                if (dc->sar_m32_5bit) {
target-xtensa/translate.c:                    tcg_gen_shl_i32(cpu_R[RRR_R], cpu_R[RRR_S], dc->sar_m32);
target-xtensa/translate.c:                if (dc->sar_5bit) {
target-xtensa/translate.c:                        tcg_gen_qemu_st32(cpu_FR[RRR_R], addr, dc->cring);
target-xtensa/translate.c:                        tcg_gen_qemu_ld32u(cpu_FR[RRR_R], addr, dc->cring);
target-xtensa/translate.c:                    tcg_gen_qemu_ld32u(cpu_R[RRR_T], addr, dc->ring);
target-xtensa/translate.c:                    tcg_gen_qemu_st32(cpu_R[RRR_T], addr, dc->ring);
target-xtensa/translate.c:                    ((dc->tb->flags & XTENSA_TBFLAG_LITBASE) ?
target-xtensa/translate.c:                     0 : ((dc->pc + 3) & ~3)) +
target-xtensa/translate.c:            if (dc->tb->flags & XTENSA_TBFLAG_LITBASE) {
target-xtensa/translate.c:                tcg_gen_add_i32(tmp, tmp, dc->litbase);
target-xtensa/translate.c:            tcg_gen_qemu_ld32u(cpu_R[RRR_T], tmp, dc->cring);
target-xtensa/translate.c:            tcg_gen_qemu_##type(cpu_R[RRI8_T], addr, dc->cring); \
target-xtensa/translate.c:            tcg_gen_qemu_ld8u(res, addr, dc->cring); \
target-xtensa/translate.c:            tcg_gen_movi_i32(cpu_pc, dc->pc); \
target-xtensa/translate.c:            tcg_gen_qemu_##type(cpu_R[RRI8_T], addr, dc->cring); \
target-xtensa/translate.c:                tpc = tcg_const_i32(dc->pc);
target-xtensa/translate.c:                tcg_gen_qemu_ld32u(cpu_R[RRI8_T], addr, dc->cring);
target-xtensa/translate.c:                tcg_gen_qemu_st32(tmp, addr, dc->cring);
target-xtensa/translate.c:                    tcg_gen_qemu_st32(cpu_FR[RRI8_T], addr, dc->cring);
target-xtensa/translate.c:                    tcg_gen_qemu_ld32u(cpu_FR[RRI8_T], addr, dc->cring);
target-xtensa/translate.c:                    tcg_gen_qemu_ld32u(mem32, vaddr, dc->cring);
target-xtensa/translate.c:            tcg_gen_movi_i32(cpu_R[0], dc->next_pc);
target-xtensa/translate.c:            gen_jumpi(dc, (dc->pc & ~3) + (CALL_OFFSET_SE << 2) + 4, 0);
target-xtensa/translate.c:                    (dc->pc & ~3) + (CALL_OFFSET_SE << 2) + 4, 0);
target-xtensa/translate.c:            gen_jumpi(dc, dc->pc + 4 + CALL_OFFSET_SE, 0);
target-xtensa/translate.c:                    TCGv_i32 pc = tcg_const_i32(dc->pc);
target-xtensa/translate.c:                        uint32_t lend = dc->pc + RRI8_IMM8 + 4;
target-xtensa/translate.c:                        tcg_gen_movi_i32(cpu_SR[LBEG], dc->next_pc);
target-xtensa/translate.c:                        gen_jumpi(dc, dc->next_pc, 0);
target-xtensa/translate.c:            tcg_gen_qemu_##type(cpu_R[RRRN_T], addr, dc->cring); \
target-xtensa/translate.c:                    TCGv_i32 tmp = tcg_const_i32(dc->pc);
target-xtensa/translate.c:                if (dc->debug) {
target-xtensa/translate.c:    if (dc->is_jmp == DISAS_NEXT) {
target-xtensa/translate.c:    dc->pc = dc->next_pc;
target-xtensa/translate.c:    qemu_log("INVALID(pc = %08x)\n", dc->pc);
target-xtensa/translate.c:            if (bp->pc == dc->pc) {
target-xtensa/translate.c:                tcg_gen_movi_i32(cpu_pc, dc->pc);
target-xtensa/translate.c:                dc->is_jmp = DISAS_UPDATE;
target-xtensa/translate.c:    for (i = 0; i < dc->config->nibreak; ++i) {
target-xtensa/translate.c:                env->sregs[IBREAKA + i] == dc->pc) {
target-xtensa/cpu.c:    xcc->parent_realize = dc->realize;
target-xtensa/cpu.c:    dc->realize = xtensa_cpu_realizefn;
target-xtensa/cpu.c:    dc->vmsd = &vmstate_xtensa_cpu;
tests/test-qdev-global-props.c:    dc->realize = NULL;
tests/test-qdev-global-props.c:    dc->props = static_props;
tests/test-qdev-global-props.c:    dc->realize = NULL;
tests/Makefile~:check-qtest-i386-y += tests/fdc-test$(EXESUF)
tests/Makefile~:tests/fdc-test$(EXESUF): tests/fdc-test.o
tests/Makefile.rej: tests/fdc-test$(EXESUF): tests/fdc-test.o
tests/Makefile:check-qtest-i386-y += tests/fdc-test$(EXESUF)
tests/Makefile:tests/fdc-test$(EXESUF): tests/fdc-test.o
Binary file unicore32-linux-user/qemu-unicore32 matches
Binary file unicore32-softmmu/qemu-system-unicore32 matches
Binary file x86_64-linux-user/qemu-x86_64 matches
Binary file x86_64-softmmu/qemu-system-x86_64 matches
Binary file xtensaeb-softmmu/qemu-system-xtensaeb matches
Binary file xtensa-softmmu/qemu-system-xtensa matches
